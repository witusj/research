---
title: "Search Function"
---

## Setup

See "Scheduling Simulation" for all function descriptions.

```{python}
import numpy as np
from matplotlib import pyplot as plt
import time
import functions as fn
```

Configure global simulation parameters.

```{python}
## Global variables

cts = np.array([0, 1]) # client types -> normal or emergency
pct = np.array([1, 0]) # distribution of client types -> normal or emergency
# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing
# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution

nsh = 0.1 # percentage of no-shows
nsims = 100000 # number of simulations
logs = False # do not print simulation logs
lnm = 14 # lognormal mean
lns = 5 # lognormal standard deviation
nm = fn.logn_mean_lns(lnm, lns)[0] # normal mean
ns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation
d = 10 # interval time
T = 12 # number of intervals
sts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times
sim = np.zeros(T) 
i = np.arange(T, step=2)
sim[i] = 1
sim[-1] = 1
sim[0] = 2 
sim = sim.astype(int) # initial schedule
N = np.sum(sim)

ctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix
stsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix
nsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix
stsm = stsm * nsm # service times matrix with no-shows
```

## Run simulations and search

```{python}
print(f'Running {nsims} simulations with {N} patients and {T} timeslots.')

# Get start time and set timer seconds
start_time = time.time()
seconds = 30
bestresult = {
          'schedule': None,
          'iats': None,
          'iats_diff': None,
          'loss': None,
          'calc_time': None
          } # Dictionary for saving best result

# Start timer while loop
while True:
    current_time = time.time()
    elapsed_time = current_time - start_time
    
    if elapsed_time > seconds:
        print(f"Finished iterating in: {str(int(elapsed_time))} seconds\n")
        print(f"Best result:\nschedule: {bestresult['schedule']},\niats: {bestresult['iats']},\niats_diff: {bestresult['iats_diff']},\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\n")
        break
      
    
    ## data preparation
    psm = fn.patient_shift_matrix(sim).astype(int)
    print("Generated new psm\n")
    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) 
    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix
    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix
    
    ## Start iterator for inter arrival times in shift matrix
    results = [] # start list for saving results
    for iats in iats_sm:
      tic = time.time()
      simreswt = [None] * nsims # array for saving waiting times
      simresln = 0 # array for saving lateness
      
      for i in range(nsims): # simulate nsims number of times
        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)
        simreswt[i] = experiment[0].mean()
        ln = max(0, (experiment[1] - d))
        simresln += ln
        
      mwt = np.array(simreswt).mean()
      mln = simresln / nsims
      loss = 0.5 * mwt + 0.5 * mln
      toc = time.time()
      result = {
          'schedule': fn.transform_iats_schedule(iats, d, T)[0],
          'iats': iats,
          'iats_diff': np.diff(iats),
          'loss': loss,
          'calc_time': toc - tic
        }
      if bestresult['loss'] == None: # save first result as bestresult
            bestresult = result
      if result['loss'] < bestresult['loss']: # break loop on first improvement of loss value
            sim = result['schedule'] # assign current best schedule as new starting point for search
            bestresult = result
            print(f"\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\n")
            break
      
      results.append(result)
      print(f"schedule: {result['schedule']},\niats: {result['iats']},\niats_diff: {result['iats_diff']},\nloss = {result['loss']}, calc time: {result['calc_time']} secs\n")

```

```{python}

def distribute_elements(n, t):
    quotient, remainder = divmod(t, n-1)
    elements = np.zeros(t)
    for i in range(n-1):
        elements[i * quotient] = 1
    elements[0] = elements[0] + 1
    return elements
  

nsh = 0.1 # percentage of no-shows
nsims = 100000 # number of simulations
logs = False # do not print simulation logs
lnm = 20 # lognormal mean
lns = 5 # lognormal standard deviation
nm = fn.logn_mean_lns(lnm, lns)[0] # normal mean
ns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation
d = 10 # interval time
T = 24 # number of intervals
N = 9 # number of patients
sts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times
sim = distribute_elements(N, T)
sim = sim.astype(int) # initial schedule

ctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix
stsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix
nsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix
stsm = stsm * nsm # service times matrix with no-shows
```

```{python}
print(f'Running {nsims} simulations with {N} patients and {T} timeslots.')

# Get start time and set timer seconds
start_time = time.time()
seconds = 300
bestresult = {
          'schedule': None,
          'iats': None,
          'iats_diff': None,
          'loss': None,
          'calc_time': None
          } # Dictionary for saving best result

# Start timer while loop
while True:
    current_time = time.time()
    elapsed_time = current_time - start_time
    
    if elapsed_time > seconds:
        print(f"Finished iterating in: {str(int(elapsed_time))} seconds\n")
        print(f"Best result:\nschedule: {bestresult['schedule']},\niats: {bestresult['iats']},\niats_diff: {bestresult['iats_diff']},\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\n")
        break
      
    
    ## data preparation
    psm = fn.patient_shift_matrix(sim).astype(int)
    print("Generated new psm\n")
    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) 
    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix
    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix
    
    ## Start iterator for inter arrival times in shift matrix
    results = [] # start list for saving results
    for iats in iats_sm:
      tic = time.time()
      simreswt = [None] * nsims # array for saving waiting times
      simresln = 0 # array for saving lateness
      
      for i in range(nsims): # simulate nsims number of times
        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)
        simreswt[i] = experiment[0].mean()
        ln = max(0, (experiment[1] - d))
        simresln += ln
        
      mwt = np.array(simreswt).mean()
      mln = simresln / nsims
      loss = 0.5 * mwt + 0.5 * mln
      toc = time.time()
      result = {
          'schedule': fn.transform_iats_schedule(iats, d, T)[0],
          'iats': iats,
          'iats_diff': np.diff(iats),
          'loss': loss,
          'calc_time': toc - tic
        }
      if bestresult['loss'] == None: # save first result as bestresult
            bestresult = result
      if result['loss'] < bestresult['loss']: # break loop on first improvement of loss value
            sim = result['schedule'] # assign current best schedule as new starting point for search
            bestresult = result
            print(f"\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\n")
            break
      
      results.append(result)
      print(f"schedule: {result['schedule']},\niats: {result['iats']},\niats_diff: {result['iats_diff']},\nloss = {result['loss']}, calc time: {result['calc_time']} secs\n")

```
