[
  {
    "objectID": "local-search-schedule-probabilities.html",
    "href": "local-search-schedule-probabilities.html",
    "title": "Scheduling w/ Local Search",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\nfrom itertools import chain, combinations\nimport copy\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n    \ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]\n\ndef get_v_star(t):\n    # Create an initial vector 'u' of zeros with length 't'\n    u = np.zeros(t, dtype=np.int64)\n    # Set the first element of vector 'u' to -1\n    u[0] = -1\n    # Set the last element of vector 'u' to 1\n    u[-1] = 1\n    # Initialize the list 'v_star' with the initial vector 'u'\n    v_star = [u]\n    # Loop over the length of 'u' minus one times\n    for i in range(len(u) - 1):\n        # Append the last element of 'u' to the front of 'u'\n        u = np.append(u[-1], u)\n        # Remove the last element of 'u' to maintain the same length\n        u = np.delete(u, -1)\n        # Append the updated vector 'u' to the list 'v_star'\n        v_star.append(u)\n    # Convert the list of vectors 'v_star' into a NumPy array and return it\n    return(np.array(v_star))\n\n# Example of function call:\n# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row\n\ndef generate_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  logging.info(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}\n  # 'ids' will be a list of tuples, where each tuple is a subset of indices\n  ids = list(powerset(range(T)))\n\n  logging.info(f'Neighborhood size = {len(ids)}')\n\n  # Select the vectors from 'v_star' that correspond to the indices in each subset\n  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\n  sub_sets = [v_star[i] for i in ids]\n\n  # Sum the vectors within each subset and flatten the result to get a 1-D array\n  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\n  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n  \n  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  logging.info(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ndef generate_small_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  logging.info(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  neighborhood = np.array([schedule + v_star[i] for i in range(len(v_star))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  logging.info(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ndef distribute_patients(n_patients, n_timeslots):\n    # Create a list with all slots initially empty\n    distribution = [0] * n_timeslots\n\n    # Place patients in timeslots\n    for i in range(n_patients):\n        # Calculate the slot for each patient\n        slot = round(i * n_timeslots / n_patients)\n        distribution[slot] = 1\n\n    return distribution\n\ndef plot_timeline(slots, title):\n    # Create a figure\n    fig = go.Figure()\n\n    # Iterate over each timeslot and add a bar for occupied slots\n    for i, slot in enumerate(slots):\n        fig.add_trace(go.Bar(x=[i], y=[slot], width=0.8, marker_color='black'))\n\n    # Update layout\n    fig.update_layout(\n        title=title,\n        xaxis_title=\"Timeslots\",\n        yaxis=dict(showticklabels=False, showgrid=False, zeroline=False),\n        showlegend=False\n    )\n\n    # Set y-axis range\n    fig.update_yaxes(range=[0, np.max(slots)])\n\n    # Show the figure\n    fig.show()\n    \ndef service_time_with_no_shows(s, q):\n  # \"\"\"\n  # Function to adjust a distribution of service times for no-shows\n  # \n  # Args:\n  #     s (numpy.ndarray): An array with service times.\n  #     q (double): The fraction of no-shows.\n  # \n  # Returns:\n  #     numpy.ndarray: The adjusted array of service times.\n  # \"\"\"\n  \n  s_adj = s * (1-q)\n  s_adj[0] = s_adj[0] + q\n  return(s_adj)\n\ndef add_lists(short_list, long_list):\n  # \"\"\"\n  # This function takes in two lists and returns a new list where each element \n  # is the sum of the elements from the input lists at the corresponding position.\n  # If the lists are of different lengths, the shorter list is extended with zeros \n  # to match the length of the longer list.\n  # \n  # Parameters:\n  # - short_list (list): The shorter list of numbers.\n  # - long_list (list): The longer list of numbers.\n  # \n  # Returns:\n  # - list: A list containing the element-wise sum of the two input lists.\n  # \"\"\"\n  \n  # Extend the short lists to the length of the long list with zeros\n  short_list.extend([0] * (len(long_list) - len(short_list)))\n  \n  # Sum the elements of the two lists element-wise\n  result = [a + b for a, b in zip(short_list, long_list)]\n  \n  return result\n\ndef calculate_rolling_convolution(p_y, s):\n  conv_list = s\n  limit = len(p_y)\n  v = [x * p_y[0] for x in conv_list]\n  for i in range(1, limit):\n    conv_list = np.convolve(conv_list, s)\n    v = add_lists(v, [x * p_y[i] for x in conv_list])\n    \n  return(v)\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times. In the examples below we model service times as a Poisson process, because we are calculating in discrete time units.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for functions defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s, q):\n        \"\"\"\n        Initialize the Schedule class with patient schedules and a service time distribution.\n\n        Args:\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            d (int): An integer representing the length of a time interval.\n            s (list): A list of floats representing the probability distribution of service times.\n        \"\"\"\n        if not all(isinstance(i, np.integer) and i &gt;= 0 for i in x):\n            raise ValueError(\"All elements in x must be non-negative integers.\")\n        if not isinstance(d, int) or d &lt;= 0:\n            raise ValueError(\"d must be a positive integer.\")\n        if not all(isinstance(i, float) and 0 &lt;= i &lt;= 1 for i in s):\n            raise ValueError(\"All elements in s must be floats between 0 and 1.\")\n        if not isinstance(q, float) and 0 &lt;= q &lt;= 1:\n            raise ValueError(\"q must be a float between 0 and 1.\")\n\n        self.parameters = {'x': x, 'd': d, 's': s, 'q': q}\n        self.parameters['s'] = service_time_with_no_shows(self.parameters['s'], self.parameters['q'])\n        self._initialize_system()\n            \n    def _initialize_system(self):\n        \"\"\" Initialize the system's internal state. \"\"\"\n        self.state = 0\n        length_x = len(self.parameters['x'])\n        length_s = len(self.parameters['s'])\n        self.system = {\n            'p_min': np.zeros((length_x + 1, length_s), dtype=np.float64),\n            'p_plus': np.zeros((length_x, length_s), dtype=np.float64),\n            'w': [np.zeros((i, length_s), dtype=np.float64) for i in self.parameters['x']],\n            'ew': np.zeros(length_x, dtype=np.float64)\n        }\n        self.system['p_min'][0][0] = 1\n        if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n        self._update_p_plus(0)\n        self.state = 1\n            \n    def _update_p_plus(self, state):\n        \"\"\" Update the p_plus array based on the current state. \"\"\"\n        if self.parameters['x'][state] == 0:\n            self.system['p_plus'][state] = self.system['p_min'][state].copy()\n        else:\n            self.system['p_plus'][state] = np.convolve(self.system['w'][state][-1], self.parameters['s'], mode='full')[:len(self.parameters['s'])]\n        logging.info(f\"p_plus = {self.system['p_plus'][state]}\")\n            \n    def _calculate_state(self):\n        logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n        \n        \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n        logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n        self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n        \n        \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n        \n        self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n        \n        \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n        The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n        of waiting times of the first patient in state t and the service time distribution. \n        The resulting vector is truncated to the length of the service time distribution.\"\"\"\n        if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                logging.info(self.system['w'][self.state][0])\n                logging.info(f'{datetime.datetime.now()} - Done')\n                for i in range(1, self.parameters['x'][self.state]):\n                    logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                    self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                    logging.info(self.system['w'][self.state][i])\n\n        \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n        the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n        Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal \n        to the distribution of work at the beginning of t. \n        The resulting vector is truncated to the length of the service time distribution.\"\"\"\n        logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n        self._update_p_plus(self.state)\n    \n    def calculate_system_states(self, until=1):\n        \"\"\"\n        Calculate the probabilities of the system being in each state at each time step.\n\n        Args:\n            until (int, optional): The state until which to calculate the probabilities. Defaults to 1.\n        \"\"\"\n        while self.state &lt; until:\n            self._calculate_state()\n            self.state += 1\n  \n      \n    def local_search(self, omega=0.5):\n        \"\"\"\n        Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting times stop searching.  \n        \"\"\"\n        \n        # Calculate initial loss\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n        \n        # Continue the search until no improvement is found\n        while True:  # Start an outer loop that will continue until explicitly broken\n            nh = generate_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood\n            improved = False  # Flag to check if an improvement was found in the inner loop\n            \n            for y in nh:  # Inner loop to search through the neighborhood\n                # Insert first element of nh in x\n                self.parameters['x'] = y.copy()\n                logging.info(f\"Test schedule = {self.parameters['x']}\")\n                # Set starting state\n                self.state = 0\n                # If start state is 0 reinitialize p_min, w and p_plus in state 0\n                self._initialize_system()\n                self.calculate_system_states(until=len(self.parameters['x']))\n                logging.info(\"System recalculated\")\n                self.calculate_wait_times()\n                test_wt = self.system[\"ew\"].sum()\n                logging.info(f\"Average waiting time={test_wt / self.parameters['x'].sum()}\")\n                self.calculate_tardiness()\n                indices = np.arange(self.system['p_min'][-1].size) \n                exp_tard = (indices * self.system['p_min'][-1]).sum()\n                logging.info(f'Expected tardiness={exp_tard}')\n                test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n                logging.info(f'obj_value = {test_loss}')\n                # If a neighborhood with a lower waiting time is found, store the system\n                if(test_loss &lt; lowest_loss):\n                    lowest_loss = test_loss\n                    store_optim['x'] = self.parameters['x'].copy()\n                    newsystem = copy.deepcopy(self.system)\n                    store_optim['system'] = newsystem\n                    store_optim['tot_wt'] = test_wt\n                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                    improved = True  # Set the flag because an improvement was found\n                    break  # Exit the inner loop to generate a new neighborhood\n            \n            if not improved:  # If no improvement was found in the inner loop\n                logging.info(f'Finished searching')\n                # Set the system to the stored optimal system \n                logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                self.parameters['x'] = store_optim['x'].copy()\n                self.system['p_min'] = store_optim['system']['p_min']\n                self.system['p_plus'] = store_optim['system']['p_plus']\n                self.system['w'] = store_optim['system']['w']\n                self.system['ew'] = store_optim['system']['ew']\n                break  # Exit the outer loop - the search is complete\n      \n        \n    def small_local_search(self, omega=0.5):\n          \"\"\"\n          Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting stop searching.  \n          \"\"\"\n          # Calculate initial loss\n          test_wt = self.system[\"ew\"].sum()\n          self.calculate_tardiness()\n          indices = np.arange(self.system['p_min'][-1].size) \n          exp_tard = (indices * self.system['p_min'][-1]).sum()\n          lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n          store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n        \n          # Continue the search until no improvement is found\n          while True:  # Start an outer loop that will continue until explicitly broken\n              nh = generate_small_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood\n              improved = False  # Flag to check if an improvement was found in the inner loop\n              \n              for y in nh:  # Inner loop to search through the neighborhood\n                  # Insert first element of nh in x\n                  self.parameters['x'] = y.copy()\n                  logging.info(f\"Test schedule = {self.parameters['x']}\")\n                  # Set starting state\n                  self.state = 0\n                  # If start state is 0 reinitialize p_min, w and p_plus in state 0\n                  if(self.state == 0):\n                      self.system = dict({\n                          'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                          'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n                      })\n                      # Set the first element of p_min in the initial state to 1.\n                      self.system['p_min'][0][0] = 1\n                      # Initialize array of arrays for saving waiting times distributions per patient\n                      self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n                      if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                               self.system['w'][0][0] = self.system['p_min'][0].copy()\n                               for i in range(1, self.parameters['x'][0]):\n                                      self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                      self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                      # Initialize array for saving total expected waiting times per state\n                      self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n                      # Set the initial state to 1.\n                      self.state = 1\n                  self.calculate_system_states(until=len(self.parameters['x']))\n                  logging.info(\"System recalculated\")\n                  self.calculate_wait_times()\n                  test_wt = self.system[\"ew\"].sum()\n                  logging.info(f\"Average waiting time={test_wt / self.parameters['x'].sum()}\")\n                  self.calculate_tardiness()\n                  indices = np.arange(self.system['p_min'][-1].size) \n                  exp_tard = (indices * self.system['p_min'][-1]).sum()\n                  logging.info(f'Expected tardiness={exp_tard}')\n                  test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n                  logging.info(f'obj_value = {test_loss}')\n                  # If a schedule with a lower waiting time is found, store the system\n                  if(test_loss &lt; lowest_loss):\n                    lowest_loss = test_loss\n                    store_optim['x'] = self.parameters['x'].copy()\n                    newsystem = copy.deepcopy(self.system)\n                    store_optim['system'] = newsystem\n                    store_optim['tot_wt'] = test_wt\n                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]}')\n                    improved = True  # Set the flag because an improvement was found\n                    break  # Exit the inner loop to generate a new neighborhood\n              \n              if not improved:  # If no improvement was found in the inner loop\n                logging.info(f'Finished searching')\n                # Set the system to the stored optimal system \n                logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                self.parameters['x'] = store_optim['x'].copy()\n                self.system['p_min'] = store_optim['system']['p_min']\n                self.system['p_plus'] = store_optim['system']['p_plus']\n                self.system['w'] = store_optim['system']['w']\n                self.system['ew'] = store_optim['system']['ew']\n                break  # Exit the outer loop - the search is complete\n          \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      # logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n      for interval, wtdists in enumerate(self.system['w']):\n          ew = 0\n          for nr, dist in enumerate(wtdists):\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(dist))\n              b = dist\n              meanwt = np.dot(a, b)\n              logging.info(f\"Mean waiting time for patient {nr} in interval {interval} = {meanwt}\")\n              ew += meanwt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][interval] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values,\n                    colorscale=[\n                      [0, 'white'],  # white color at the bottom\n                      [1, 'red']     # red color at the top\n                    ]\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, q, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s, q=q)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.local_search(omega=omega)\n    return(schedule)\n\n\ndef run_schedule_small_search(x, d, s, q, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s, q=q)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.small_local_search(omega=omega)\n    return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\nq = 0.1\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\n# s= service_time_with_no_shows(s, q)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 5\nomega = 0.5\nsch = run_schedule(x, d, s, q, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n                                                \n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3\nsch = run_schedule(x, d, s, q, u, omega, False)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\n                                                \n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.5\nsch = run_schedule(x, d, s, q, u, omega, False)\nx_final = sch.parameters['x']\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\n\n                                                \n\n\n                                                \n\n\n\nsch.visualize_state(2)\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n                                                \n\n\n\nwith open(\"logs.txt\",'w') as file:\n  pass\nT = 12 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2\nx[1] = 1\nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.5\nsch = run_schedule(x, d, s, q, u, omega, False)\nsch.visualize_system('p_min')\nx_final = sch.parameters['x']\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\n\nInitial schedule: [2 1 1 0 1 0 1 0 1 0 1 1]\n\n\n                                                \n\n\n                                                \n\n\n                                                \n\n\n\nwith open(\"logs.txt\",'w') as file:\n  pass\n\nT = 14 # number of intervals\nN = 10\nx = np.array(distribute_patients(N, T))\n\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 5\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.999\nsch = run_schedule_small_search(x, d, s, q, u, omega, False)\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\nsch.visualize_system('p_min')\n\nInitial schedule: [1 1 0 1 1 0 1 1 1 0 1 1 0 1]\n\n\n                                                \n\n\n                                                \n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "convexity.html",
    "href": "convexity.html",
    "title": "Convexity",
    "section": "",
    "text": "import numpy as np\n\n# Define the function\ndef f(x):\n    return x**2\n\n# Define x1, x2 and t\nx1 = 1\nx2 = 3\nt = 0.5  # choose any value in [0, 1]\n\n# Compute the left-hand and right-hand side of the convexity inequality\nlhs = f(t*x1 + (1-t)*x2)\nrhs = t*f(x1) + (1-t)*f(x2)\n\n# Print the results\nprint(f\"Left-hand side: {lhs}\")\nprint(f\"Right-hand side: {rhs}\")\n\n# Check if the inequality holds\nif lhs &lt;= rhs:\n    print(\"The function is convex.\")\nelse:\n    print(\"The function is not convex.\")\n\na = (f(x2) - f(x1)) / (x2 - x1)\n\nb = f(x1) - a*x1\n\nprint(f'y = {a}x + {b}')\n\nLeft-hand side: 4.0\nRight-hand side: 5.0\nThe function is convex.\ny = 4.0x + -3.0\n\n\n\nfrom sympy import *\n\ndef g(x):\n  return 4*x - 3\n\nx = symbols('x')\nf = f(x)\ng = g(x)\n\nplot(f, g, (x, -1, 4))"
  },
  {
    "objectID": "search-function.html",
    "href": "search-function.html",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#setup",
    "href": "search-function.html#setup",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#run-simulations-and-search",
    "href": "search-function.html#run-simulations-and-search",
    "title": "Search Function",
    "section": "Run simulations and search",
    "text": "Run simulations and search\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 30\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 8 patients and 12 timeslots.\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 20 20 20 20 20 10],\niats_diff: [  0  20   0   0   0   0 -10],\nloss = 3.662546113948175, calc time: 1.2794361114501953 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 20 20 20 20 20 10  0],\niats_diff: [ 20   0   0   0   0 -10 -10],\nloss = 7.250588901845144, calc time: 1.326179027557373 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 10 30 20 20 20 10],\niats_diff: [  0  10  20 -10   0   0 -10],\nloss = 4.021963651011019, calc time: 1.29917573928833 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 20 10 30 20 20 10],\niats_diff: [  0  20 -10  20 -10   0 -10],\nloss = 3.8932554862482136, calc time: 1.2745471000671387 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 20 20 10 30 20 10],\niats_diff: [  0  20   0 -10  20 -10 -10],\nloss = 3.8306583217908994, calc time: 1.2400000095367432 secs\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 20 20 20 10 30 10],\niats_diff: [  0  20   0   0 -10  20 -20],\nloss = 3.7642389722501024, calc time: 1.2542800903320312 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 0 1 1 0 1] with loss: 3.044342875269389\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 20 20 20 20 10 20],\niats_diff: [  0  20   0   0   0 -10  10],\nloss = 3.044342875269389, calc time: 1.2658717632293701 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 1 0 2],\niats: [ 0 20 20 20 20 10 20  0],\niats_diff: [ 20   0   0   0 -10  10 -20],\nloss = 6.278311537956356, calc time: 1.307291030883789 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 10 30 20 20 10 20],\niats_diff: [  0  10  20 -10   0 -10  10],\nloss = 3.4033924045615382, calc time: 1.253857135772705 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 1 0 1],\niats: [ 0  0 20 10 30 20 10 20],\niats_diff: [  0  20 -10  20 -10 -10  10],\nloss = 3.272588727336865, calc time: 1.5062110424041748 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 1 0 1],\niats: [ 0  0 20 20 10 30 10 20],\niats_diff: [  0  20   0 -10  20 -20  10],\nloss = 3.198853290971254, calc time: 1.3597910404205322 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 1 0 1 0 1] with loss: 2.9039548735473817\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 20 20 20 10 20 20],\niats_diff: [  0  20   0   0 -10  10   0],\nloss = 2.9039548735473817, calc time: 1.2770979404449463 secs\n\nschedule: [1 0 1 0 1 0 1 1 0 1 0 2],\niats: [ 0 20 20 20 10 20 20  0],\niats_diff: [ 20   0   0 -10  10   0 -20],\nloss = 6.050726979947406, calc time: 1.3104681968688965 secs\n\nschedule: [2 1 0 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 10 30 20 10 20 20],\niats_diff: [  0  10  20 -10 -10  10   0],\nloss = 3.2621484006411574, calc time: 1.3528850078582764 secs\n\nschedule: [2 0 1 1 0 0 1 1 0 1 0 1],\niats: [ 0  0 20 10 30 10 20 20],\niats_diff: [  0  20 -10  20 -20  10   0],\nloss = 3.1243228203812277, calc time: 1.2652311325073242 secs\n\n\n#### Found better schedule: [2 0 1 0 1 1 0 1 0 1 0 1] with loss: 2.9014475232623385\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.9014475232623385, calc time: 1.2555961608886719 secs\n\nschedule: [1 0 1 0 1 1 0 1 0 1 0 2],\niats: [ 0 20 20 10 20 20 20  0],\niats_diff: [ 20   0 -10  10   0   0 -20],\nloss = 5.986973488487433, calc time: 1.2558131217956543 secs\n\nschedule: [2 1 0 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 10 30 10 20 20 20],\niats_diff: [  0  10  20 -20  10   0   0],\nloss = 3.2549043025431663, calc time: 1.251837968826294 secs\n\nschedule: [2 0 1 1 0 1 0 1 0 1 0 1],\niats: [ 0  0 20 10 20 20 20 20],\niats_diff: [  0  20 -10  10   0   0   0],\nloss = 2.9976572324570023, calc time: 1.2462430000305176 secs\n\nschedule: [2 0 1 0 2 0 0 1 0 1 0 1],\niats: [ 0  0 20 20  0 30 20 20],\niats_diff: [  0  20   0 -20  30 -10   0],\nloss = 3.3142049751171196, calc time: 1.2669169902801514 secs\n\nschedule: [2 0 1 0 1 1 1 0 0 1 0 1],\niats: [ 0  0 20 20 10 10 30 20],\niats_diff: [  0  20   0 -10   0  20 -10],\nloss = 3.1284174900657815, calc time: 1.2399370670318604 secs\n\nschedule: [2 0 1 0 1 1 0 1 1 0 0 1],\niats: [ 0  0 20 20 10 20 10 30],\niats_diff: [  0  20   0 -10  10 -10  20],\nloss = 3.016472856546239, calc time: 1.2746281623840332 secs\n\nschedule: [2 0 1 0 1 1 0 1 0 1 1 0],\niats: [ 0  0 20 20 10 20 20 10],\niats_diff: [  0  20   0 -10  10   0 -10],\nloss = 4.037552796193288, calc time: 1.2882819175720215 secs\n\nFinished iterating in: 33 seconds\n\nBest result:\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.9014475232623385, calc time: 1.2578659057617188 secs\n\n\n\n\ndef distribute_elements(n, t):\n    quotient, remainder = divmod(t, n-1)\n    elements = np.zeros(t)\n    for i in range(n-1):\n        elements[i * quotient] = 1\n    elements[0] = elements[0] + 1\n    return elements\n  \n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 20 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 24 # number of intervals\nN = 9 # number of patients\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = distribute_elements(N, T)\nsim = sim.astype(int) # initial schedule\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\n\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 300\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 9 patients and 24 timeslots.\nGenerated new psm\n\nschedule: [2 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0],\niats: [ 0  0 30 30 30 30 30 30 30],\niats_diff: [ 0 30  0  0  0  0  0  0],\nloss = 5.09726412059726, calc time: 1.4839818477630615 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1] with loss: 4.478825497850658\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 30 30 20],\niats_diff: [ 30   0   0   0   0   0   0 -10],\nloss = 4.478825497850658, calc time: 1.5447888374328613 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 2],\niats: [30 30 30 30 30 30 30 20  0],\niats_diff: [  0   0   0   0   0   0 -10 -20],\nloss = 12.124535454272072, calc time: 1.9307630062103271 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 20 40 30 30 30 30 30 20],\niats_diff: [ 20  20 -10   0   0   0   0 -10],\nloss = 4.550255818203546, calc time: 1.5164670944213867 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 20 40 30 30 30 30 20],\niats_diff: [ 30 -10  20 -10   0   0   0 -10],\nloss = 4.551934777066057, calc time: 1.3970670700073242 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 20 40 30 30 30 20],\niats_diff: [ 30   0 -10  20 -10   0   0 -10],\nloss = 4.553183990328361, calc time: 1.409027099609375 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 20 40 30 30 20],\niats_diff: [ 30   0   0 -10  20 -10   0 -10],\nloss = 4.552895311910661, calc time: 1.4079411029815674 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 20 40 30 20],\niats_diff: [ 30   0   0   0 -10  20 -10 -10],\nloss = 4.551423068413996, calc time: 1.7610650062561035 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 20 40 20],\niats_diff: [ 30   0   0   0   0 -10  20 -20],\nloss = 4.535378977240903, calc time: 1.4244842529296875 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1] with loss: 3.9998519628242066\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 30 20 30],\niats_diff: [ 30   0   0   0   0   0 -10  10],\nloss = 3.9998519628242066, calc time: 1.3361341953277588 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 2],\niats: [30 30 30 30 30 30 20 30  0],\niats_diff: [  0   0   0   0   0 -10  10 -30],\nloss = 11.478803941056114, calc time: 1.295271873474121 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 30 20 30],\niats_diff: [ 20  20 -10   0   0   0 -10  10],\nloss = 4.07127959373461, calc time: 1.332057237625122 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 30 20 30],\niats_diff: [ 30 -10  20 -10   0   0 -10  10],\nloss = 4.072957063595088, calc time: 1.4092309474945068 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 30 20 30],\niats_diff: [ 30   0 -10  20 -10   0 -10  10],\nloss = 4.074170816422878, calc time: 1.3989191055297852 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 30 20 30],\niats_diff: [ 30   0   0 -10  20 -10 -10  10],\nloss = 4.0735613376760265, calc time: 1.4107780456542969 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 40 20 30],\niats_diff: [ 30   0   0   0 -10  20 -20  10],\nloss = 4.0686941746592575, calc time: 1.5095412731170654 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1] with loss: 3.949551584320572\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 20 30 30],\niats_diff: [ 30   0   0   0   0 -10  10   0],\nloss = 3.949551584320572, calc time: 1.4602909088134766 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 30 20 30 30  0],\niats_diff: [  0   0   0   0 -10  10   0 -30],\nloss = 11.404846193882861, calc time: 1.3885219097137451 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 20 30 30],\niats_diff: [ 20  20 -10   0   0 -10  10   0],\nloss = 4.020975549618222, calc time: 1.3217079639434814 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 20 30 30],\niats_diff: [ 30 -10  20 -10   0 -10  10   0],\nloss = 4.022625151883249, calc time: 1.3146560192108154 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 20 30 30],\niats_diff: [ 30   0 -10  20 -10 -10  10   0],\nloss = 4.023603928422934, calc time: 1.3189589977264404 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 20 30 30],\niats_diff: [ 30   0   0 -10  20 -20  10   0],\nloss = 4.020956084084994, calc time: 1.3113112449645996 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.94297092097397\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 30 30 30],\niats_diff: [ 30   0   0   0 -10  10   0   0],\nloss = 3.94297092097397, calc time: 1.398230791091919 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 20 30 30 30  0],\niats_diff: [  0   0   0 -10  10   0   0 -30],\nloss = 11.394137462847457, calc time: 1.4574482440948486 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 20 30 30 30],\niats_diff: [ 20  20 -10   0 -10  10   0   0],\nloss = 4.014363733780281, calc time: 1.5553698539733887 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 20 30 30 30],\niats_diff: [ 30 -10  20 -10 -10  10   0   0],\nloss = 4.015825020918849, calc time: 1.3939967155456543 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 20 30 30 30],\niats_diff: [ 30   0 -10  20 -20  10   0   0],\nloss = 4.014835082737981, calc time: 1.4055397510528564 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.941971310278493\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.4257218837738037 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.311372995376587 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3241803646087646 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3331108093261719 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3274340629577637 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3232722282409668 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3291871547698975 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3258161544799805 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3136820793151855 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3040521144866943 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.350466012954712 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3047881126403809 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.323410987854004 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3187119960784912 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3147377967834473 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3442049026489258 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3388781547546387 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3493289947509766 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3340659141540527 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3162739276885986 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3316588401794434 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3150701522827148 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3268649578094482 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3404719829559326 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3326189517974854 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3279259204864502 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3198738098144531 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3157730102539062 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.308931827545166 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.307009220123291 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3583040237426758 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3029062747955322 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.305474042892456 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.323357343673706 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3078229427337646 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3104701042175293 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.332414150238037 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3189420700073242 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3707289695739746 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3206241130828857 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3562679290771484 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3109700679779053 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3146979808807373 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3141920566558838 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3119428157806396 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3160369396209717 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3162310123443604 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3086068630218506 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3261711597442627 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.328042984008789 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.6777310371398926 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3182201385498047 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3151302337646484 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3275690078735352 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.308293104171753 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3110737800598145 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3501052856445312 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3130548000335693 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3195850849151611 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3137290477752686 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3419499397277832 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.332383155822754 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.339609146118164 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.317478895187378 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3231041431427002 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3145759105682373 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3053288459777832 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3235840797424316 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3310580253601074 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3258130550384521 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3389701843261719 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.292933702468872 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3894660472869873 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3129808902740479 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.310013771057129 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.2945170402526855 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.4367060661315918 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3189620971679688 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3312671184539795 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3030002117156982 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.336949110031128 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.310269832611084 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.332298994064331 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.4288129806518555 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.313486099243164 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.425779104232788 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.307370901107788 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3425588607788086 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.326240062713623 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3063559532165527 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3332409858703613 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3265023231506348 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.314817190170288 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3307411670684814 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3367440700531006 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.30552077293396 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3108348846435547 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3260250091552734 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.327035903930664 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3153462409973145 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3202507495880127 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.338202953338623 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3204562664031982 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3104000091552734 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.319429874420166 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.311147928237915 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3463339805603027 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.361928939819336 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3260653018951416 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3270578384399414 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3407080173492432 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.2981319427490234 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.4977836608886719 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3752288818359375 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3323578834533691 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3231101036071777 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3490111827850342 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3714849948883057 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.5024948120117188 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.4507708549499512 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3784198760986328 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3181431293487549 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3268101215362549 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.338611125946045 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3222510814666748 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.306952953338623 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3376131057739258 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3287029266357422 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3821208477020264 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3459830284118652 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3524577617645264 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.31607985496521 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3393809795379639 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3579301834106445 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3381102085113525 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3368570804595947 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3396718502044678 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3301501274108887 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.339508056640625 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3273887634277344 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.341238021850586 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3104970455169678 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3168089389801025 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3456499576568604 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3229808807373047 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3228490352630615 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3214521408081055 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3184478282928467 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3333280086517334 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3324799537658691 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3478949069976807 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3155860900878906 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3747551441192627 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3369669914245605 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3305411338806152 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3123819828033447 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3304100036621094 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3175830841064453 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3372948169708252 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3220229148864746 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3518540859222412 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.32389235496521 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.3292529582977295 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.3298251628875732 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.4011046886444092 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.4627487659454346 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.5344600677490234 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.3759889602661133 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.3826658725738525 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.5076208114624023 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.6533119678497314 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.3968570232391357 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.4238767623901367 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.367638111114502 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.3766050338745117 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3693270683288574 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.4705579280853271 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.8199329376220703 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.4377222061157227 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.7014238834381104 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.6270089149475098 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39306658818889, calc time: 1.4128139019012451 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.013129383865734, calc time: 1.4136531352996826 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0126239747554, calc time: 1.4308781623840332 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9419907426697853, calc time: 1.4075007438659668 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.276853745462354, calc time: 1.3753290176391602 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.049932741840875, calc time: 1.3471288681030273 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.017827304855091, calc time: 1.337899923324585 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.985154688535664, calc time: 1.375749111175537 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5700042559212966, calc time: 1.3892080783843994 secs\n\nFinished iterating in: 302 seconds\n\nBest result:\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.941971310278493, calc time: 1.3949720859527588 secs"
  },
  {
    "objectID": "sim-based-opt.html",
    "href": "sim-based-opt.html",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#setup",
    "href": "sim-based-opt.html#setup",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#run-simulations",
    "href": "sim-based-opt.html#run-simulations",
    "title": "Simulation Based Optimization",
    "section": "Run simulations",
    "text": "Run simulations\n\n# Simulation 1\n\ntic = time.time()\nsim = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nN = len(iats) # number of patients\n# T = len(sim) # number of intervals\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimreswt = []\nsimresln = 0\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = loss = 0.5 * mwt + 0.5 * mln\ntoc = time.time()\nprint(toc - tic)\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\n1.7864136695861816\n\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 1 1 1 1 1 1 1], mwt: 1.6222892754727454, mln: 1.9931756105620877, loss: 1.8077324430174166')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Simulation 2\n\nsim = np.array([2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [2 0 1 1 1 1 1 1 1 1 1 1], mwt: 2.206595313724208, mln: 1.9903322416971536, loss: 2.098463777710681')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Simulation 3\n\nsim = np.array([1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 2 0 1 1 1 1 1 1 1], mwt: 2.2937956255958443, mln: 1.982546491681163, loss: 2.1381710586385037')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Simulation 4\n\nsim = np.array([1, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 2 0 1 1 1 1 1], mwt: 2.302365722768532, mln: 1.9688381974928553, loss: 2.1356019601306935')"
  },
  {
    "objectID": "noshow.html",
    "href": "noshow.html",
    "title": "No-shows and emergency patients",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nLet the number of arriving emergency patients be \\(Y\\). Then the amount of work arriving is the Y-fold convolution of the vector representing the service time for emergency patients, \\(s_e^{(Y)}\\). In this vector the \\(j\\)th element \\(s_{ej}\\) denotes the probability that the service time of an emergency patient is \\(j\\) minutes. Then the distribution of the amount of emergency work arriving at the start of any interval is given by:\n\\[v_0(i) = \\sum\\limits_{y=1}^{\\infty}s_{ei}^{(Y)}P(Y=y) = \\Big(\\sum\\limits_{y=1}^{\\infty}P(Y=y)s_{e}^{(y)}\\Big)_i\\]\n\nimport numpy as np\nfrom scipy.stats import poisson\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\n\ndef service_time_with_no_shows(s, q):\n  # \"\"\"\n  # Function to adjust a distribution of service times for no-shows\n  # \n  # Args:\n  #     s (numpy.ndarray): An array with service times.\n  #     q (double): The fraction of no-shows.\n  # \n  # Returns:\n  #     numpy.ndarray: The adjusted array of service times.\n  # \"\"\"\n  \n  s_adj = s * (1-q)\n  s_adj[0] = s_adj[0] + q\n  \n  return(s_adj)\n\ndef add_lists(short_list, long_list):\n  # \"\"\"\n  # This function takes in two lists and returns a new list where each element \n  # is the sum of the elements from the input lists at the corresponding position.\n  # If the lists are of different lengths, the shorter list is extended with zeros \n  # to match the length of the longer list.\n  # \n  # Parameters:\n  # - short_list (list): The shorter list of numbers.\n  # - long_list (list): The longer list of numbers.\n  # \n  # Returns:\n  # - list: A list containing the element-wise sum of the two input lists.\n  # \"\"\"\n  \n  # Extend the short lists to the length of the long list with zeros\n  short_list.extend([0] * (len(long_list) - len(short_list)))\n  \n  # Sum the elements of the two lists element-wise\n  result = [a + b for a, b in zip(short_list, long_list)]\n  \n  return result\n\ndef calculate_rolling_convolution(p_y, s, limit):\n  conv_list = s\n  v = [x * p_y[0] for x in conv_list]\n  for i in range(1, limit):\n    conv_list = np.convolve(conv_list, s)\n    v = add_lists(v, [x * p_y[i] for x in conv_list])\n  print(f'conv_list = {conv_list[:10]} (first ten elements) with sum {sum(conv_list)}, v = {v[:10]} with sum {sum(v)}')\n  return(v)\n\n\n### TEST ###\n\ns = np.array([0.0, 0.5, 0.2, 0.3])\nq = 0.1\ns_adj = service_time_with_no_shows(s, q)\nprint(f'adjusted service times={s_adj}, with sum  {s_adj.sum()}')\n\nadjusted service times=[0.1  0.45 0.18 0.27], with sum  1.0\n\n\n\n### TEST 2 ###\n\np_y = [0.5, 0.3, 0.2]\ns = [0.1, 0.2, 0.7]\nlimit = 3\nv = calculate_rolling_convolution(p_y, s, limit)\n\nconv_list = [0.001 0.006 0.033 0.092 0.231 0.294 0.343] (first ten elements) with sum 1.0, v = [0.053200000000000004, 0.11320000000000001, 0.41059999999999997, 0.10239999999999999, 0.19319999999999996, 0.0588, 0.06859999999999998] with sum 0.9999999999999999\n\n\n\ntrace = go.Scatter(\n            x = list(range(len(v))),\n            y = v,\n            mode = 'lines'\n        )\n        \ndata = [trace]\n\nlayout = go.Layout(\n    title = f'distribution of v',\n    xaxis = dict(title='Time'),\n    yaxis = dict(title='Probability')\n)\n\nfig = go.Figure(data=data, layout=layout)\npyo.iplot(fig)\n\n                                                \n\n\n\n### TEST 3 ###\n\nlen_y = 300\nlen_se = 300\np_y = [poisson.pmf(i, 2) for i in range(0, len_y)]\nse = [poisson.pmf(j, 10) for j in range(0, len_se)]\nprint(sum(p_y), sum(se))\n\n\nv = calculate_rolling_convolution(p_y, se, len_y)\n\n0.9999999999999999 1.0000000000000022\nconv_list = [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] (first ten elements) with sum 1.0000000000006708, v = [6.144770272275882e-06, 6.145328216553419e-05, 0.00030732220778848765, 0.0010247793643651344, 0.002563808626256866, 0.0051350592539100804, 0.00858324446168137, 0.01233269472644276, 0.015593252353944275, 0.0177203279998164] with sum 1.0000000000000064\n\n\n\ntrace = go.Scatter(\n            x = list(range(len(v))),\n            y = v[:len_y],\n            mode = 'lines'\n        )\n        \ndata = [trace]\n\nlayout = go.Layout(\n    title = f'distribution of v',\n    xaxis = dict(title='Time'),\n    yaxis = dict(title='Probability')\n)\n\nfig = go.Figure(data=data, layout=layout)\npyo.iplot(fig)\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "schedule-probabilities.html",
    "href": "schedule-probabilities.html",
    "title": "Scheduling w/ Nested Partitions",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \ndef weak_compositions(n, k):\n    if k == 1:\n        return [[n]]\n    compositions = []\n    for i in range(n + 1):\n        for composition in weak_compositions(n - i, k - 1):\n            compositions.append([i] + composition)\n    return compositions\n  \nprint(f'Weak compositions are: {weak_compositions(2, 4)}')\n\n\nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n        \nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\nWeak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for functions defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s):\n            \"\"\"\n            Initialize the class with a schedule of patients and a service time distribution.\n            \n            Args:\n            d (int): An integer representing the time lenght of an interval.\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            s (list): A list of floats representing the probability distribution of service times.\n            \"\"\"\n            \n            self.parameters = dict({'x': x, 'd': d, 's': s})\n            logging.info(f'{datetime.datetime.now()} - x = {self.parameters[\"x\"]}')\n            # Initialize the system dictionary with p_min and p_plus. p_min has one element extra for storing tardiness\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        \n    def calculate_system_states(self, until = 1):\n            \"\"\"\n            Calculate the probabilities of the system being in each state at each time step.\n            \n            Args:\n            until (int): An optional integer representing the state until which to calculate the probabilities.\n            \"\"\"\n            \n            while self.state &lt; until:\n                logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n                \n                \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n                \n                \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n                \n                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n                \n                \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n                The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n                of waiting times of the first patient in state t and the service time distribution. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                     logging.info(f'{datetime.datetime.now()} - Done')\n                     for i in range(1, self.parameters['x'][self.state]):\n                            logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n\n                \n                \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n                the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n                Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal \n                to the distribution of work at the beginning of t. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                \"\"\"Jump to next state\"\"\"\n                self.state += 1\n    \n    def impute_compositions(self, s=0, k=2, omega=0.5):\n      \"\"\"\n      Impute the compositions of patients in a given time interval and establish the schedule with the lowest total waiting time.\n      \n      Args:\n      s (int): An integer representing the starting state.\n      k (int): An integer representing the number of states from the starting state to include in the compositions.\n      \"\"\"\n      logging.info(f'{datetime.datetime.now()} - Running impute_compositions() in state {self.state} with x = {self.parameters[\"x\"]}')\n      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end.\n      t = min(len(self.parameters['x']), s+k)\n      k = t - s\n      c = self.parameters['x'][s:t]\n      n = c.sum()\n      # Calculate initial loss\n      test_wt = self.system[\"ew\"].sum()\n      self.calculate_tardiness()\n      indices = np.arange(self.system['p_min'][-1].size) \n      exp_tard = (indices * self.system['p_min'][-1]).sum()\n      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n      # Generate compositions\n      compositions = weak_compositions(n, k)\n      logging.info(f'{datetime.datetime.now()} - Computing {len(compositions)} compositions')\n      # For all compositions calculate the waiting times\n      for comp in compositions:\n        # Insert composition in x\n        self.parameters['x'][s:t] = comp.copy()\n        # Set starting state\n        self.state = s\n        # Adjust the array for waiting time distributions to new x\n        self.system['w'][s:] = zero_arrays(self.parameters['x'][s:].copy(), len(self.parameters['s']))\n        # Recalculate distributions\n        # If start state is 0 reinitialize p_min, w and p_plus in state 0\n        if(self.state == 0):\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        self.calculate_system_states(until=len(self.parameters['x']))\n        self.calculate_wait_times()\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        # If a composition with a lower waiting time is found, store the system\n        if(test_loss &lt; lowest_loss):\n          lowest_loss = test_loss\n          store_optim['x'] = self.parameters['x'].copy()\n          newsystem = copy.deepcopy(self.system)\n          store_optim['system'] = newsystem\n          store_optim['tot_wt'] = test_wt\n          logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      # Set the system to the stored optimal system\n      self.parameters['x'] = store_optim['x'].copy()\n      self.system['p_min'] = store_optim['system']['p_min']\n      self.system['p_plus'] = store_optim['system']['p_plus']\n      self.system['w'] = store_optim['system']['w']\n      self.system['ew'] = store_optim['system']['ew']\n        \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def search_function(self, k=1, omega=0.5):\n      \"\"\"\n      Slide over the schedule intervals and run inpute_compositions()\n      \"\"\"\n      for i in range(0, len(self.parameters['x'] - k)):\n        self.impute_compositions(s=i, k=k, omega=omega)\n      \n      \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n    # Initialize time counter\n      t = 0\n      # Calculate the expected waiting time for each time step\n      for t, w in enumerate(self.system['w']):\n          ew = 0\n          for i in w:\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(i))\n              b = i\n              wt = np.dot(a, b)\n              ew += wt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][t] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.search_function(k=3, omega=omega)\n    return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 5\nomega = 0.5\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n                                                \n\n\n                                                \n\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = len(x)\nomega = 1\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n                                                \n\n\n                                                \n\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = len(x)\nomega = 0\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n                                                \n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\n                                                \n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3  \nsch = run_schedule(x, d, s, u, omega, False)\n\n\nsch.visualize_state(2)\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n                                                \n\n\n\nT = 24 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2 \nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_plus')\n\nInitial schedule: [2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1]\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "sched-sim.html",
    "href": "sched-sim.html",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#setup",
    "href": "sched-sim.html#setup",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#run-simulation-1",
    "href": "sched-sim.html#run-simulation-1",
    "title": "Scheduling Simulation",
    "section": "Run simulation 1",
    "text": "Run simulation 1\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14 \nlns = 5\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], dtype=object) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time= {mwt}\")"
  },
  {
    "objectID": "sched-sim.html#run-simulation-2",
    "href": "sched-sim.html#run-simulation-2",
    "title": "Scheduling Simulation",
    "section": "Run simulation 2",
    "text": "Run simulation 2\n\nConfigure parameters.\n\n# Configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving silnmlation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n\nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times.\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")"
  },
  {
    "objectID": "sched-sim.html#run-simulation-3",
    "href": "sched-sim.html#run-simulation-3",
    "title": "Scheduling Simulation",
    "section": "Run simulation 3",
    "text": "Run simulation 3\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 0, 0, 60, 0, 0, 0, 60, 0, 0, 0]) # inter-arrival times\n\nnsims = nsims # number of simulations\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Experiments",
    "section": "",
    "text": "This site contains the code experiments for my research on appointment scheduling optimization. Specifically I am working on solution methods for single stage stochastic programming problems (1-SSP) and so-called off-line scheduling system. In an off-line scheduling system all patients that want an appointment in a specific time-frame (e.g. day) are gathered first and then given an appointment time. An example of such a problem is scheduling a number of patients into a series of fixed time slots for a single physician. Each patient will have a certain service time that can not be predicted, but has some known distribution with a mean and variance. If a certain patient needs more time to consult than his time slot the next patient will start later. In case the patient finishes earlier, the doctor has idle time.\nBoth waiting times - for patient and doctor - are undesirable. The question is how to find an optimal schedule that minimizes total waiting times. Weights can be given to both types of waiting times to accommodate for different utilities of saved time for patients and doctors.\nSolution methods for these kinds of problems can be divided into two types: (1) analytical and (2) numerical. Analytical methods applies mathematical principles to a problem in order to obtain provable results. Numerical methods use sets of iterative procedures to find solutions to problems that are hard to solve by analytical methods. A numerical method is considered accurate if it finds: (1) an optimal solution in a given time or (2) a perturbed (or near-optimal) solution with a known deterministic error bound, which is a bound on the solution’s (relative or absolute) optimality gap. An inaccurate method does not produce an error bound and the quality of the solution can not be determined (Ahmadi-Javid, Jalali, and Klassen 2017).\nIdeas:\n\nApply utility function to waiting times -&gt; one minute of waiting is more acceptable than 30 minutes of waiting.\n\n\n\n\n\n\nReferences\n\nAhmadi-Javid, Amir, Zahra Jalali, and Kenneth J Klassen. 2017. “Outpatient Appointment Systems in Healthcare: A Review of Optimization Studies.” European Journal of Operational Research 258 (1): 3–34. https://doi.org/10.1016/j.ejor.2016.06.064."
  },
  {
    "objectID": "local-search-function.html",
    "href": "local-search-function.html",
    "title": "Local Search Function",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nfrom scipy.special import comb\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nfrom itertools import chain, combinations\nimport copy\n\nSchedule \\(x\\) is a vector with each element representing the number of scheduled patients.\n\n#x = [2, 1, 0, 2]\nx = [2, 0, 0, 0, 2]\n\nThe number of possible schedules is\n\\[\\dbinom{N+T-1}{N}\\]\n\nN = sum(x)\nT = len(x)\nresult = comb(N + T - 1, N, exact=True)  # exact=True returns the exact integer\nprint(result) \n\n70\n\n\n\ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]\n\n\ntest = powerset([1,2,3])\nlist(test)\n\n[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n\nDefine the vectors\n\\[\n\\left\\{\n\\begin{array}{c}\n\\vec{u_1}, \\\\\n\\vec{u_2}, \\\\\n\\vec{u_3}, \\\\\n\\vdots \\\\\n\\vec{u_{T-1}}, \\\\\n\\vec{u_T} \\\\\n\\end{array}\n\\right\\} =\n\\left\\{\n\\begin{array}{c}\n(-1, 0,...., 0, 1), \\\\\n(1, -1, 0,...., 0), \\\\\n(0, 1, -1,...., 0), \\\\\n\\vdots \\\\\n(0,...., 1, -1, 0), \\\\\n(0,...., 0, 1, -1) \\\\\n\\end{array}\n\\right\\}\n\\] and take \\(V^* = \\{u_1,....,u_T\\}\\).\n\ndef get_v_star(t):\n    # Create an initial vector 'u' of zeros with length 't'\n    u = np.zeros(t)\n    # Set the first element of vector 'u' to -1\n    u[0] = -1\n    # Set the last element of vector 'u' to 1\n    u[-1] = 1\n    # Initialize the list 'v_star' with the initial vector 'u'\n    v_star = [u]\n    # Loop over the length of 'u' minus one times\n    for i in range(len(u) - 1):\n        # Append the last element of 'u' to the front of 'u'\n        u = np.append(u[-1], u)\n        # Remove the last element of 'u' to maintain the same length\n        u = np.delete(u, -1)\n        # Append the updated vector 'u' to the list 'v_star'\n        v_star.append(u)\n    # Convert the list of vectors 'v_star' into a NumPy array and return it\n    return(np.array(v_star))\n\n# Example of function call:\n# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row\nget_v_star(4)\n\narray([[-1.,  0.,  0.,  1.],\n       [ 1., -1.,  0.,  0.],\n       [ 0.,  1., -1.,  0.],\n       [ 0.,  0.,  1., -1.]])\n\n\nAs the neighborhood of schedule \\(x\\) we take all vectors of the form \\(x + v_1+..+v_k\\) with \\(v_1,....,v_k \\in V^*\\)\n\n# Set the value of 't'\nt = len(x)\n\n# Generate a matrix 'v_star' using the 'get_v_star' function\nv_star = get_v_star(t)\n\n# Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., t-1}\n# 'ids' will be a list of tuples, where each tuple is a subset of indices\nids = list(powerset(range(t)))\n\n# Select the vectors from 'v_star' that correspond to the indices in each subset\n# 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\nsub_sets = [v_star[i] for i in ids]\n\n# Sum the vectors within each subset and flatten the result to get a 1-D array\n# 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\nsummed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n\n# 'summed_sets' is the final output\nsummed_sets\n\n[array([0., 0., 0., 0., 0.]),\n array([-1.,  0.,  0.,  0.,  1.]),\n array([ 1., -1.,  0.,  0.,  0.]),\n array([ 0.,  1., -1.,  0.,  0.]),\n array([ 0.,  0.,  1., -1.,  0.]),\n array([ 0.,  0.,  0.,  1., -1.]),\n array([ 0., -1.,  0.,  0.,  1.]),\n array([-1.,  1., -1.,  0.,  1.]),\n array([-1.,  0.,  1., -1.,  1.]),\n array([-1.,  0.,  0.,  1.,  0.]),\n array([ 1.,  0., -1.,  0.,  0.]),\n array([ 1., -1.,  1., -1.,  0.]),\n array([ 1., -1.,  0.,  1., -1.]),\n array([ 0.,  1.,  0., -1.,  0.]),\n array([ 0.,  1., -1.,  1., -1.]),\n array([ 0.,  0.,  1.,  0., -1.]),\n array([ 0.,  0., -1.,  0.,  1.]),\n array([ 0., -1.,  1., -1.,  1.]),\n array([ 0., -1.,  0.,  1.,  0.]),\n array([-1.,  1.,  0., -1.,  1.]),\n array([-1.,  1., -1.,  1.,  0.]),\n array([-1.,  0.,  1.,  0.,  0.]),\n array([ 1.,  0.,  0., -1.,  0.]),\n array([ 1.,  0., -1.,  1., -1.]),\n array([ 1., -1.,  1.,  0., -1.]),\n array([ 0.,  1.,  0.,  0., -1.]),\n array([ 0.,  0.,  0., -1.,  1.]),\n array([ 0.,  0., -1.,  1.,  0.]),\n array([ 0., -1.,  1.,  0.,  0.]),\n array([-1.,  1.,  0.,  0.,  0.]),\n array([ 1.,  0.,  0.,  0., -1.]),\n array([0., 0., 0., 0., 0.])]\n\n\n\ny = np.array([x + summed_sets[i] for i in range(len(summed_sets))])\ny\n\narray([[ 2.,  0.,  0.,  0.,  2.],\n       [ 1.,  0.,  0.,  0.,  3.],\n       [ 3., -1.,  0.,  0.,  2.],\n       [ 2.,  1., -1.,  0.,  2.],\n       [ 2.,  0.,  1., -1.,  2.],\n       [ 2.,  0.,  0.,  1.,  1.],\n       [ 2., -1.,  0.,  0.,  3.],\n       [ 1.,  1., -1.,  0.,  3.],\n       [ 1.,  0.,  1., -1.,  3.],\n       [ 1.,  0.,  0.,  1.,  2.],\n       [ 3.,  0., -1.,  0.,  2.],\n       [ 3., -1.,  1., -1.,  2.],\n       [ 3., -1.,  0.,  1.,  1.],\n       [ 2.,  1.,  0., -1.,  2.],\n       [ 2.,  1., -1.,  1.,  1.],\n       [ 2.,  0.,  1.,  0.,  1.],\n       [ 2.,  0., -1.,  0.,  3.],\n       [ 2., -1.,  1., -1.,  3.],\n       [ 2., -1.,  0.,  1.,  2.],\n       [ 1.,  1.,  0., -1.,  3.],\n       [ 1.,  1., -1.,  1.,  2.],\n       [ 1.,  0.,  1.,  0.,  2.],\n       [ 3.,  0.,  0., -1.,  2.],\n       [ 3.,  0., -1.,  1.,  1.],\n       [ 3., -1.,  1.,  0.,  1.],\n       [ 2.,  1.,  0.,  0.,  1.],\n       [ 2.,  0.,  0., -1.,  3.],\n       [ 2.,  0., -1.,  1.,  2.],\n       [ 2., -1.,  1.,  0.,  2.],\n       [ 1.,  1.,  0.,  0.,  2.],\n       [ 3.,  0.,  0.,  0.,  1.],\n       [ 2.,  0.,  0.,  0.,  2.]])\n\n\nsuch that \\(x + v_1+..+v_k \\ge 0\\)\n\nimport numpy as np\n\n# Create a mask for rows with negative values\nmask = ~np.any(y &lt; 0, axis=1)\n\n# Filter out rows with negative values using the mask\nfiltered_y = y[mask]\n\nfiltered_y\n\narray([[2., 0., 0., 0., 2.],\n       [1., 0., 0., 0., 3.],\n       [2., 0., 0., 1., 1.],\n       [1., 0., 0., 1., 2.],\n       [2., 0., 1., 0., 1.],\n       [1., 0., 1., 0., 2.],\n       [2., 1., 0., 0., 1.],\n       [1., 1., 0., 0., 2.],\n       [3., 0., 0., 0., 1.],\n       [2., 0., 0., 0., 2.]])\n\n\nSo the whole neighborhood function becomes.\n\ndef generate_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  print(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}\n  # 'ids' will be a list of tuples, where each tuple is a subset of indices\n  ids = list(powerset(range(T)))\n\n  # Select the vectors from 'v_star' that correspond to the indices in each subset\n  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\n  sub_sets = [v_star[i] for i in ids]\n\n  # Sum the vectors within each subset and flatten the result to get a 1-D array\n  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\n  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n  \n  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  print(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ntestnh = generate_search_neighborhood(x)\n\nThe schedule = [2, 0, 0, 0, 2]\nAnd the neighborhood is [[2. 0. 0. 0. 2.]\n [1. 0. 0. 0. 3.]\n [2. 0. 0. 1. 1.]\n [1. 0. 0. 1. 2.]\n [2. 0. 1. 0. 1.]\n [1. 0. 1. 0. 2.]\n [2. 1. 0. 0. 1.]\n [1. 1. 0. 0. 2.]\n [3. 0. 0. 0. 1.]\n [2. 0. 0. 0. 2.]]\n\n\nLet the objective function be a simple sum of square.\n\ndef obj_function(x):\n  res = sum(map(lambda i: i * i, x))\n  return res\n\nobj_function(np.array(x))\n\n8\n\n\nThe algorithm for computing an optimal schedule becomes.\n\ndef search_best_solution(x):\n    obj_value = obj_function(x)\n    \n    # Keep track of the best solution found\n    best_solution = x.copy()\n    \n    # Continue the search until no improvement is found\n    while True:  # Start an outer loop that will continue until explicitly broken\n        nh = generate_search_neighborhood(best_solution)  # Generate a new neighborhood\n        improved = False  # Flag to check if an improvement was found in the inner loop\n        \n        for y in nh:  # Inner loop to search through the neighborhood\n            c = obj_function(y)\n            if c &lt; obj_value:\n                obj_value = c\n                best_solution = y.copy()\n                print(f'Found better schedule {best_solution} with objective value {obj_value}')\n                improved = True  # Set the flag because an improvement was found\n                break  # Exit the inner loop to generate a new neighborhood\n        \n        if not improved:  # If no improvement was found in the inner loop\n            break  # Exit the outer loop - the search is complete\n\n    return best_solution, obj_value\n\n# Example usage:\nx = [5, 0, 0, 0, 1]\ninitial_solution = x  # Replace this with your actual initial solution\nbest_solution, best_obj_value = search_best_solution(initial_solution)\nprint(\"Best solution found:\", best_solution)\nprint(\"Objective value of the best solution:\", best_obj_value)\n\nThe schedule = [5, 0, 0, 0, 1]\nAnd the neighborhood is [[5. 0. 0. 0. 1.]\n [4. 0. 0. 0. 2.]\n [5. 0. 0. 1. 0.]\n [4. 0. 0. 1. 1.]\n [5. 0. 1. 0. 0.]\n [4. 0. 1. 0. 1.]\n [5. 1. 0. 0. 0.]\n [4. 1. 0. 0. 1.]\n [6. 0. 0. 0. 0.]\n [5. 0. 0. 0. 1.]]\nFound better schedule [4. 0. 0. 0. 2.] with objective value 20.0\nThe schedule = [4. 0. 0. 0. 2.]\nAnd the neighborhood is [[4. 0. 0. 0. 2.]\n [3. 0. 0. 0. 3.]\n [4. 0. 0. 1. 1.]\n [3. 0. 0. 1. 2.]\n [4. 0. 1. 0. 1.]\n [3. 0. 1. 0. 2.]\n [4. 1. 0. 0. 1.]\n [3. 1. 0. 0. 2.]\n [5. 0. 0. 0. 1.]\n [4. 0. 0. 0. 2.]]\nFound better schedule [3. 0. 0. 0. 3.] with objective value 18.0\nThe schedule = [3. 0. 0. 0. 3.]\nAnd the neighborhood is [[3. 0. 0. 0. 3.]\n [2. 0. 0. 0. 4.]\n [3. 0. 0. 1. 2.]\n [2. 0. 0. 1. 3.]\n [3. 0. 1. 0. 2.]\n [2. 0. 1. 0. 3.]\n [3. 1. 0. 0. 2.]\n [2. 1. 0. 0. 3.]\n [4. 0. 0. 0. 2.]\n [3. 0. 0. 0. 3.]]\nFound better schedule [3. 0. 0. 1. 2.] with objective value 14.0\nThe schedule = [3. 0. 0. 1. 2.]\nAnd the neighborhood is [[3. 0. 0. 1. 2.]\n [2. 0. 0. 1. 3.]\n [3. 0. 1. 0. 2.]\n [3. 0. 0. 2. 1.]\n [2. 0. 1. 0. 3.]\n [2. 0. 0. 2. 2.]\n [3. 1. 0. 0. 2.]\n [3. 0. 1. 1. 1.]\n [2. 1. 0. 0. 3.]\n [2. 0. 1. 1. 2.]\n [4. 0. 0. 0. 2.]\n [3. 1. 0. 1. 1.]\n [3. 0. 0. 0. 3.]\n [2. 1. 0. 1. 2.]\n [4. 0. 0. 1. 1.]\n [3. 0. 0. 1. 2.]]\nFound better schedule [2. 0. 0. 2. 2.] with objective value 12.0\nThe schedule = [2. 0. 0. 2. 2.]\nAnd the neighborhood is [[2. 0. 0. 2. 2.]\n [1. 0. 0. 2. 3.]\n [2. 0. 1. 1. 2.]\n [2. 0. 0. 3. 1.]\n [1. 0. 1. 1. 3.]\n [1. 0. 0. 3. 2.]\n [2. 1. 0. 1. 2.]\n [2. 0. 1. 2. 1.]\n [1. 1. 0. 1. 3.]\n [1. 0. 1. 2. 2.]\n [3. 0. 0. 1. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 0. 1. 3.]\n [1. 1. 0. 2. 2.]\n [3. 0. 0. 2. 1.]\n [2. 0. 0. 2. 2.]]\nFound better schedule [2. 0. 1. 1. 2.] with objective value 10.0\nThe schedule = [2. 0. 1. 1. 2.]\nAnd the neighborhood is [[2. 0. 1. 1. 2.]\n [1. 0. 1. 1. 3.]\n [2. 1. 0. 1. 2.]\n [2. 0. 2. 0. 2.]\n [2. 0. 1. 2. 1.]\n [1. 1. 0. 1. 3.]\n [1. 0. 2. 0. 3.]\n [1. 0. 1. 2. 2.]\n [3. 0. 0. 1. 2.]\n [2. 1. 1. 0. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 2. 1. 1.]\n [2. 0. 0. 1. 3.]\n [1. 1. 1. 0. 3.]\n [1. 1. 0. 2. 2.]\n [1. 0. 2. 1. 2.]\n [3. 0. 1. 0. 2.]\n [3. 0. 0. 2. 1.]\n [2. 1. 1. 1. 1.]\n [2. 0. 1. 0. 3.]\n [2. 0. 0. 2. 2.]\n [1. 1. 1. 1. 2.]\n [3. 0. 1. 1. 1.]\n [2. 0. 1. 1. 2.]]\nFound better schedule [2. 1. 1. 1. 1.] with objective value 8.0\nThe schedule = [2. 1. 1. 1. 1.]\nAnd the neighborhood is [[2. 1. 1. 1. 1.]\n [1. 1. 1. 1. 2.]\n [3. 0. 1. 1. 1.]\n [2. 2. 0. 1. 1.]\n [2. 1. 2. 0. 1.]\n [2. 1. 1. 2. 0.]\n [2. 0. 1. 1. 2.]\n [1. 2. 0. 1. 2.]\n [1. 1. 2. 0. 2.]\n [1. 1. 1. 2. 1.]\n [3. 1. 0. 1. 1.]\n [3. 0. 2. 0. 1.]\n [3. 0. 1. 2. 0.]\n [2. 2. 1. 0. 1.]\n [2. 2. 0. 2. 0.]\n [2. 1. 2. 1. 0.]\n [2. 1. 0. 1. 2.]\n [2. 0. 2. 0. 2.]\n [2. 0. 1. 2. 1.]\n [1. 2. 1. 0. 2.]\n [1. 2. 0. 2. 1.]\n [1. 1. 2. 1. 1.]\n [3. 1. 1. 0. 1.]\n [3. 1. 0. 2. 0.]\n [3. 0. 2. 1. 0.]\n [2. 2. 1. 1. 0.]\n [2. 1. 1. 0. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 2. 1. 1.]\n [1. 2. 1. 1. 1.]\n [3. 1. 1. 1. 0.]\n [2. 1. 1. 1. 1.]]\nBest solution found: [2. 1. 1. 1. 1.]\nObjective value of the best solution: 8.0\n\n\n\ndef search_solutions_3d(s, obj_func):\n    \"\"\"\n    Perform a search for the best solution in a solution space using a neighborhood-based search algorithm.\n\n    Args:\n    s (list): The initial solution from which the search starts. Needs three elements x, y, z\n    obj_func (function): The objective function that evaluates the quality of a solution.\n\n    Returns:\n    list: The x, y, z coordinates (or components) of each solution in the search history.\n    list: The corresponding objective function values for each solution in the search history.\n\n    The function initializes with an initial solution 's' and evaluates it using the objective function 'obj_func'.\n    It then iteratively generates neighboring solutions, evaluates them, and keeps track of the best solution found so far.\n    The search continues until no further improvement is found in the neighborhood of the current best solution.\n    \"\"\"\n\n    # Evaluate the initial solution\n    obj_value = obj_func(s)\n    \n    # Initialize the best solution as the initial solution\n    best_solution = s.copy()\n    \n    # Initialize lists to keep track of the search history\n    x, y, z, f_v = [], [], [], []\n    \n    # Start an outer loop that continues until no improvement is found\n    while True:\n        # Generate a new neighborhood of solutions around the current best solution\n        nh = generate_search_neighborhood(best_solution)\n        \n        # Flag to check if an improvement was found in the current iteration\n        improved = False\n        \n        # Iterate over each solution in the neighborhood\n        for s in nh:\n            # Append the components of the solution to the history lists\n            x.append(s[0])\n            y.append(s[1])\n            z.append(s[2])\n            \n            # Evaluate the current solution\n            c = obj_func(s)\n            f_v.append(c)\n            print(f'Tested solution {s} with objective value {c}')\n            \n            # Check if the current solution is an improvement\n            if c &lt; obj_value:\n                # Update the best solution and its objective value\n                obj_value = c\n                best_solution = s.copy()\n                print(f'Found better solution {best_solution} with objective value {obj_value}')\n                \n                # Mark that an improvement was found and exit the inner loop\n                improved = True\n                break\n        \n        # If no improvement was found in the entire neighborhood\n        if not improved:\n            # Exit the outer loop - the search is complete\n            break\n\n    # Return the search history\n    return x, y, z, f_v\n\n\ns = [3, 0, 0]\nx, y, z, f_v = search_solutions_3d(s, obj_function)\n\n# Determine the range for each axis to set the ticks\ns_range = range(int(min(s)), int(max(s)) + 1)\n\nfig = go.Figure(data=[go.Scatter3d(\n    x=x,\n    y=y,\n    z=z,\n    mode='markers',\n    marker=dict(\n        size=6,\n        color=f_v,  # Set color to function values\n        colorscale='Plotly3',\n        opacity=0.8,\n        showscale=True\n    ),\n    hoverinfo='text',\n    text=[f'x: {xi:.0f}, y: {yi:.0f}, z: {zi:.0f}, f_v: {value:.1f}' for xi, yi, zi, value in zip(x, y, z, f_v)]\n)])\n\nfig.update_layout(title='3D Function Visualization',\n                  scene=dict(\n                      xaxis=dict(title='X axis', tickmode='array', tickvals=list(s_range)),\n                      yaxis=dict(title='Y axis', tickmode='array', tickvals=list(s_range)),\n                      zaxis=dict(title='Z axis', tickmode='array', tickvals=list(s_range))\n                  ))\n\nfig.show()\n\nThe schedule = [3, 0, 0]\nAnd the neighborhood is [[3. 0. 0.]\n [2. 0. 1.]\n [2. 1. 0.]\n [3. 0. 0.]]\nTested solution [3. 0. 0.] with objective value 9.0\nTested solution [2. 0. 1.] with objective value 5.0\nFound better solution [2. 0. 1.] with objective value 5.0\nThe schedule = [2. 0. 1.]\nAnd the neighborhood is [[2. 0. 1.]\n [1. 0. 2.]\n [2. 1. 0.]\n [1. 1. 1.]\n [3. 0. 0.]\n [2. 0. 1.]]\nTested solution [2. 0. 1.] with objective value 5.0\nTested solution [1. 0. 2.] with objective value 5.0\nTested solution [2. 1. 0.] with objective value 5.0\nTested solution [1. 1. 1.] with objective value 3.0\nFound better solution [1. 1. 1.] with objective value 3.0\nThe schedule = [1. 1. 1.]\nAnd the neighborhood is [[1. 1. 1.]\n [0. 1. 2.]\n [2. 0. 1.]\n [1. 2. 0.]\n [1. 0. 2.]\n [0. 2. 1.]\n [2. 1. 0.]\n [1. 1. 1.]]\nTested solution [1. 1. 1.] with objective value 3.0\nTested solution [0. 1. 2.] with objective value 5.0\nTested solution [2. 0. 1.] with objective value 5.0\nTested solution [1. 2. 0.] with objective value 5.0\nTested solution [1. 0. 2.] with objective value 5.0\nTested solution [0. 2. 1.] with objective value 5.0\nTested solution [2. 1. 0.] with objective value 5.0\nTested solution [1. 1. 1.] with objective value 3.0\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "simple-schedule-landscape.html",
    "href": "simple-schedule-landscape.html",
    "title": "Simple schedule landscape",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport pandas as pd\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\nfrom itertools import chain, combinations\nimport plotly.graph_objs as go\nimport copy\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n    \ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]\n\ndef get_v_star(t):\n    # Create an initial vector 'u' of zeros with length 't'\n    u = np.zeros(t, dtype=np.int64)\n    # Set the first element of vector 'u' to -1\n    u[0] = -1\n    # Set the last element of vector 'u' to 1\n    u[-1] = 1\n    # Initialize the list 'v_star' with the initial vector 'u'\n    v_star = [u]\n    # Loop over the length of 'u' minus one times\n    for i in range(len(u) - 1):\n        # Append the last element of 'u' to the front of 'u'\n        u = np.append(u[-1], u)\n        # Remove the last element of 'u' to maintain the same length\n        u = np.delete(u, -1)\n        # Append the updated vector 'u' to the list 'v_star'\n        v_star.append(u)\n    # Convert the list of vectors 'v_star' into a NumPy array and return it\n    return(np.array(v_star))\n\n# Example of function call:\n# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row\n\ndef generate_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  logging.info(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}\n  # 'ids' will be a list of tuples, where each tuple is a subset of indices\n  ids = list(powerset(range(T)))\n\n  logging.info(f'Neighborhood size = {len(ids)}')\n\n  # Select the vectors from 'v_star' that correspond to the indices in each subset\n  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\n  sub_sets = [v_star[i] for i in ids]\n\n  # Sum the vectors within each subset and flatten the result to get a 1-D array\n  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\n  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n  \n  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  logging.info(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ndef generate_small_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  logging.info(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  neighborhood = np.array([schedule + v_star[i] for i in range(len(v_star))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  logging.info(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ndef distribute_patients(n_patients, n_timeslots):\n    # Create a list with all slots initially empty\n    distribution = [0] * n_timeslots\n\n    # Place patients in timeslots\n    for i in range(n_patients):\n        # Calculate the slot for each patient\n        slot = round(i * n_timeslots / n_patients)\n        distribution[slot] = 1\n\n    return distribution\n\ndef plot_timeline(slots, title):\n    # Create a figure\n    fig = go.Figure()\n\n    # Iterate over each timeslot and add a bar for occupied slots\n    for i, slot in enumerate(slots):\n        fig.add_trace(go.Bar(x=[i], y=[slot], width=0.8, marker_color='black'))\n\n    # Update layout\n    fig.update_layout(\n        title=title,\n        xaxis_title=\"Timeslots\",\n        yaxis=dict(showticklabels=False, showgrid=False, zeroline=False),\n        showlegend=False\n    )\n\n    # Set y-axis range\n    fig.update_yaxes(range=[0, np.max(slots)])\n\n    # Show the figure\n    fig.show()\n    \ndef service_time_with_no_shows(s, q):\n  # \"\"\"\n  # Function to adjust a distribution of service times for no-shows\n  # \n  # Args:\n  #     s (numpy.ndarray): An array with service times.\n  #     q (double): The fraction of no-shows.\n  # \n  # Returns:\n  #     numpy.ndarray: The adjusted array of service times.\n  # \"\"\"\n  \n  s_adj = s * (1-q)\n  s_adj[0] = s_adj[0] + q\n  return(s_adj)\n\ndef add_lists(short_list, long_list):\n  # \"\"\"\n  # This function takes in two lists and returns a new list where each element \n  # is the sum of the elements from the input lists at the corresponding position.\n  # If the lists are of different lengths, the shorter list is extended with zeros \n  # to match the length of the longer list.\n  # \n  # Parameters:\n  # - short_list (list): The shorter list of numbers.\n  # - long_list (list): The longer list of numbers.\n  # \n  # Returns:\n  # - list: A list containing the element-wise sum of the two input lists.\n  # \"\"\"\n  \n  # Extend the short lists to the length of the long list with zeros\n  short_list.extend([0] * (len(long_list) - len(short_list)))\n  \n  # Sum the elements of the two lists element-wise\n  result = [a + b for a, b in zip(short_list, long_list)]\n  \n  return result\n\ndef calculate_rolling_convolution(p_y, s):\n  conv_list = s\n  limit = len(p_y)\n  v = [x * p_y[0] for x in conv_list]\n  for i in range(1, limit):\n    conv_list = np.convolve(conv_list, s)\n    v = add_lists(v, [x * p_y[i] for x in conv_list])\n    \n  return(v)\n\ndef generate_schedules(N):\n    \"\"\"\n    Generate all possible ways to distribute N patients into 3 timeslots.\n    The function returns a list of lists, where each sublist represents\n    a distribution of patients across the 3 timeslots such that the sum of\n    the numbers in the sublist is N.\n\n    Parameters:\n    N (int): The total number of patients to be distributed.\n\n    Returns:\n    List[List[int]]: A list of lists where each sublist contains 3 integers\n    representing a possible distribution of patients across the 3 timeslots.\n    \"\"\"\n    # This list will hold the result\n    schedules = []\n\n    # Iterate over all possible values of 'a' from 0 to N (inclusive)\n    for a in range(N + 1):\n        # For each value of 'a', iterate over all possible values of 'b' from 0 to N-a (inclusive)\n        for b in range(N - a + 1):\n            # Compute 'c' such that the sum of 'a', 'b', and 'c' is N\n            c = N - a - b\n            # Append the combination [a, b, c] to the schedules list\n            schedules.append([a, b, c])\n\n    # Return the list of all possible schedules\n    return schedules\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times. In the examples below we model service times as a Poisson process, because we are calculating in discrete time units.\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s, q, omega):\n        \"\"\"\n        Initialize the Schedule class with patient schedules and a service time distribution.\n\n        Args:\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            d (int): An integer representing the length of a time interval.\n            s (list): A list of floats representing the probability distribution of service times.\n            q (float): A float representing the probability of patients not showing up.\n            omega (float): A float representing weight for the waiting cost in the loss function The weight for tardiness equal 1 - omega.\n        \"\"\"\n        if not all(isinstance(i, np.integer) and i &gt;= 0 for i in x):\n            raise ValueError(\"All elements in x must be non-negative integers.\")\n        if not isinstance(d, int) or d &lt;= 0:\n            raise ValueError(\"d must be a positive integer.\")\n        if not all(isinstance(i, float) and 0 &lt;= i &lt;= 1 for i in s):\n            raise ValueError(\"All elements in s must be floats between 0 and 1.\")\n        if not isinstance(q, float) and 0 &lt;= q &lt;= 1:\n            raise ValueError(\"q must be a float between 0 and 1.\")\n        if not isinstance(omega, float) and 0 &lt;= omega &lt;= 1:\n            raise ValueError(\"omegea must be a float between 0 and 1.\")\n\n        self.parameters = {'x': x, 'd': d, 's': s, 'q': q, 'omega': omega}\n        \"\"\" Adjust service times for no-shows. \"\"\"\n        self.parameters['s'] = service_time_with_no_shows(self.parameters['s'], self.parameters['q'])\n        self._initialize_system()\n            \n    def _initialize_system(self):\n        \"\"\" Initialize the system's internal state. \"\"\"\n        self.state = 0\n        length_x = len(self.parameters['x'])\n        length_s = len(self.parameters['s'])\n        self.system = {\n            'p_min': np.zeros((length_x + 1, length_s), dtype=np.float64),\n            'p_plus': np.zeros((length_x, length_s), dtype=np.float64),\n            'w': [np.zeros((i, length_s), dtype=np.float64) for i in self.parameters['x']],\n            'ew': np.zeros(length_x, dtype=np.float64),\n            'loss': None\n        }\n        self.system['p_min'][0][0] = 1\n        if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n        self._update_p_plus(0)\n        self.state = 1\n            \n    def _update_p_plus(self, state):\n        \"\"\" Update the p_plus array based on the current state. \"\"\"\n        if self.parameters['x'][state] == 0:\n            self.system['p_plus'][state] = self.system['p_min'][state].copy()\n        else:\n            self.system['p_plus'][state] = np.convolve(self.system['w'][state][-1], self.parameters['s'], mode='full')[:len(self.parameters['s'])]\n        logging.info(f\"p_plus = {self.system['p_plus'][state]}\")\n            \n    def _calculate_state(self):\n        logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n        \n        \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n        logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n        self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n        \n        \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n        \n        self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n        \n        \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n        The distribution of waiting times of the second patient in state t equals the convolution of the distribution  of waiting times of the first patient in state t and the service time distribution. The resulting vector is truncated to the length of the service time distribution.\"\"\"\n        if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                logging.info(self.system['w'][self.state][0])\n                logging.info(f'{datetime.datetime.now()} - Done')\n                for i in range(1, self.parameters['x'][self.state]):\n                    logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                    self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                    logging.info(self.system['w'][self.state][i])\n\n        \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals the convolution of the waiting time distribution of the last arriving patient and the service time distribution. Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal to the distribution of work at the beginning of t. The resulting vector is truncated to the length of the service time distribution.\"\"\"\n        logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n        self._update_p_plus(self.state)\n    \n    def calculate_system_states(self, until=1):\n        \"\"\"\n        Calculate the probabilities of the system being in each state at each time step.\n\n        Args:\n            until (int, optional): The state until which to calculate the probabilities. Defaults to 1.\n        \"\"\"\n        while self.state &lt; until:\n            self._calculate_state()\n            self.state += 1\n            \n    def calculate_loss(self):\n        omega = self.parameters['omega']\n        # Calculate loss\n        tot_wt = self.system['ew'].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        self.system['loss'] = omega * tot_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      \n    def local_search(self, omega=0.5):\n        \"\"\"\n        Perform a local search to optimize a schedule by minimizing the total waiting time and expected tardiness.\n        \n        The function starts with an initial schedule and iteratively explores neighboring schedules. For each neighboring schedule, it recalculates the system's states and computes the total waiting time and expected tardiness. If a neighboring schedule with a lower objective value (weighted sum of normalized waiting time and expected tardiness) is found, the function updates the current best schedule and continues the search from this new schedule. The search stops when no better neighboring schedule is found.\n        \n        Parameters:\n        omega (float): A weighting factor between 0 and 1 used to balance the trade-off between total waiting time and expected tardiness.\n        \n        The function follows these steps:\n        1. Calculate the initial loss using the total waiting time and expected tardiness.\n        2. Store the current schedule and system state as the initial best solution.\n        3. Enter a loop to explore neighboring schedules:\n           a. Generate a neighborhood of candidate schedules.\n           b. For each candidate schedule in the neighborhood:\n              i. Update the schedule and reinitialize the system.\n              ii. Recalculate the system states and waiting times.\n              iii. Calculate the objective value (weighted sum of normalized waiting time and expected tardiness).\n              iv. If a better schedule is found, update the best solution and break to generate a new neighborhood.\n        4. If no better schedule is found in the neighborhood, end the search.\n        5. Set the system to the best found schedule and system state.\n        \"\"\"\n        omega = self.parameters['omega']\n        # Calculate initial loss\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n        \n        # Continue the search until no improvement is found\n        while True:  # Start an outer loop that will continue until explicitly broken\n            nh = generate_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood\n            improved = False  # Flag to check if an improvement was found in the inner loop\n            \n            for y in nh:  # Inner loop to search through the neighborhood\n                # Insert first element of nh in x\n                self.parameters['x'] = y.copy()\n                logging.info(f\"Test schedule = {self.parameters['x']}\")\n                # Set starting state\n                self.state = 0\n                # If start state is 0 reinitialize p_min, w and p_plus in state 0\n                self._initialize_system()\n                self.calculate_system_states(until=len(self.parameters['x']))\n                logging.info(\"System recalculated\")\n                self.calculate_wait_times()\n                test_wt = self.system[\"ew\"].sum()\n                logging.info(f\"Average waiting time={test_wt / self.parameters['x'].sum()}\")\n                self.calculate_tardiness()\n                indices = np.arange(self.system['p_min'][-1].size) \n                exp_tard = (indices * self.system['p_min'][-1]).sum()\n                logging.info(f'Expected tardiness={exp_tard}')\n                test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n                logging.info(f'obj_value = {test_loss}')\n                # If a neighborhood with a lower waiting time is found, store the system\n                if(test_loss &lt; lowest_loss):\n                    lowest_loss = test_loss\n                    store_optim['x'] = self.parameters['x'].copy()\n                    newsystem = copy.deepcopy(self.system)\n                    store_optim['system'] = newsystem\n                    store_optim['tot_wt'] = test_wt\n                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                    improved = True  # Set the flag because an improvement was found\n                    break  # Exit the inner loop to generate a new neighborhood\n            \n            if not improved:  # If no improvement was found in the inner loop\n                logging.info(f'Finished searching')\n                # Set the system to the stored optimal system \n                logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                self.parameters['x'] = store_optim['x'].copy()\n                self.system['p_min'] = store_optim['system']['p_min']\n                self.system['p_plus'] = store_optim['system']['p_plus']\n                self.system['w'] = store_optim['system']['w']\n                self.system['ew'] = store_optim['system']['ew']\n                break  # Exit the outer loop - the search is complete\n      \n        \n    def small_local_search(self):\n          \"\"\"\n          Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting stop searching.  \n          \"\"\"\n          omega = self.parameters['omega']\n          # Calculate initial loss\n          test_wt = self.system[\"ew\"].sum()\n          self.calculate_tardiness()\n          indices = np.arange(self.system['p_min'][-1].size) \n          exp_tard = (indices * self.system['p_min'][-1]).sum()\n          lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n          store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n        \n          # Continue the search until no improvement is found\n          while True:  # Start an outer loop that will continue until explicitly broken\n              nh = generate_small_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood\n              improved = False  # Flag to check if an improvement was found in the inner loop\n              \n              for y in nh:  # Inner loop to search through the neighborhood\n                  # Insert first element of nh in x\n                  self.parameters['x'] = y.copy()\n                  logging.info(f\"Test schedule = {self.parameters['x']}\")\n                  # Set starting state\n                  self.state = 0\n                  # If start state is 0 reinitialize p_min, w and p_plus in state 0\n                  if(self.state == 0):\n                      self.system = dict({\n                          'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                          'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n                      })\n                      # Set the first element of p_min in the initial state to 1.\n                      self.system['p_min'][0][0] = 1\n                      # Initialize array of arrays for saving waiting times distributions per patient\n                      self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n                      if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                               self.system['w'][0][0] = self.system['p_min'][0].copy()\n                               for i in range(1, self.parameters['x'][0]):\n                                      self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                      self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                      # Initialize array for saving total expected waiting times per state\n                      self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n                      # Set the initial state to 1.\n                      self.state = 1\n                  self.calculate_system_states(until=len(self.parameters['x']))\n                  logging.info(\"System recalculated\")\n                  self.calculate_wait_times()\n                  test_wt = self.system[\"ew\"].sum()\n                  logging.info(f\"Average waiting time={test_wt / self.parameters['x'].sum()}\")\n                  self.calculate_tardiness()\n                  indices = np.arange(self.system['p_min'][-1].size) \n                  exp_tard = (indices * self.system['p_min'][-1]).sum()\n                  logging.info(f'Expected tardiness={exp_tard}')\n                  test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n                  logging.info(f'obj_value = {test_loss}')\n                  # If a schedule with a lower waiting time is found, store the system\n                  if(test_loss &lt; lowest_loss):\n                    lowest_loss = test_loss\n                    store_optim['x'] = self.parameters['x'].copy()\n                    newsystem = copy.deepcopy(self.system)\n                    store_optim['system'] = newsystem\n                    store_optim['tot_wt'] = test_wt\n                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]}')\n                    improved = True  # Set the flag because an improvement was found\n                    break  # Exit the inner loop to generate a new neighborhood\n              \n              if not improved:  # If no improvement was found in the inner loop\n                logging.info(f'Finished searching')\n                # Set the system to the stored optimal system \n                logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                self.parameters['x'] = store_optim['x'].copy()\n                self.system['p_min'] = store_optim['system']['p_min']\n                self.system['p_plus'] = store_optim['system']['p_plus']\n                self.system['w'] = store_optim['system']['w']\n                self.system['ew'] = store_optim['system']['ew']\n                break  # Exit the outer loop - the search is complete\n          \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      # logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n      for interval, wtdists in enumerate(self.system['w']):\n          ew = 0\n          for nr, dist in enumerate(wtdists):\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(dist))\n              b = dist\n              meanwt = np.dot(a, b)\n              logging.info(f\"Mean waiting time for patient {nr} in interval {interval} = {meanwt}\")\n              ew += meanwt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][interval] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values,\n                    colorscale=[\n                      [0, 'white'],  # white color at the bottom\n                      [1, 'red']     # red color at the top\n                    ]\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, q, omega, print_system=True):\n    schedule = Schedule(x=x, d=d, s=s, q=q, omega=omega)\n    schedule.calculate_system_states(until=len(x))\n    schedule.calculate_wait_times()\n    schedule.calculate_loss()\n    if(print_system): print(schedule)\n    return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\nd = 3\nq = 0.0\nomega = 0.6\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\n# s= service_time_with_no_shows(s, q)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\n\nexp_s = 2.25\n\n\n\nN = 6\nschedules = generate_schedules(N)\ndata = {'x0': [], 'x1': [], 'x2': [], 'loss': []}\nfor schedule in schedules:\n  x = np.array(schedule, dtype=np.int64)\n  sch = run_schedule(x, d, s, q, omega, False)\n  x0, x1, x2 = x\n  data['x0'].append(x0)\n  data['x1'].append(x1)\n  data['x2'].append(x2)\n  data['loss'].append(sch.system['loss'])\n\ndf = pd.DataFrame.from_dict(data)\ndf\n\n\n\n\n\n\n\n\n\nx0\nx1\nx2\nloss\n\n\n\n\n0\n0\n0\n6\n4.548829\n\n\n1\n0\n1\n5\n4.417006\n\n\n2\n0\n2\n4\n4.363485\n\n\n3\n0\n3\n3\n4.541565\n\n\n4\n0\n4\n2\n4.723808\n\n\n5\n0\n5\n1\n4.555431\n\n\n6\n0\n6\n0\n3.946096\n\n\n7\n1\n0\n5\n4.364368\n\n\n8\n1\n1\n4\n3.730667\n\n\n9\n1\n2\n3\n3.552043\n\n\n10\n1\n3\n2\n3.743224\n\n\n11\n1\n4\n1\n3.867762\n\n\n12\n1\n5\n0\n3.534817\n\n\n13\n2\n0\n4\n3.860934\n\n\n14\n2\n1\n3\n3.365116\n\n\n15\n2\n2\n2\n3.430555\n\n\n16\n2\n3\n1\n3.589480\n\n\n17\n2\n4\n0\n3.412492\n\n\n18\n3\n0\n3\n3.618120\n\n\n19\n3\n1\n2\n3.617519\n\n\n20\n3\n2\n1\n3.758252\n\n\n21\n3\n3\n0\n3.595156\n\n\n22\n4\n0\n2\n3.730820\n\n\n23\n4\n1\n1\n3.910641\n\n\n24\n4\n2\n0\n3.787802\n\n\n25\n5\n0\n1\n3.569059\n\n\n26\n5\n1\n0\n3.703079\n\n\n27\n6\n0\n0\n3.382490\n\n\n\n\n\n\n\n\n\n# Create a 3D scatter plot with Plotly with arrows\n\n# Sort the dataframe by 'loss' to find the 5th lowest and the lowest loss\nsorted_df = df.sort_values(by='loss').reset_index(drop=True)\n\n# Create the 3D scatter plot using Plotly Graph Objects\nfig = go.Figure()\n\n# Add scatter plot\nfig.add_trace(go.Scatter3d(\n    x=df['x0'], y=df['x1'], z=df['x2'],\n    mode='markers',\n    marker=dict(\n        size=10,\n        color=df['loss'],\n        colorscale='matter',\n        showscale=False  # Hide the colorbar)\n    ),\n    text=df['loss'],\n    hovertemplate='[%{x}, %{y}, %{z}] - loss = %{text:.2f}',\n))\n\n# Add red arrows from the 5th lowest loss to the lowest loss point\nfor i in range(4):\n    fig.add_trace(go.Scatter3d(\n        x=[sorted_df['x0'][i], sorted_df['x0'][i + 1]],\n        y=[sorted_df['x1'][i], sorted_df['x1'][i + 1]],\n        z=[sorted_df['x2'][i], sorted_df['x2'][i + 1]],\n        mode='lines',\n        line=dict(color='red', width=4),\n        showlegend=False\n    ))\n\n# Update layout\nfig.update_layout(\n    title='Solution landscape for schedule with N = {} and T = 3'.format(N),\n    scene=dict(\n        xaxis_title='x0',\n        yaxis_title='x1',\n        zaxis_title='x2',\n    ),\n    width=800,\n    height=800,\n    showlegend=False\n)\n#fig.write_image(\"images/landscape-with-arrows.png\", scale=4)\nfig.show()\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  }
]