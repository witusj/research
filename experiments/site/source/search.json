[
  {
    "objectID": "sched-sim.html",
    "href": "sched-sim.html",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -> st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -> normal or emergency\npct = np.array([1, 0]) # distribution of client types -> normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#run-simulation-1",
    "href": "sched-sim.html#run-simulation-1",
    "title": "Scheduling Simulation",
    "section": "Run simulation 1",
    "text": "Run simulation 1\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14 \nlns = 5\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], dtype=object) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time= {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time= 3.1245202216053287')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-2",
    "href": "sched-sim.html#run-simulation-2",
    "title": "Scheduling Simulation",
    "section": "Run simulation 2",
    "text": "Run simulation 2\n\nConfigure parameters.\n\n# Configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving silnmlation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n\nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times.\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 11.129256919264234')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-3",
    "href": "sched-sim.html#run-simulation-3",
    "title": "Scheduling Simulation",
    "section": "Run simulation 3",
    "text": "Run simulation 3\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 0, 0, 60, 0, 0, 0, 60, 0, 0, 0]) # inter-arrival times\n\nnsims = nsims # number of simulations\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 22.757662394656464')]"
  },
  {
    "objectID": "sim-based-opt.html",
    "href": "sim-based-opt.html",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -> normal or emergency\npct = np.array([1, 0]) # distribution of client types -> normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#run-simulations",
    "href": "sim-based-opt.html#run-simulations",
    "title": "Simulation Based Optimization",
    "section": "Run simulations",
    "text": "Run simulations\n\n# Simulation 1\n\ntic = time.time()\nsim = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nN = len(iats) # number of patients\n# T = len(sim) # number of intervals\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimreswt = []\nsimresln = 0\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = loss = 0.5 * mwt + 0.5 * mln\ntoc = time.time()\nprint(toc - tic)\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\n1.9191620349884033\n\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 1 1 1 1 1 1 1], mwt: 1.628650296227571, mln: 2.008251478502302, loss: 1.8184508873649365')\n\n\n\n\n\n\n\n\n\n# Simulation 2\n\nsim = np.array([2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [2 0 1 1 1 1 1 1 1 1 1 1], mwt: 2.2145308988902643, mln: 2.004846181961865, loss: 2.1096885404260646')\n\n\n\n\n\n\n\n\n\n# Simulation 3\n\nsim = np.array([1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 2 0 1 1 1 1 1 1 1], mwt: 2.300712630374417, mln: 1.99761781582213, loss: 2.1491652230982736')\n\n\n\n\n\n\n\n\n\n# Simulation 4\n\nsim = np.array([1, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 2 0 1 1 1 1 1], mwt: 2.308230165116365, mln: 1.9829459016861526, loss: 2.1455880334012587')"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Experiments",
    "section": "",
    "text": "Here I will share all my experiments."
  },
  {
    "objectID": "search-function.html",
    "href": "search-function.html",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -> normal or emergency\npct = np.array([1, 0]) # distribution of client types -> normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nT = 12\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#run-simulations",
    "href": "search-function.html#run-simulations",
    "title": "Search Function",
    "section": "Run simulations",
    "text": "Run simulations\n\n# Simulations\nresults = []\nfor iats in iats_sm:\n  tic = time.time()\n  simreswt = [None] * nsims # array for saving waiting times\n  simresln = 0 # array for saving lateness\n  \n  for i in range(nsims):\n    experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n    simreswt[i] = experiment[0].mean()\n    ln = max(0, (experiment[1] - d))\n    simresln += ln\n    \n  mwt = np.array(simreswt).mean()\n  mln = simresln / nsims\n  loss = 0.5 * mwt + 0.5 * mln\n  toc = time.time()\n  result = {\n      \"schedule\": fn.transform_iats_schedule(iats, d, T)[0],\n      \"iats\": iats,\n      \"iats_diff\": np.diff(iats),\n      \"loss\": loss,\n      \"calc_time\": toc - tic\n    }\n  results.append(result)\n  print(f'schedule: {result[\"schedule\"]},\\niats: {iats},\\niats_diff: {result[\"iats_diff\"]},\\nloss = {result[\"loss\"]}, \\\n  calc time: {result[\"calc_time\"]} secs')\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 30 30 30 30 30 15],\niats_diff: [  0  30   0   0   0   0 -15],\nloss = 1.4263666172805927,   calc time: 1.4521541595458984 secs\n\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 30 30 30 30 30 15  0],\niats_diff: [ 30   0   0   0   0 -15 -15],\nloss = 4.210848905204175,   calc time: 1.5045511722564697 secs\n\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 15 45 30 30 30 15],\niats_diff: [  0  15  30 -15   0   0 -15],\nloss = 1.762480804275828,   calc time: 1.4852979183197021 secs\n\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 30 15 45 30 30 15],\niats_diff: [  0  30 -15  30 -15   0 -15],\nloss = 1.5094766751224018,   calc time: 1.428389072418213 secs\n\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 30 30 15 45 30 15],\niats_diff: [  0  30   0 -15  30 -15 -15],\nloss = 1.4880901501989365,   calc time: 1.4166440963745117 secs\n\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 30 30 30 15 45 15],\niats_diff: [  0  30   0   0 -15  30 -30],\nloss = 1.4838762193887753,   calc time: 1.4979219436645508 secs\n\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 30 30 30 30 15 30],\niats_diff: [  0  30   0   0   0 -15  15],\nloss = 1.2176828824460646,   calc time: 1.5055110454559326 secs\n\n\nschedule: [2 0 1 0 1 0 1 0 1 0 2 0],\niats: [ 0  0 30 30 30 30 30  0],\niats_diff: [  0  30   0   0   0   0 -30],\nloss = 4.358537839217919,   calc time: 1.4922161102294922 secs\n\n\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 20\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    bestresult = None\n\n    if elapsed_time > seconds:\n        print(\"Finished iterating in: \" + str(int(elapsed_time))  + \" seconds\")\n        break\n      \n    ## Start iterator for inter arrival times in shift matrix\n    results = []\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims):\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          \"schedule\": fn.transform_iats_schedule(iats, d, T)[0],\n          \"iats\": iats,\n          \"iats_diff\": np.diff(iats),\n          \"loss\": loss,\n          \"calc_time\": toc - tic\n        }\n      bestresult = result\n      if (result[\"loss\"] < bestresult[\"loss\"]): bestresult = result\n      results.append(result)\n      print(f'schedule: {result[\"schedule\"]},\\niats: {iats},\\niats_diff: {result[\"iats_diff\"]},\\nloss = {result[\"loss\"]}, \\\n  calc time: {result[\"calc_time\"]} secs')\n### Simulate item of the shift matrix\n\n#### If loss is lower than previous save iats vector and loss\n\n## Calculate new shift matrix based upon best iats vector\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 30 30 30 30 30 15],\niats_diff: [  0  30   0   0   0   0 -15],\nloss = 1.4263666172805927,   calc time: 1.6719810962677002 secs\n\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 30 30 30 30 30 15  0],\niats_diff: [ 30   0   0   0   0 -15 -15],\nloss = 4.210848905204175,   calc time: 1.50339674949646 secs\n\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 15 45 30 30 30 15],\niats_diff: [  0  15  30 -15   0   0 -15],\nloss = 1.762480804275828,   calc time: 1.5018928050994873 secs\n\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 30 15 45 30 30 15],\niats_diff: [  0  30 -15  30 -15   0 -15],\nloss = 1.5094766751224018,   calc time: 1.5592739582061768 secs\n\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 30 30 15 45 30 15],\niats_diff: [  0  30   0 -15  30 -15 -15],\nloss = 1.4880901501989365,   calc time: 1.5862889289855957 secs\n\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 30 30 30 15 45 15],\niats_diff: [  0  30   0   0 -15  30 -30],\nloss = 1.4838762193887753,   calc time: 1.475468635559082 secs\n\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 30 30 30 30 15 30],\niats_diff: [  0  30   0   0   0 -15  15],\nloss = 1.2176828824460646,   calc time: 1.5483200550079346 secs\n\n\nschedule: [2 0 1 0 1 0 1 0 1 0 2 0],\niats: [ 0  0 30 30 30 30 30  0],\niats_diff: [  0  30   0   0   0   0 -30],\nloss = 4.358537839217919,   calc time: 1.5328521728515625 secs\n\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 30 30 30 30 30 15],\niats_diff: [  0  30   0   0   0   0 -15],\nloss = 1.4263666172805927,   calc time: 1.5011329650878906 secs\n\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 30 30 30 30 30 15  0],\niats_diff: [ 30   0   0   0   0 -15 -15],\nloss = 4.210848905204175,   calc time: 1.5827031135559082 secs\n\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 15 45 30 30 30 15],\niats_diff: [  0  15  30 -15   0   0 -15],\nloss = 1.762480804275828,   calc time: 1.5032858848571777 secs\n\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 30 15 45 30 30 15],\niats_diff: [  0  30 -15  30 -15   0 -15],\nloss = 1.5094766751224018,   calc time: 1.5510308742523193 secs\n\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 30 30 15 45 30 15],\niats_diff: [  0  30   0 -15  30 -15 -15],\nloss = 1.4880901501989365,   calc time: 1.5094740390777588 secs\n\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 30 30 30 15 45 15],\niats_diff: [  0  30   0   0 -15  30 -30],\nloss = 1.4838762193887753,   calc time: 1.4989562034606934 secs\n\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 30 30 30 30 15 30],\niats_diff: [  0  30   0   0   0 -15  15],\nloss = 1.2176828824460646,   calc time: 1.5308480262756348 secs\n\n\nschedule: [2 0 1 0 1 0 1 0 1 0 2 0],\niats: [ 0  0 30 30 30 30 30  0],\niats_diff: [  0  30   0   0   0   0 -30],\nloss = 4.358537839217919,   calc time: 1.48704195022583 secs\nFinished iterating in: 24 seconds"
  },
  {
    "objectID": "scratchpad.html",
    "href": "scratchpad.html",
    "title": "scratchpad",
    "section": "",
    "text": "import numpy as np\nimport functions as fn\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\n\nem = np.random.poisson(0.5, 12).astype(int)\nem_stsm = [np.random.lognormal(mean = nm, sigma=ns, size=i).sum() for i in em]\nprint(f'em: {em}, em_stsm: {em_stsm}')\n\nem: [0 2 1 3 0 0 1 3 0 0 1 0], em_stsm: [0.0, 23.488629614841592, 10.372765197716179, 51.8581428881152, 0.0, 0.0, 10.443123508396317, 37.18816526366919, 0.0, 0.0, 11.984049773180192, 0.0]"
  },
  {
    "objectID": "search-function.html#run-simulations-and-search",
    "href": "search-function.html#run-simulations-and-search",
    "title": "Search Function",
    "section": "Run simulations and search",
    "text": "Run simulations and search\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 30\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time > seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] < bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule']\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 8 patients and 12 timeslots.\nGenerated new psm\n\n\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 30 30 30 30 30 15],\niats_diff: [  0  30   0   0   0   0 -15],\nloss = 1.4190072954620558, calc time: 1.5507898330688477 secs\n\n\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 30 30 30 30 30 15  0],\niats_diff: [ 30   0   0   0   0 -15 -15],\nloss = 4.205657559425883, calc time: 1.5974009037017822 secs\n\n\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 15 45 30 30 30 15],\niats_diff: [  0  15  30 -15   0   0 -15],\nloss = 1.753404729412901, calc time: 1.6068029403686523 secs\n\n\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 30 15 45 30 30 15],\niats_diff: [  0  30 -15  30 -15   0 -15],\nloss = 1.5003523275738382, calc time: 1.521069049835205 secs\n\n\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 30 30 15 45 30 15],\niats_diff: [  0  30   0 -15  30 -15 -15],\nloss = 1.4799204090613483, calc time: 1.5901329517364502 secs\n\n\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 30 30 30 15 45 15],\niats_diff: [  0  30   0   0 -15  30 -30],\nloss = 1.4771469156467405, calc time: 1.526716947555542 secs\n\n\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 0 1 1 0 1] with loss: 1.2114045603647747\n\nGenerated new psm\n\n\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 30 30 30 30 15 30],\niats_diff: [  0  30   0   0   0 -15  15],\nloss = 1.2114045603647747, calc time: 1.517603874206543 secs\n\n\n\nschedule: [1 0 1 0 1 0 1 0 1 1 0 2],\niats: [ 0 30 30 30 30 15 30  0],\niats_diff: [ 30   0   0   0 -15  15 -30],\nloss = 3.8130833873111856, calc time: 1.5954339504241943 secs\n\n\n\nschedule: [2 1 0 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 15 45 30 30 15 30],\niats_diff: [  0  15  30 -15   0 -15  15],\nloss = 1.54580199431562, calc time: 1.6065890789031982 secs\n\n\n\nschedule: [2 0 1 1 0 0 1 0 1 1 0 1],\niats: [ 0  0 30 15 45 30 15 30],\niats_diff: [  0  30 -15  30 -15 -15  15],\nloss = 1.2927254201152847, calc time: 1.599867820739746 secs\n\n\n\nschedule: [2 0 1 0 1 1 0 0 1 1 0 1],\niats: [ 0  0 30 30 15 45 15 30],\niats_diff: [  0  30   0 -15  30 -30  15],\nloss = 1.2716436006540044, calc time: 1.56880784034729 secs\n\n\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 1 0 1 0 1] with loss: 1.2055497369854167\n\nGenerated new psm\n\n\n\nschedule: [2 0 1 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 30 30 30 15 30 30],\niats_diff: [  0  30   0   0 -15  15   0],\nloss = 1.2055497369854167, calc time: 1.6540751457214355 secs\n\n\n\nschedule: [1 0 1 0 1 0 1 1 0 1 0 2],\niats: [ 0 30 30 30 15 30 30  0],\niats_diff: [ 30   0   0 -15  15   0 -30],\nloss = 3.799749756817863, calc time: 1.5697698593139648 secs\n\n\n\nschedule: [2 1 0 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 15 45 30 15 30 30],\niats_diff: [  0  15  30 -15 -15  15   0],\nloss = 1.539932789033532, calc time: 1.5202391147613525 secs\n\n\n\nschedule: [2 0 1 1 0 0 1 1 0 1 0 1],\niats: [ 0  0 30 15 45 15 30 30],\niats_diff: [  0  30 -15  30 -30  15   0],\nloss = 1.286384515220363, calc time: 1.5101029872894287 secs\n\n\n\n\n#### Found better schedule: [2 0 1 0 1 1 0 1 0 1 0 1] with loss: 1.2051199375105335\n\nGenerated new psm\n\n\n\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 30 30 15 30 30 30],\niats_diff: [  0  30   0 -15  15   0   0],\nloss = 1.2051199375105335, calc time: 1.5269219875335693 secs\n\n\n\nschedule: [1 0 1 0 1 1 0 1 0 1 0 2],\niats: [ 0 30 30 15 30 30 30  0],\niats_diff: [ 30   0 -15  15   0   0 -30],\nloss = 3.7985047564941525, calc time: 1.5376908779144287 secs\n\n\n\nschedule: [2 1 0 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 15 45 15 30 30 30],\niats_diff: [  0  15  30 -30  15   0   0],\nloss = 1.5391154183103475, calc time: 1.5958778858184814 secs\n\n\n\nschedule: [2 0 1 1 0 1 0 1 0 1 0 1],\niats: [ 0  0 30 15 30 30 30 30],\niats_diff: [  0  30 -15  15   0   0   0],\nloss = 1.22696574325763, calc time: 1.732637882232666 secs\n\n\n\nschedule: [2 0 1 0 2 0 0 1 0 1 0 1],\niats: [ 0  0 30 30  0 45 30 30],\niats_diff: [  0  30   0 -30  45 -15   0],\nloss = 1.7167666108010833, calc time: 1.5913469791412354 secs\n\n\n\nschedule: [2 0 1 0 1 1 1 0 0 1 0 1],\niats: [ 0  0 30 30 15 15 45 30],\niats_diff: [  0  30   0 -15   0  30 -15],\nloss = 1.291053987776476, calc time: 1.5714588165283203 secs\n\n\n\nschedule: [2 0 1 0 1 1 0 1 1 0 0 1],\niats: [ 0  0 30 30 15 30 15 45],\niats_diff: [  0  30   0 -15  15 -15  30],\nloss = 1.2604147046428467, calc time: 1.596369981765747 secs\n\n\n\nschedule: [2 0 1 0 1 1 0 1 0 1 1 0],\niats: [ 0  0 30 30 15 30 30 15],\niats_diff: [  0  30   0 -15  15   0 -15],\nloss = 1.4841214147183492, calc time: 1.5145249366760254 secs\n\nFinished iterating in: 40 seconds\n\nBest result:\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 30 30 15 30 30 30],\niats_diff: [  0  30   0 -15  15   0   0],\nloss = 1.2051199375105335, calc time: 1.5791077613830566 secs"
  }
]