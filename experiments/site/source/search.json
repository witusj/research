[
  {
    "objectID": "convexity.html",
    "href": "convexity.html",
    "title": "Convexity",
    "section": "",
    "text": "import numpy as np\n\n# Define the function\ndef f(x):\n    return x**2\n\n# Define x1, x2 and t\nx1 = 1\nx2 = 3\nt = 0.5  # choose any value in [0, 1]\n\n# Compute the left-hand and right-hand side of the convexity inequality\nlhs = f(t*x1 + (1-t)*x2)\nrhs = t*f(x1) + (1-t)*f(x2)\n\n# Print the results\nprint(f\"Left-hand side: {lhs}\")\nprint(f\"Right-hand side: {rhs}\")\n\n# Check if the inequality holds\nif lhs &lt;= rhs:\n    print(\"The function is convex.\")\nelse:\n    print(\"The function is not convex.\")\n\na = (f(x2) - f(x1)) / (x2 - x1)\n\nb = f(x1) - a*x1\n\nprint(f'y = {a}x + {b}')\n\nLeft-hand side: 4.0\nRight-hand side: 5.0\nThe function is convex.\ny = 4.0x + -3.0\n\n\n\nfrom sympy import *\n\ndef g(x):\n  return 4*x - 3\n\nx = symbols('x')\nf = f(x)\ng = g(x)\n\nplot(f, g, (x, -1, 4))\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x10af97b80&gt;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Experiments",
    "section": "",
    "text": "This site contains the code experiments for my research on appointment scheduling optimization. Specifically I am working on solution methods for single stage stochastic programming problems (1-SSP) and so-called off-line scheduling system. In an off-line scheduling system all patients that want an appointment in a specific time-frame (e.g. day) are gathered first and then given an appointment time. An example of such a problem is scheduling a number of patients into a series of fixed time slots for a single physician. Each patient will have a certain service time that can not be predicted, but has some known distribution with a mean and variance. If a certain patient needs more time to consult than his time slot the next patient will start later. In case the patient finishes earlier, the doctor has idle time.\nBoth waiting times - for patient and doctor - are undesirable. The question is how to find an optimal schedule that minimizes total waiting times. Weights can be given to both types of waiting times to accommodate for different utilities of saved time for patients and doctors.\nSolution methods for these kinds of problems can be divided into two types: (1) analytical and (2) numerical. Analytical methods applies mathematical principles to a problem in order to obtain provable results. Numerical methods use sets of iterative procedures to find solutions to problems that are hard to solve by analytical methods. A numerical method is considered accurate if it finds: (1) an optimal solution in a given time or (2) a perturbed (or near-optimal) solution with a known deterministic error bound, which is a bound on the solution’s (relative or absolute) optimality gap. An inaccurate method does not produce an error bound and the quality of the solution can not be determined (Ahmadi-Javid, Jalali, and Klassen 2017).\nIdeas:\n\nApply utility function to waiting times -&gt; one minute of waiting is more acceptable than 30 minutes of waiting.\n\n\n\n\n\n\nReferences\n\nAhmadi-Javid, Amir, Zahra Jalali, and Kenneth J Klassen. 2017. “Outpatient Appointment Systems in Healthcare: A Review of Optimization Studies.” European Journal of Operational Research 258 (1): 3–34. https://doi.org/10.1016/j.ejor.2016.06.064."
  },
  {
    "objectID": "sched-sim.html",
    "href": "sched-sim.html",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#setup",
    "href": "sched-sim.html#setup",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#run-simulation-1",
    "href": "sched-sim.html#run-simulation-1",
    "title": "Scheduling Simulation",
    "section": "Run simulation 1",
    "text": "Run simulation 1\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14 \nlns = 5\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], dtype=object) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time= {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time= 3.110063978318297')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-2",
    "href": "sched-sim.html#run-simulation-2",
    "title": "Scheduling Simulation",
    "section": "Run simulation 2",
    "text": "Run simulation 2\n\nConfigure parameters.\n\n# Configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving silnmlation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n\nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times.\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 11.132844025736073')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-3",
    "href": "sched-sim.html#run-simulation-3",
    "title": "Scheduling Simulation",
    "section": "Run simulation 3",
    "text": "Run simulation 3\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 0, 0, 60, 0, 0, 0, 60, 0, 0, 0]) # inter-arrival times\n\nnsims = nsims # number of simulations\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 22.74999554639331')]"
  },
  {
    "objectID": "schedule-probabilities.html",
    "href": "schedule-probabilities.html",
    "title": "Scheduling w/ Nested Partitions",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \ndef weak_compositions(n, k):\n    if k == 1:\n        return [[n]]\n    compositions = []\n    for i in range(n + 1):\n        for composition in weak_compositions(n - i, k - 1):\n            compositions.append([i] + composition)\n    return compositions\n  \nprint(f'Weak compositions are: {weak_compositions(2, 4)}')\n\n\nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n        \nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\nWeak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for funciotns defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s):\n            \"\"\"\n            Initialize the class with a schedule of patients and a service time distribution.\n            \n            Args:\n            d (int): An integer representing the time lenght of an interval.\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            s (list): A list of floats representing the probability distribution of service times.\n            \"\"\"\n            \n            self.parameters = dict({'x': x, 'd': d, 's': s})\n            logging.info(f'{datetime.datetime.now()} - x = {self.parameters[\"x\"]}')\n            # Initialize the system dictionary with p_min and v.\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        \n    def calculate_system_states(self, until = 1):\n            \"\"\"\n            Calculate the probabilities of the system being in each state at each time step.\n            \n            Args:\n            until (int): An optional integer representing the state until which to calculate the probabilities.\n            \"\"\"\n            \n            while self.state &lt; until:\n                logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n                \n                \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n                \n                \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n                \n                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n                \n                \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n                The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n                of waiting times of the first patient in state t and the service time distribution. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                     logging.info(f'{datetime.datetime.now()} - Done')\n                     for i in range(1, self.parameters['x'][self.state]):\n                            logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n\n                \n                \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n                the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n                Unless there are no patients in the state t. In that case the distributio of total work just before t ends is equal \n                to the distribution of work at the beginning of t. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                \"\"\"Jump to next state\"\"\"\n                self.state += 1\n    \n    def impute_compositions(self, s=1, k=2):\n      \"\"\"\n      Impute the compositions of patients in a given time interval and establish the schedule with the lowest total waiting time\n      \n      Args:\n      s (int): An integer representing the starting state.\n      k (int): An integer representing the number of states from the starting state to include in the compositions.\n      \"\"\"\n      logging.info(f'{datetime.datetime.now()} - Running impute_compositions() in state {self.state} with x = {self.parameters[\"x\"]}')\n      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end.\n      t = min(len(self.parameters['x']), s+k)\n      k = t - s\n      c = self.parameters['x'][s:t]\n      n = c.sum()\n      lowest_wt = self.system[\"ew\"].sum()\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : lowest_wt})\n      # Generate compositions\n      compositions = weak_compositions(n, k)\n      logging.info(f'{datetime.datetime.now()} - Computing {len(compositions)} compositions')\n      for comp in compositions:\n        # Insert composition in x\n        self.parameters['x'][s:t] = comp.copy()\n        # Set starting state\n        self.state = s\n        # Adjust the array for waiting time distributions to new x\n        self.system['w'][s:] = zero_arrays(self.parameters['x'][s:].copy(), len(self.parameters['s']))\n        # Recalculate distributions\n        self.calculate_system_states(until=len(self.parameters['x']))\n        self.calculate_wait_times()\n        test_wt = self.system[\"ew\"].sum()\n        if(test_wt &lt; lowest_wt):\n          lowest_wt = test_wt\n          store_optim['x'] = self.parameters['x'].copy()\n          newsystem = copy.deepcopy(self.system)\n          store_optim['system'] = newsystem\n          store_optim['tot_wt'] = lowest_wt\n          logging.info(f'{datetime.datetime.now()} - Found lower wt = {lowest_wt} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      logging.info(f'{datetime.datetime.now()} - Final result wt = {lowest_wt} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')    \n      self.parameters['x'] = store_optim['x'].copy()\n      self.system['p_min'] = store_optim['system']['p_min']\n      self.system['p_plus'] = store_optim['system']['p_plus']\n      self.system['w'] = store_optim['system']['w']\n      self.system['ew'] = store_optim['system']['ew']\n    \n    def search_function(self, k=1):\n      for i in range(1, len(self.parameters['x'] - k)):\n        self.impute_compositions(s=i, k=k)\n        \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n    # Initialize time counter\n      t = 0\n      # Calculate the expected waiting time for each time step\n      for t, w in enumerate(self.system['w']):\n          ew = 0\n          for i in w:\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(i))\n              b = i\n              wt = np.dot(a, b)\n              ew += wt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][t] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n      \n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values,\n                    text=np.around(values, 2),\n                    texttemplate=\"%{text}\",\n                    textfont={\"size\":10}\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of tasks (n) over the intervals are generated (compositions), and for each possible distribution, the system states are recalculated.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, u=1, print_system=True):\n  schedule = Schedule(x=x, d=d, s=s)\n  schedule.calculate_system_states(until=u)\n  schedule.calculate_wait_times()\n  if(print_system): print(schedule)\n  schedule.search_function(k=3)\n  return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 4\nsch = run_schedule(x, d, s, u, False)\nsch.visualize_system('p_min')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\n# x = np.array([1, 1], dtype=np.int64)\n# d = 5\n# l = 6\n# limit = calc_distr_limit(l * x.sum())+1\n# service_times = range(0, limit)\n# s = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\n# u = len(x)\n#   \n# sch = run_schedule(x, d, s, u, True)\n# \n# sch.visualize_system('p_min')\n# sch.visualize_state(1, 'p_min')\n\n'Test case with validation in spreadsheet\\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing'\n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = 4\n  \nsch = run_schedule(x, d, s, u, False)\n\n\nsch.visualize_state(2)\n\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n\n                                                \n\n\n\nT = 24 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2 \nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nsch = run_schedule(x, d, s, u, False)\nsch.visualize_system('p_plus')\n\nInitial schedule: [2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1]\n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "sim-based-opt.html",
    "href": "sim-based-opt.html",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#setup",
    "href": "sim-based-opt.html#setup",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#run-simulations",
    "href": "sim-based-opt.html#run-simulations",
    "title": "Simulation Based Optimization",
    "section": "Run simulations",
    "text": "Run simulations\n\n# Simulation 1\n\ntic = time.time()\nsim = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nN = len(iats) # number of patients\n# T = len(sim) # number of intervals\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimreswt = []\nsimresln = 0\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = loss = 0.5 * mwt + 0.5 * mln\ntoc = time.time()\nprint(toc - tic)\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\n1.8773250579833984\n\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 1 1 1 1 1 1 1], mwt: 1.611234950205387, mln: 1.9842744867115258, loss: 1.7977547184584566')\n\n\n\n\n\n\n\n\n\n# Simulation 2\n\nsim = np.array([2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [2 0 1 1 1 1 1 1 1 1 1 1], mwt: 2.1962758284409163, mln: 1.9805515764234785, loss: 2.0884137024321974')\n\n\n\n\n\n\n\n\n\n# Simulation 3\n\nsim = np.array([1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 2 0 1 1 1 1 1 1 1], mwt: 2.2792733925483533, mln: 1.9745720674699918, loss: 2.1269227300091726')\n\n\n\n\n\n\n\n\n\n# Simulation 4\n\nsim = np.array([1, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 2 0 1 1 1 1 1], mwt: 2.2902016946902832, mln: 1.9611865168511518, loss: 2.1256941057707177')"
  },
  {
    "objectID": "search-function.html",
    "href": "search-function.html",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#setup",
    "href": "search-function.html#setup",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#run-simulations-and-search",
    "href": "search-function.html#run-simulations-and-search",
    "title": "Search Function",
    "section": "Run simulations and search",
    "text": "Run simulations and search\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 30\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 8 patients and 12 timeslots.\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 20 20 20 20 20 10],\niats_diff: [  0  20   0   0   0   0 -10],\nloss = 3.6448444292504667, calc time: 1.3158788681030273 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 20 20 20 20 20 10  0],\niats_diff: [ 20   0   0   0   0 -10 -10],\nloss = 7.23491641216485, calc time: 1.2501838207244873 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 10 30 20 20 20 10],\niats_diff: [  0  10  20 -10   0   0 -10],\nloss = 4.005330473341495, calc time: 1.2633132934570312 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 20 10 30 20 20 10],\niats_diff: [  0  20 -10  20 -10   0 -10],\nloss = 3.875707430198978, calc time: 1.284513235092163 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 20 20 10 30 20 10],\niats_diff: [  0  20   0 -10  20 -10 -10],\nloss = 3.8095009383189704, calc time: 1.4249770641326904 secs\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 20 20 20 10 30 10],\niats_diff: [  0  20   0   0 -10  20 -20],\nloss = 3.74866457839218, calc time: 1.6291420459747314 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 0 1 1 0 1] with loss: 3.035896134346853\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 20 20 20 20 10 20],\niats_diff: [  0  20   0   0   0 -10  10],\nloss = 3.035896134346853, calc time: 1.430785894393921 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 1 0 2],\niats: [ 0 20 20 20 20 10 20  0],\niats_diff: [ 20   0   0   0 -10  10 -20],\nloss = 6.273176480711154, calc time: 1.4351861476898193 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 10 30 20 20 10 20],\niats_diff: [  0  10  20 -10   0 -10  10],\nloss = 3.3959652981614497, calc time: 1.4279837608337402 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 1 0 1],\niats: [ 0  0 20 10 30 20 10 20],\niats_diff: [  0  20 -10  20 -10 -10  10],\nloss = 3.2645071110623345, calc time: 1.447577714920044 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 1 0 1],\niats: [ 0  0 20 20 10 30 10 20],\niats_diff: [  0  20   0 -10  20 -20  10],\nloss = 3.187095286293613, calc time: 1.4314541816711426 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 1 0 1 0 1] with loss: 2.897111388043177\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 20 20 20 10 20 20],\niats_diff: [  0  20   0   0 -10  10   0],\nloss = 2.897111388043177, calc time: 1.406205177307129 secs\n\nschedule: [1 0 1 0 1 0 1 1 0 1 0 2],\niats: [ 0 20 20 20 10 20 20  0],\niats_diff: [ 20   0   0 -10  10   0 -20],\nloss = 6.036434209184975, calc time: 1.4425418376922607 secs\n\nschedule: [2 1 0 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 10 30 20 10 20 20],\niats_diff: [  0  10  20 -10 -10  10   0],\nloss = 3.2558610782428685, calc time: 1.4219460487365723 secs\n\nschedule: [2 0 1 1 0 0 1 1 0 1 0 1],\niats: [ 0  0 20 10 30 10 20 20],\niats_diff: [  0  20 -10  20 -20  10   0],\nloss = 3.117431624837555, calc time: 1.4425170421600342 secs\n\n\n#### Found better schedule: [2 0 1 0 1 1 0 1 0 1 0 1] with loss: 2.890114946948\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.890114946948, calc time: 1.5799851417541504 secs\n\nschedule: [1 0 1 0 1 1 0 1 0 1 0 2],\niats: [ 0 20 20 10 20 20 20  0],\niats_diff: [ 20   0 -10  10   0   0 -20],\nloss = 5.975262960420585, calc time: 1.3696208000183105 secs\n\nschedule: [2 1 0 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 10 30 10 20 20 20],\niats_diff: [  0  10  20 -20  10   0   0],\nloss = 3.2439703616845144, calc time: 1.379075050354004 secs\n\nschedule: [2 0 1 1 0 1 0 1 0 1 0 1],\niats: [ 0  0 20 10 20 20 20 20],\niats_diff: [  0  20 -10  10   0   0   0],\nloss = 2.988033862331597, calc time: 1.5410091876983643 secs\n\nschedule: [2 0 1 0 2 0 0 1 0 1 0 1],\niats: [ 0  0 20 20  0 30 20 20],\niats_diff: [  0  20   0 -20  30 -10   0],\nloss = 3.3016153379873847, calc time: 1.4073233604431152 secs\n\nschedule: [2 0 1 0 1 1 1 0 0 1 0 1],\niats: [ 0  0 20 20 10 10 30 20],\niats_diff: [  0  20   0 -10   0  20 -10],\nloss = 3.1189961894604457, calc time: 1.4754810333251953 secs\n\nschedule: [2 0 1 0 1 1 0 1 1 0 0 1],\niats: [ 0  0 20 20 10 20 10 30],\niats_diff: [  0  20   0 -10  10 -10  20],\nloss = 3.0072950954760054, calc time: 1.5021700859069824 secs\n\nschedule: [2 0 1 0 1 1 0 1 0 1 1 0],\niats: [ 0  0 20 20 10 20 20 10],\niats_diff: [  0  20   0 -10  10   0 -10],\nloss = 4.01997534868512, calc time: 1.4452011585235596 secs\n\nFinished iterating in: 37 seconds\n\nBest result:\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.890114946948, calc time: 1.4361159801483154 secs\n\n\n\n\ndef distribute_elements(n, t):\n    quotient, remainder = divmod(t, n-1)\n    elements = np.zeros(t)\n    for i in range(n-1):\n        elements[i * quotient] = 1\n    elements[0] = elements[0] + 1\n    return elements\n  \n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 20 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 24 # number of intervals\nN = 9 # number of patients\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = distribute_elements(N, T)\nsim = sim.astype(int) # initial schedule\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\n\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 300\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 9 patients and 24 timeslots.\nGenerated new psm\n\nschedule: [2 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0],\niats: [ 0  0 30 30 30 30 30 30 30],\niats_diff: [ 0 30  0  0  0  0  0  0],\nloss = 5.114397269883165, calc time: 1.4137530326843262 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1] with loss: 4.500215905815976\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 30 30 20],\niats_diff: [ 30   0   0   0   0   0   0 -10],\nloss = 4.500215905815976, calc time: 1.6029250621795654 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 2],\niats: [30 30 30 30 30 30 30 20  0],\niats_diff: [  0   0   0   0   0   0 -10 -20],\nloss = 12.159577903084989, calc time: 1.507601022720337 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 20 40 30 30 30 30 30 20],\niats_diff: [ 20  20 -10   0   0   0   0 -10],\nloss = 4.571659822950219, calc time: 1.5279979705810547 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 20 40 30 30 30 30 20],\niats_diff: [ 30 -10  20 -10   0   0   0 -10],\nloss = 4.574329999745175, calc time: 1.492753267288208 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 20 40 30 30 30 20],\niats_diff: [ 30   0 -10  20 -10   0   0 -10],\nloss = 4.573751887783908, calc time: 1.5069589614868164 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 20 40 30 30 20],\niats_diff: [ 30   0   0 -10  20 -10   0 -10],\nloss = 4.573751780981003, calc time: 1.4642541408538818 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 20 40 30 20],\niats_diff: [ 30   0   0   0 -10  20 -10 -10],\nloss = 4.5721619796816, calc time: 1.4584929943084717 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 20 40 20],\niats_diff: [ 30   0   0   0   0 -10  20 -20],\nloss = 4.55542136621789, calc time: 1.4739601612091064 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1] with loss: 4.021041608386607\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 30 20 30],\niats_diff: [ 30   0   0   0   0   0 -10  10],\nloss = 4.021041608386607, calc time: 1.463674783706665 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 2],\niats: [30 30 30 30 30 30 20 30  0],\niats_diff: [  0   0   0   0   0 -10  10 -30],\nloss = 11.505842327192772, calc time: 1.454145908355713 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 30 20 30],\niats_diff: [ 20  20 -10   0   0   0 -10  10],\nloss = 4.092485525520852, calc time: 1.5121667385101318 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 30 20 30],\niats_diff: [ 30 -10  20 -10   0   0 -10  10],\nloss = 4.095152898792898, calc time: 1.505676031112671 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 30 20 30],\niats_diff: [ 30   0 -10  20 -10   0 -10  10],\nloss = 4.094550175936864, calc time: 1.5785810947418213 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 30 20 30],\niats_diff: [ 30   0   0 -10  20 -10 -10  10],\nloss = 4.0942850163484374, calc time: 1.4544129371643066 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 40 20 30],\niats_diff: [ 30   0   0   0 -10  20 -20  10],\nloss = 4.089246968671449, calc time: 1.4848241806030273 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1] with loss: 3.96513584212817\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 20 30 30],\niats_diff: [ 30   0   0   0   0 -10  10   0],\nloss = 3.96513584212817, calc time: 1.4641931056976318 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 30 20 30 30  0],\niats_diff: [  0   0   0   0 -10  10   0 -30],\nloss = 11.430863992351732, calc time: 1.4762592315673828 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 20 30 30],\niats_diff: [ 20  20 -10   0   0 -10  10   0],\nloss = 4.036576564918305, calc time: 1.4948899745941162 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 20 30 30],\niats_diff: [ 30 -10  20 -10   0 -10  10   0],\nloss = 4.0392231062512405, calc time: 1.4717540740966797 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 20 30 30],\niats_diff: [ 30   0 -10  20 -10 -10  10   0],\nloss = 4.038418224219281, calc time: 1.4732840061187744 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 20 30 30],\niats_diff: [ 30   0   0 -10  20 -20  10   0],\nloss = 4.036182809072835, calc time: 1.4688560962677002 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9573049854254365\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 30 30 30],\niats_diff: [ 30   0   0   0 -10  10   0   0],\nloss = 3.9573049854254365, calc time: 1.46909499168396 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 20 30 30 30  0],\niats_diff: [  0   0   0 -10  10   0   0 -30],\nloss = 11.420862321379374, calc time: 1.459392786026001 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 20 30 30 30],\niats_diff: [ 20  20 -10   0 -10  10   0   0],\nloss = 4.028716881270472, calc time: 1.4925520420074463 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 20 30 30 30],\niats_diff: [ 30 -10  20 -10 -10  10   0   0],\nloss = 4.031113699550697, calc time: 1.467689037322998 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 20 30 30 30],\niats_diff: [ 30   0 -10  20 -20  10   0   0],\nloss = 4.028298442992774, calc time: 1.4831650257110596 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.956503966703464\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.956503966703464, calc time: 1.517651081085205 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.418984357936159, calc time: 1.4722809791564941 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.027655820901562, calc time: 1.4656941890716553 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.028198626361626, calc time: 1.493466854095459 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9560463324608346\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.471069097518921 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4581289291381836 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.5422179698944092 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4631879329681396 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4787437915802002 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4754621982574463 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4745419025421143 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 2.3279621601104736 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.5881938934326172 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.5158979892730713 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.5046639442443848 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4473397731781006 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.477459192276001 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4750168323516846 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4823932647705078 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4942560195922852 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.555067777633667 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4754369258880615 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.500781774520874 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4675710201263428 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4886739253997803 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4644429683685303 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.510016918182373 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4765710830688477 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.5019168853759766 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4643781185150146 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.482698678970337 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.463160753250122 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4968078136444092 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4779889583587646 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.5327730178833008 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.45355224609375 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.4718432426452637 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4705462455749512 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4640839099884033 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4695286750793457 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.45871901512146 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4972107410430908 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.5553207397460938 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.451352834701538 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4620239734649658 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.456387996673584 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.4679391384124756 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.513969898223877 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4808251857757568 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4710907936096191 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4784631729125977 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4661948680877686 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4743061065673828 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4679391384124756 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4621570110321045 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4661638736724854 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.4712498188018799 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4784739017486572 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4616219997406006 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.5805020332336426 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.6249151229858398 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.5199570655822754 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.567004919052124 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.5039100646972656 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4582457542419434 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.5690417289733887 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.5259709358215332 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.5174877643585205 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4721291065216064 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4760832786560059 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.5876190662384033 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.5659258365631104 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.5174946784973145 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.5944058895111084 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.5319461822509766 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4442059993743896 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.5411601066589355 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4720020294189453 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4546010494232178 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.464062213897705 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4762940406799316 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4746689796447754 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.5001881122589111 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4507758617401123 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.473067045211792 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4559760093688965 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.463254690170288 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.5224182605743408 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4664568901062012 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4747991561889648 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4505579471588135 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4645278453826904 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4618911743164062 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4553980827331543 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4733068943023682 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4651761054992676 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.4632949829101562 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.521744966506958 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.463789939880371 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4567129611968994 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.473588228225708 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.5332059860229492 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.5097789764404297 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.450434923171997 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4618537425994873 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4378371238708496 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.47589111328125 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4641880989074707 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4662573337554932 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4651148319244385 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4785528182983398 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4478428363800049 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4584088325500488 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4378256797790527 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4722397327423096 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4334189891815186 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.4811351299285889 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.5258331298828125 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4438788890838623 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.4518311023712158 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4446940422058105 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4530560970306396 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.457284927368164 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.574603796005249 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.446869134902954 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4384400844573975 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.5064351558685303 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.5177838802337646 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4370949268341064 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.5369467735290527 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4606342315673828 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.461050033569336 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4529249668121338 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4509539604187012 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4863147735595703 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4443058967590332 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.449371099472046 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4686238765716553 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4492907524108887 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.445876121520996 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.458009958267212 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4478180408477783 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4800961017608643 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.5257759094238281 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.5022037029266357 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.434783935546875 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.470348834991455 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4656810760498047 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.4903109073638916 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.543661117553711 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4565889835357666 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4643151760101318 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4609928131103516 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4547557830810547 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4577877521514893 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4794073104858398 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.4615659713745117 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4566371440887451 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.457921028137207 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.455368995666504 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4530911445617676 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.452826976776123 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4443888664245605 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.492164134979248 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4681248664855957 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.419061987918127, calc time: 1.4491958618164062 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.024948675081106, calc time: 1.4633889198303223 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.956424313507956, calc time: 1.4973602294921875 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.291357174400938, calc time: 1.464879035949707 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.063459598201268, calc time: 1.485969066619873 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.033574329274549, calc time: 1.4694898128509521 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.028155652925329, calc time: 1.4694511890411377 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 4.000523258635278, calc time: 1.4501256942749023 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.589888378660417, calc time: 1.4634740352630615 secs\n\nFinished iterating in: 307 seconds\n\nBest result:\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9560463324608346, calc time: 1.4975991249084473 secs"
  }
]