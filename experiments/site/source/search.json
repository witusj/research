[
  {
    "objectID": "local-search-schedule-probabilities.html",
    "href": "local-search-schedule-probabilities.html",
    "title": "Scheduling w/ Local Search",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\nfrom itertools import chain, combinations\nimport copy\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n    \ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]\n\ndef get_v_star(t):\n    # Create an initial vector 'u' of zeros with length 't'\n    u = np.zeros(t, dtype=np.int64)\n    # Set the first element of vector 'u' to -1\n    u[0] = -1\n    # Set the last element of vector 'u' to 1\n    u[-1] = 1\n    # Initialize the list 'v_star' with the initial vector 'u'\n    v_star = [u]\n    # Loop over the length of 'u' minus one times\n    for i in range(len(u) - 1):\n        # Append the last element of 'u' to the front of 'u'\n        u = np.append(u[-1], u)\n        # Remove the last element of 'u' to maintain the same length\n        u = np.delete(u, -1)\n        # Append the updated vector 'u' to the list 'v_star'\n        v_star.append(u)\n    # Convert the list of vectors 'v_star' into a NumPy array and return it\n    return(np.array(v_star))\n\n# Example of function call:\n# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row\n\ndef generate_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  logging.info(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}\n  # 'ids' will be a list of tuples, where each tuple is a subset of indices\n  ids = list(powerset(range(T)))\n\n  logging.info(f'Neighborhood size = {len(ids)}')\n\n  # Select the vectors from 'v_star' that correspond to the indices in each subset\n  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\n  sub_sets = [v_star[i] for i in ids]\n\n  # Sum the vectors within each subset and flatten the result to get a 1-D array\n  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\n  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n  \n  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  logging.info(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ndef generate_small_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  logging.info(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  neighborhood = np.array([schedule + v_star[i] for i in range(len(v_star))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  logging.info(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ndef distribute_patients(n_patients, n_timeslots):\n    # Create a list with all slots initially empty\n    distribution = [0] * n_timeslots\n\n    # Place patients in timeslots\n    for i in range(n_patients):\n        # Calculate the slot for each patient\n        slot = round(i * n_timeslots / n_patients)\n        distribution[slot] = 1\n\n    return distribution\n\ndef plot_timeline(slots, title):\n    # Create a figure\n    fig = go.Figure()\n\n    # Iterate over each timeslot and add a bar for occupied slots\n    for i, slot in enumerate(slots):\n        fig.add_trace(go.Bar(x=[i], y=[slot], width=0.8, marker_color='black'))\n\n    # Update layout\n    fig.update_layout(\n        title=title,\n        xaxis_title=\"Timeslots\",\n        yaxis=dict(showticklabels=False, showgrid=False, zeroline=False),\n        showlegend=False\n    )\n\n    # Set y-axis range\n    fig.update_yaxes(range=[0, np.max(slots)])\n\n    # Show the figure\n    fig.show()\n    \ndef service_time_with_no_shows(s, q):\n  # \"\"\"\n  # Function to adjust a distribution of service times for no-shows\n  # \n  # Args:\n  #     s (numpy.ndarray): An array with service times.\n  #     q (double): The fraction of no-shows.\n  # \n  # Returns:\n  #     numpy.ndarray: The adjusted array of service times.\n  # \"\"\"\n  \n  s_adj = s * (1-q)\n  s_adj[0] = s_adj[0] + q\n  return(s_adj)\n\ndef add_lists(short_list, long_list):\n  # \"\"\"\n  # This function takes in two lists and returns a new list where each element \n  # is the sum of the elements from the input lists at the corresponding position.\n  # If the lists are of different lengths, the shorter list is extended with zeros \n  # to match the length of the longer list.\n  # \n  # Parameters:\n  # - short_list (list): The shorter list of numbers.\n  # - long_list (list): The longer list of numbers.\n  # \n  # Returns:\n  # - list: A list containing the element-wise sum of the two input lists.\n  # \"\"\"\n  \n  # Extend the short lists to the length of the long list with zeros\n  short_list.extend([0] * (len(long_list) - len(short_list)))\n  \n  # Sum the elements of the two lists element-wise\n  result = [a + b for a, b in zip(short_list, long_list)]\n  \n  return result\n\ndef calculate_rolling_convolution(p_y, s):\n  conv_list = s\n  limit = len(p_y)\n  v = [x * p_y[0] for x in conv_list]\n  for i in range(1, limit):\n    conv_list = np.convolve(conv_list, s)\n    v = add_lists(v, [x * p_y[i] for x in conv_list])\n    \n  return(v)\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times. In the examples below we model service times as a Poisson process, because we are calculating in discrete time units.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for functions defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s, q):\n        \"\"\"\n        Initialize the Schedule class with patient schedules and a service time distribution.\n\n        Args:\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            d (int): An integer representing the length of a time interval.\n            s (list): A list of floats representing the probability distribution of service times.\n        \"\"\"\n        if not all(isinstance(i, np.integer) and i &gt;= 0 for i in x):\n            raise ValueError(\"All elements in x must be non-negative integers.\")\n        if not isinstance(d, int) or d &lt;= 0:\n            raise ValueError(\"d must be a positive integer.\")\n        if not all(isinstance(i, float) and 0 &lt;= i &lt;= 1 for i in s):\n            raise ValueError(\"All elements in s must be floats between 0 and 1.\")\n        if not isinstance(q, float) and 0 &lt;= q &lt;= 1:\n            raise ValueError(\"q must be a float between 0 and 1.\")\n\n        self.parameters = {'x': x, 'd': d, 's': s, 'q': q}\n        self.parameters['s'] = service_time_with_no_shows(self.parameters['s'], self.parameters['q'])\n        self._initialize_system()\n            \n    def _initialize_system(self):\n        \"\"\" Initialize the system's internal state. \"\"\"\n        self.state = 0\n        length_x = len(self.parameters['x'])\n        length_s = len(self.parameters['s'])\n        self.system = {\n            'p_min': np.zeros((length_x + 1, length_s), dtype=np.float64),\n            'p_plus': np.zeros((length_x, length_s), dtype=np.float64),\n            'w': [np.zeros((i, length_s), dtype=np.float64) for i in self.parameters['x']],\n            'ew': np.zeros(length_x, dtype=np.float64)\n        }\n        self.system['p_min'][0][0] = 1\n        if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n        self._update_p_plus(0)\n        self.state = 1\n            \n    def _update_p_plus(self, state):\n        \"\"\" Update the p_plus array based on the current state. \"\"\"\n        if self.parameters['x'][state] == 0:\n            self.system['p_plus'][state] = self.system['p_min'][state].copy()\n        else:\n            self.system['p_plus'][state] = np.convolve(self.system['w'][state][-1], self.parameters['s'], mode='full')[:len(self.parameters['s'])]\n        logging.info(f\"p_plus = {self.system['p_plus'][state]}\")\n            \n    def _calculate_state(self):\n        logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n        \n        \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n        logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n        self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n        \n        \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n        \n        self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n        \n        \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n        The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n        of waiting times of the first patient in state t and the service time distribution. \n        The resulting vector is truncated to the length of the service time distribution.\"\"\"\n        if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                logging.info(self.system['w'][self.state][0])\n                logging.info(f'{datetime.datetime.now()} - Done')\n                for i in range(1, self.parameters['x'][self.state]):\n                    logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                    self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                    logging.info(self.system['w'][self.state][i])\n\n        \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n        the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n        Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal \n        to the distribution of work at the beginning of t. \n        The resulting vector is truncated to the length of the service time distribution.\"\"\"\n        logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n        self._update_p_plus(self.state)\n    \n    def calculate_system_states(self, until=1):\n        \"\"\"\n        Calculate the probabilities of the system being in each state at each time step.\n\n        Args:\n            until (int, optional): The state until which to calculate the probabilities. Defaults to 1.\n        \"\"\"\n        while self.state &lt; until:\n            self._calculate_state()\n            self.state += 1\n  \n      \n    def local_search(self, omega=0.5):\n        \"\"\"\n        Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting times stop searching.  \n        \"\"\"\n        \n        # Calculate initial loss\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n        \n        # Continue the search until no improvement is found\n        while True:  # Start an outer loop that will continue until explicitly broken\n            nh = generate_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood\n            improved = False  # Flag to check if an improvement was found in the inner loop\n            \n            for y in nh:  # Inner loop to search through the neighborhood\n                # Insert first element of nh in x\n                self.parameters['x'] = y.copy()\n                logging.info(f\"Test schedule = {self.parameters['x']}\")\n                # Set starting state\n                self.state = 0\n                # If start state is 0 reinitialize p_min, w and p_plus in state 0\n                self._initialize_system()\n                self.calculate_system_states(until=len(self.parameters['x']))\n                logging.info(\"System recalculated\")\n                self.calculate_wait_times()\n                test_wt = self.system[\"ew\"].sum()\n                logging.info(f\"Average waiting time={test_wt / self.parameters['x'].sum()}\")\n                self.calculate_tardiness()\n                indices = np.arange(self.system['p_min'][-1].size) \n                exp_tard = (indices * self.system['p_min'][-1]).sum()\n                logging.info(f'Expected tardiness={exp_tard}')\n                test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n                logging.info(f'obj_value = {test_loss}')\n                # If a neighborhood with a lower waiting time is found, store the system\n                if(test_loss &lt; lowest_loss):\n                    lowest_loss = test_loss\n                    store_optim['x'] = self.parameters['x'].copy()\n                    newsystem = copy.deepcopy(self.system)\n                    store_optim['system'] = newsystem\n                    store_optim['tot_wt'] = test_wt\n                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                    improved = True  # Set the flag because an improvement was found\n                    break  # Exit the inner loop to generate a new neighborhood\n            \n            if not improved:  # If no improvement was found in the inner loop\n                logging.info(f'Finished searching')\n                # Set the system to the stored optimal system \n                logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                self.parameters['x'] = store_optim['x'].copy()\n                self.system['p_min'] = store_optim['system']['p_min']\n                self.system['p_plus'] = store_optim['system']['p_plus']\n                self.system['w'] = store_optim['system']['w']\n                self.system['ew'] = store_optim['system']['ew']\n                break  # Exit the outer loop - the search is complete\n      \n        \n    def small_local_search(self, omega=0.5):\n          \"\"\"\n          Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting stop searching.  \n          \"\"\"\n          # Calculate initial loss\n          test_wt = self.system[\"ew\"].sum()\n          self.calculate_tardiness()\n          indices = np.arange(self.system['p_min'][-1].size) \n          exp_tard = (indices * self.system['p_min'][-1]).sum()\n          lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n          store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n        \n          # Continue the search until no improvement is found\n          while True:  # Start an outer loop that will continue until explicitly broken\n              nh = generate_small_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood\n              improved = False  # Flag to check if an improvement was found in the inner loop\n              \n              for y in nh:  # Inner loop to search through the neighborhood\n                  # Insert first element of nh in x\n                  self.parameters['x'] = y.copy()\n                  logging.info(f\"Test schedule = {self.parameters['x']}\")\n                  # Set starting state\n                  self.state = 0\n                  # If start state is 0 reinitialize p_min, w and p_plus in state 0\n                  if(self.state == 0):\n                      self.system = dict({\n                          'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                          'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n                      })\n                      # Set the first element of p_min in the initial state to 1.\n                      self.system['p_min'][0][0] = 1\n                      # Initialize array of arrays for saving waiting times distributions per patient\n                      self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n                      if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                               self.system['w'][0][0] = self.system['p_min'][0].copy()\n                               for i in range(1, self.parameters['x'][0]):\n                                      self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                      self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                      # Initialize array for saving total expected waiting times per state\n                      self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n                      # Set the initial state to 1.\n                      self.state = 1\n                  self.calculate_system_states(until=len(self.parameters['x']))\n                  logging.info(\"System recalculated\")\n                  self.calculate_wait_times()\n                  test_wt = self.system[\"ew\"].sum()\n                  logging.info(f\"Average waiting time={test_wt / self.parameters['x'].sum()}\")\n                  self.calculate_tardiness()\n                  indices = np.arange(self.system['p_min'][-1].size) \n                  exp_tard = (indices * self.system['p_min'][-1]).sum()\n                  logging.info(f'Expected tardiness={exp_tard}')\n                  test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n                  logging.info(f'obj_value = {test_loss}')\n                  # If a schedule with a lower waiting time is found, store the system\n                  if(test_loss &lt; lowest_loss):\n                    lowest_loss = test_loss\n                    store_optim['x'] = self.parameters['x'].copy()\n                    newsystem = copy.deepcopy(self.system)\n                    store_optim['system'] = newsystem\n                    store_optim['tot_wt'] = test_wt\n                    logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]}')\n                    improved = True  # Set the flag because an improvement was found\n                    break  # Exit the inner loop to generate a new neighborhood\n              \n              if not improved:  # If no improvement was found in the inner loop\n                logging.info(f'Finished searching')\n                # Set the system to the stored optimal system \n                logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n                self.parameters['x'] = store_optim['x'].copy()\n                self.system['p_min'] = store_optim['system']['p_min']\n                self.system['p_plus'] = store_optim['system']['p_plus']\n                self.system['w'] = store_optim['system']['w']\n                self.system['ew'] = store_optim['system']['ew']\n                break  # Exit the outer loop - the search is complete\n          \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      # logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n      for interval, wtdists in enumerate(self.system['w']):\n          ew = 0\n          for nr, dist in enumerate(wtdists):\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(dist))\n              b = dist\n              meanwt = np.dot(a, b)\n              logging.info(f\"Mean waiting time for patient {nr} in interval {interval} = {meanwt}\")\n              ew += meanwt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][interval] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values,\n                    colorscale=[\n                      [0, 'white'],  # white color at the bottom\n                      [1, 'red']     # red color at the top\n                    ]\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, q, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s, q=q)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.local_search(omega=omega)\n    return(schedule)\n\n\ndef run_schedule_small_search(x, d, s, q, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s, q=q)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.small_local_search(omega=omega)\n    return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\nq = 0.1\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\n# s= service_time_with_no_shows(s, q)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 5\nomega = 0.5\nsch = run_schedule(x, d, s, q, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3\nsch = run_schedule(x, d, s, q, u, omega, False)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.5\nsch = run_schedule(x, d, s, q, u, omega, False)\nx_final = sch.parameters['x']\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\n\n\n                                                \n\n\n\n                                                \n\n\n\nsch.visualize_state(2)\n\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n\n                                                \n\n\n\nwith open(\"logs.txt\",'w') as file:\n  pass\nT = 12 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2\nx[1] = 1\nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.5\nsch = run_schedule(x, d, s, q, u, omega, False)\nsch.visualize_system('p_min')\nx_final = sch.parameters['x']\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\n\nInitial schedule: [2 1 1 0 1 0 1 0 1 0 1 1]\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n                                                \n\n\n\nwith open(\"logs.txt\",'w') as file:\n  pass\n\nT = 14 # number of intervals\nN = 10\nx = np.array(distribute_patients(N, T))\n\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 5\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.999\nsch = run_schedule_small_search(x, d, s, q, u, omega, False)\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\nsch.visualize_system('p_min')\n\nInitial schedule: [1 1 0 1 1 0 1 1 1 0 1 1 0 1]\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "search-function.html",
    "href": "search-function.html",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#setup",
    "href": "search-function.html#setup",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#run-simulations-and-search",
    "href": "search-function.html#run-simulations-and-search",
    "title": "Search Function",
    "section": "Run simulations and search",
    "text": "Run simulations and search\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 30\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 8 patients and 12 timeslots.\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 20 20 20 20 20 10],\niats_diff: [  0  20   0   0   0   0 -10],\nloss = 3.6727759159954, calc time: 1.4546797275543213 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 20 20 20 20 20 10  0],\niats_diff: [ 20   0   0   0   0 -10 -10],\nloss = 7.268892702336524, calc time: 1.3617851734161377 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 10 30 20 20 20 10],\niats_diff: [  0  10  20 -10   0   0 -10],\nloss = 4.032539235470006, calc time: 1.3539068698883057 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 20 10 30 20 20 10],\niats_diff: [  0  20 -10  20 -10   0 -10],\nloss = 3.904287306680918, calc time: 1.4146549701690674 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 20 20 10 30 20 10],\niats_diff: [  0  20   0 -10  20 -10 -10],\nloss = 3.8401736725185236, calc time: 1.436445951461792 secs\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 20 20 20 10 30 10],\niats_diff: [  0  20   0   0 -10  20 -20],\nloss = 3.776385764404127, calc time: 1.433980941772461 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 0 1 1 0 1] with loss: 3.0531540471848664\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 20 20 20 20 10 20],\niats_diff: [  0  20   0   0   0 -10  10],\nloss = 3.0531540471848664, calc time: 1.4229531288146973 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 1 0 2],\niats: [ 0 20 20 20 20 10 20  0],\niats_diff: [ 20   0   0   0 -10  10 -20],\nloss = 6.304992012270459, calc time: 1.344115972518921 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 10 30 20 20 10 20],\niats_diff: [  0  10  20 -10   0 -10  10],\nloss = 3.412547770886813, calc time: 1.3912739753723145 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 1 0 1],\niats: [ 0  0 20 10 30 20 10 20],\niats_diff: [  0  20 -10  20 -10 -10  10],\nloss = 3.2817958252928987, calc time: 1.3957152366638184 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 1 0 1],\niats: [ 0  0 20 20 10 30 10 20],\niats_diff: [  0  20   0 -10  20 -20  10],\nloss = 3.2061333139236314, calc time: 1.4310212135314941 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 1 0 1 0 1] with loss: 2.912371511513167\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 20 20 20 10 20 20],\niats_diff: [  0  20   0   0 -10  10   0],\nloss = 2.912371511513167, calc time: 1.4481170177459717 secs\n\nschedule: [1 0 1 0 1 0 1 1 0 1 0 2],\niats: [ 0 20 20 20 10 20 20  0],\niats_diff: [ 20   0   0 -10  10   0 -20],\nloss = 6.068509632364982, calc time: 1.4101901054382324 secs\n\nschedule: [2 1 0 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 10 30 20 10 20 20],\niats_diff: [  0  10  20 -10 -10  10   0],\nloss = 3.2704091709113485, calc time: 1.4125139713287354 secs\n\nschedule: [2 0 1 1 0 0 1 1 0 1 0 1],\niats: [ 0  0 20 10 30 10 20 20],\niats_diff: [  0  20 -10  20 -20  10   0],\nloss = 3.1324869670043602, calc time: 1.3768110275268555 secs\n\n\n#### Found better schedule: [2 0 1 0 1 1 0 1 0 1 0 1] with loss: 2.9055917521931005\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.9055917521931005, calc time: 1.356637954711914 secs\n\nschedule: [1 0 1 0 1 1 0 1 0 1 0 2],\niats: [ 0 20 20 10 20 20 20  0],\niats_diff: [ 20   0 -10  10   0   0 -20],\nloss = 6.001462200980834, calc time: 1.3394598960876465 secs\n\nschedule: [2 1 0 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 10 30 10 20 20 20],\niats_diff: [  0  10  20 -20  10   0   0],\nloss = 3.258541262811648, calc time: 1.3359270095825195 secs\n\nschedule: [2 0 1 1 0 1 0 1 0 1 0 1],\niats: [ 0  0 20 10 20 20 20 20],\niats_diff: [  0  20 -10  10   0   0   0],\nloss = 3.001419922660575, calc time: 1.4098777770996094 secs\n\nschedule: [2 0 1 0 2 0 0 1 0 1 0 1],\niats: [ 0  0 20 20  0 30 20 20],\niats_diff: [  0  20   0 -20  30 -10   0],\nloss = 3.319298933155677, calc time: 1.3787472248077393 secs\n\nschedule: [2 0 1 0 1 1 1 0 0 1 0 1],\niats: [ 0  0 20 20 10 10 30 20],\niats_diff: [  0  20   0 -10   0  20 -10],\nloss = 3.1340298217362403, calc time: 1.3387770652770996 secs\n\nschedule: [2 0 1 0 1 1 0 1 1 0 0 1],\niats: [ 0  0 20 20 10 20 10 30],\niats_diff: [  0  20   0 -10  10 -10  20],\nloss = 3.016466036063996, calc time: 1.362403154373169 secs\n\nschedule: [2 0 1 0 1 1 0 1 0 1 1 0],\niats: [ 0  0 20 20 10 20 20 10],\niats_diff: [  0  20   0 -10  10   0 -10],\nloss = 4.046714570805916, calc time: 1.3115530014038086 secs\n\nFinished iterating in: 36 seconds\n\nBest result:\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.9055917521931005, calc time: 1.415461778640747 secs\n\n\n\n\ndef distribute_elements(n, t):\n    quotient, remainder = divmod(t, n-1)\n    elements = np.zeros(t)\n    for i in range(n-1):\n        elements[i * quotient] = 1\n    elements[0] = elements[0] + 1\n    return elements\n  \n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 20 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 24 # number of intervals\nN = 9 # number of patients\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = distribute_elements(N, T)\nsim = sim.astype(int) # initial schedule\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\n\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 300\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 9 patients and 24 timeslots.\nGenerated new psm\n\nschedule: [2 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0],\niats: [ 0  0 30 30 30 30 30 30 30],\niats_diff: [ 0 30  0  0  0  0  0  0],\nloss = 5.111365423197207, calc time: 1.3931331634521484 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1] with loss: 4.48770271803563\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 30 30 20],\niats_diff: [ 30   0   0   0   0   0   0 -10],\nloss = 4.48770271803563, calc time: 1.4854331016540527 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 2],\niats: [30 30 30 30 30 30 30 20  0],\niats_diff: [  0   0   0   0   0   0 -10 -20],\nloss = 12.141353912413486, calc time: 1.4279968738555908 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 20 40 30 30 30 30 30 20],\niats_diff: [ 20  20 -10   0   0   0   0 -10],\nloss = 4.559601670747488, calc time: 1.453721284866333 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 20 40 30 30 30 30 20],\niats_diff: [ 30 -10  20 -10   0   0   0 -10],\nloss = 4.5620879069965765, calc time: 1.4302659034729004 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 20 40 30 30 30 20],\niats_diff: [ 30   0 -10  20 -10   0   0 -10],\nloss = 4.561660253907695, calc time: 1.444411039352417 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 20 40 30 30 20],\niats_diff: [ 30   0   0 -10  20 -10   0 -10],\nloss = 4.5617726777574905, calc time: 1.4556450843811035 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 20 40 30 20],\niats_diff: [ 30   0   0   0 -10  20 -10 -10],\nloss = 4.560592286688616, calc time: 1.4704289436340332 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 20 40 20],\niats_diff: [ 30   0   0   0   0 -10  20 -20],\nloss = 4.54338261572322, calc time: 1.436629056930542 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1] with loss: 4.011361274952312\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 30 20 30],\niats_diff: [ 30   0   0   0   0   0 -10  10],\nloss = 4.011361274952312, calc time: 1.4831538200378418 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 2],\niats: [30 30 30 30 30 30 20 30  0],\niats_diff: [  0   0   0   0   0 -10  10 -30],\nloss = 11.490910590011314, calc time: 1.4409878253936768 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 30 20 30],\niats_diff: [ 20  20 -10   0   0   0 -10  10],\nloss = 4.083256616148585, calc time: 1.4605350494384766 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 30 20 30],\niats_diff: [ 30 -10  20 -10   0   0 -10  10],\nloss = 4.085741987091337, calc time: 1.4739480018615723 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 30 20 30],\niats_diff: [ 30   0 -10  20 -10   0 -10  10],\nloss = 4.08528469602395, calc time: 1.5216360092163086 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 30 20 30],\niats_diff: [ 30   0   0 -10  20 -10 -10  10],\nloss = 4.085127046476551, calc time: 1.477220058441162 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 40 20 30],\niats_diff: [ 30   0   0   0 -10  20 -20  10],\nloss = 4.080508832852727, calc time: 1.3806819915771484 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1] with loss: 3.9569817582428897\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 20 30 30],\niats_diff: [ 30   0   0   0   0 -10  10   0],\nloss = 3.9569817582428897, calc time: 1.464540958404541 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 30 20 30 30  0],\niats_diff: [  0   0   0   0 -10  10   0 -30],\nloss = 11.417440932631349, calc time: 1.3919658660888672 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 20 30 30],\niats_diff: [ 20  20 -10   0   0 -10  10   0],\nloss = 4.028872829172919, calc time: 1.4548132419586182 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 20 30 30],\niats_diff: [ 30 -10  20 -10   0 -10  10   0],\nloss = 4.031346919443826, calc time: 1.476125955581665 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 20 30 30],\niats_diff: [ 30   0 -10  20 -10 -10  10   0],\nloss = 4.030722510099247, calc time: 1.4342689514160156 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 20 30 30],\niats_diff: [ 30   0   0 -10  20 -20  10   0],\nloss = 4.028356931304926, calc time: 1.3608179092407227 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.950379529193648\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 30 30 30],\niats_diff: [ 30   0   0   0 -10  10   0   0],\nloss = 3.950379529193648, calc time: 1.4953880310058594 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 20 30 30 30  0],\niats_diff: [  0   0   0 -10  10   0   0 -30],\nloss = 11.407363743693754, calc time: 1.5093019008636475 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 20 30 30 30],\niats_diff: [ 20  20 -10   0 -10  10   0   0],\nloss = 4.0222417445774665, calc time: 1.4633259773254395 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 20 30 30 30],\niats_diff: [ 30 -10  20 -10 -10  10   0   0],\nloss = 4.024543500947197, calc time: 1.4400970935821533 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 20 30 30 30],\niats_diff: [ 30   0 -10  20 -20  10   0   0],\nloss = 4.02181693951677, calc time: 1.4632339477539062 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9493347741537934\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9493347741537934, calc time: 1.4748728275299072 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.405344567043917, calc time: 1.4387829303741455 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.020960361332397, calc time: 1.4758663177490234 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.021401702392241, calc time: 1.4672372341156006 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9486406699245977\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9486406699245977, calc time: 1.631403923034668 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.40496779498912, calc time: 1.4027981758117676 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.018045402799398, calc time: 1.4873108863830566 secs\n\n\n#### Found better schedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9483942146808135\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9483942146808135, calc time: 1.4490759372711182 secs\n\nschedule: [0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 20 30 30 30 30 30 30  0],\niats_diff: [-10  10   0   0   0   0   0 -30],\nloss = 11.40241097156638, calc time: 1.464655876159668 secs\n\n\n#### Found better schedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.945854934243833\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.4396419525146484 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4239859580993652 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.3959932327270508 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.4007580280303955 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.3682589530944824 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4772858619689941 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.462589979171753 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.5417301654815674 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.475113868713379 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.462280035018921 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.4773879051208496 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.48136305809021 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.4367389678955078 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.4680540561676025 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.4568488597869873 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4013481140136719 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.519071102142334 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.544999122619629 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.5631721019744873 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4732701778411865 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.483572244644165 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4904639720916748 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.5377049446105957 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.8403801918029785 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.5249741077423096 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4450139999389648 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.5074961185455322 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.5300929546356201 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.4069740772247314 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4602282047271729 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.433011770248413 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4008431434631348 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.4926362037658691 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.521899700164795 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.495542049407959 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.45011305809021 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.4087018966674805 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.416942834854126 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.3699488639831543 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4063379764556885 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.5371301174163818 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4951581954956055 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.6190361976623535 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.5357210636138916 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.5752861499786377 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4372150897979736 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.5312581062316895 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.4903349876403809 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.4551763534545898 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4289851188659668 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.456406831741333 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4222190380096436 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.4150240421295166 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.4550769329071045 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.4980409145355225 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4981181621551514 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.4417850971221924 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.4492442607879639 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.4764187335968018 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4259881973266602 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.5316979885101318 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4561800956726074 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.4170920848846436 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.459670066833496 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.452697992324829 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4929862022399902 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.5132999420166016 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.444859266281128 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.4085590839385986 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.7017080783843994 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.495439052581787 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.3499038219451904 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.3768701553344727 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.4576680660247803 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.475006103515625 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4497990608215332 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.4611551761627197 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.5117087364196777 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.4206578731536865 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4514601230621338 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.527799129486084 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4689102172851562 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.3566887378692627 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.3674061298370361 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.3616750240325928 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.360969066619873 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.3238778114318848 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.364927053451538 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.3708031177520752 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.3579871654510498 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.3782968521118164 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.3784661293029785 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.366718053817749 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.3479259014129639 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.3575007915496826 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.3626351356506348 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.388279914855957 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.3538310527801514 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.4695541858673096 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4638237953186035 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.4187729358673096 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.3964030742645264 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.4035449028015137 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.3509092330932617 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.3843050003051758 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.3644239902496338 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.4444239139556885 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.4243249893188477 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.444033145904541 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4737000465393066 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.439493179321289 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4203500747680664 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.4911119937896729 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.4330642223358154 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.394212007522583 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.3395929336547852 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.3447551727294922 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.3962609767913818 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.349410057067871 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4366099834442139 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.3403370380401611 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.3211758136749268 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.3562591075897217 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.377946138381958 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.3899908065795898 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.449704885482788 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.4212815761566162 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.4259777069091797 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.5151429176330566 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.437619924545288 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.4300189018249512 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.405419111251831 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.42628812789917 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.445836067199707 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.4260878562927246 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.5074491500854492 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.5592877864837646 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.4242491722106934 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.5477399826049805 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.6559381484985352 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.614232063293457 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4646341800689697 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.6809229850769043 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.6639585494995117 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.500473976135254 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4567182064056396 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.4526300430297852 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.4447379112243652 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.614645004272461 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4863028526306152 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.4274792671203613 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.4109890460968018 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.4899089336395264 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.5864739418029785 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.7386500835418701 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.4871628284454346 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.3991148471832275 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.3701097965240479 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.371476173400879 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.4233720302581787 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.3468639850616455 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.315051044379643, calc time: 1.341817855834961 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.280666650950687, calc time: 1.3552279472351074 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.053772415618152, calc time: 1.3534207344055176 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.023557388224981, calc time: 1.3830549716949463 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.02069855874274, calc time: 1.3575751781463623 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.020003286877207, calc time: 1.3504109382629395 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.017101516173905, calc time: 1.3495192527770996 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9870161115488063, calc time: 1.3612148761749268 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.575062645222366, calc time: 1.37391996383667 secs\n\nFinished iterating in: 310 seconds\n\nBest result:\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.945854934243833, calc time: 1.470386028289795 secs"
  }
]