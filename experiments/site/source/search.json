[
  {
    "objectID": "scratchpad.html",
    "href": "scratchpad.html",
    "title": "scratchpad",
    "section": "",
    "text": "import numpy as np\nimport functions as fn\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\n\nem = np.random.poisson(0.5, 12).astype(int)\nem_stsm = [np.random.lognormal(mean = nm, sigma=ns, size=i).sum() for i in em]\nprint(f'em: {em}, em_stsm: {em_stsm}')\n\nem: [0 0 1 0 0 1 0 0 0 1 0 1], em_stsm: [0.0, 0.0, 12.737638151130252, 0.0, 0.0, 19.426006901467744, 0.0, 0.0, 0.0, 15.609601772462709, 0.0, 13.285353977757865]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Experiments",
    "section": "",
    "text": "This site contains the code experiments for my research on appointment scheduling optimization. Specifically I am working on solution methods for single stage stochastic programming problems (1-SSP) and so-called off-line scheduling system. In an off-line scheduling system all patients that want an appointment in a specific time-frame (e.g. day) are gathered first and then given an appointment time. An example of such a problem is scheduling a number of patients into a series of fixed time slots for a single physician. Each patient will have a certain service time that can not be predicted, but has some known distribution with a mean and variance. If a certain patient needs more time to consult than his time slot the next patient will start later. In case the patient finishes earlier, the doctor has idle time.\nBoth waiting times - for patient and doctor - are undesirable. The question is how to find an optimal schedule that minimizes total waiting times. Weights can be given to both types of waiting times to accommodate for different utilities of saved time for patients and doctors.\nSolution methods for these kinds of problems can be divided into two types: (1) analytical and (2) numerical. Analytical methods applies mathematical principles to a problem in order to obtain provable results. Numerical methods use sets of iterative procedures to find solutions to problems that are hard to solve by analytical methods. A numerical method is considered accurate if it finds: (1) an optimal solution in a given time or (2) a perturbed (or near-optimal) solution with a known deterministic error bound, which is a bound on the solution’s (relative or absolute) optimality gap. An inaccurate method does not produce an error bound and the quality of the solution can not be determined (Ahmadi-Javid, Jalali, and Klassen 2017).\nIdeas:\n\nApply utility function to waiting times -&gt; one minute of waiting is more acceptable than 30 minutes of waiting.\n\n\n\n\n\n\nReferences\n\nAhmadi-Javid, Amir, Zahra Jalali, and Kenneth J Klassen. 2017. “Outpatient Appointment Systems in Healthcare: A Review of Optimization Studies.” European Journal of Operational Research 258 (1): 3–34. https://doi.org/10.1016/j.ejor.2016.06.064."
  },
  {
    "objectID": "sched-sim.html",
    "href": "sched-sim.html",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#setup",
    "href": "sched-sim.html#setup",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#run-simulation-1",
    "href": "sched-sim.html#run-simulation-1",
    "title": "Scheduling Simulation",
    "section": "Run simulation 1",
    "text": "Run simulation 1\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14 \nlns = 5\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], dtype=object) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time= {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time= 3.1430558496290533')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-2",
    "href": "sched-sim.html#run-simulation-2",
    "title": "Scheduling Simulation",
    "section": "Run simulation 2",
    "text": "Run simulation 2\n\nConfigure parameters.\n\n# Configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving silnmlation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n\nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times.\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 11.244390256815297')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-3",
    "href": "sched-sim.html#run-simulation-3",
    "title": "Scheduling Simulation",
    "section": "Run simulation 3",
    "text": "Run simulation 3\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 0, 0, 60, 0, 0, 0, 60, 0, 0, 0]) # inter-arrival times\n\nnsims = nsims # number of simulations\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 22.853160728847385')]"
  },
  {
    "objectID": "schedule-probabilities.html",
    "href": "schedule-probabilities.html",
    "title": "Scheduling Local Search",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \ndef weak_compositions(n, k):\n    if k == 1:\n        return [[n]]\n    compositions = []\n    for i in range(n + 1):\n        for composition in weak_compositions(n - i, k - 1):\n            compositions.append([i] + composition)\n    return compositions\n  \nprint(f'Weak compositions are: {weak_compositions(2, 4)}')\n\n\nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n        \nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\nWeak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times.\nNB: Suggestie Joost - \\(p_N := \\sum_{i=N}^\\infty p_i\\)\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s):\n            # Initialize the parameters dictionary with x, d, and s.\n            self.parameters = dict({'x': x, 'd': d, 's': s})\n            # Initialize the system dictionary with p_min and v.\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        \n    def calculate_system_states(self, until = 1):\n            \"\"\"Set state to the interval from which to start (re-)calculating waiting time distributions.\n                \"\"\"\n            \n            while self.state &lt; until:\n                \n                \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n                \n                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n                \n                \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n                \n                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n                \n                \"\"\"Service time distribution are calculated as n times convolutions, where n is the number of clients scheduled. The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                # self.system['v'][self.state] = convolve_n(self.parameters['s'].copy(), self.parameters['x'][self.state])[:(len(self.parameters['s']))]\n                \n                \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n                The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n                of waiting times of the first patient in state t and the service time distribution. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                     for i in range(1, self.parameters['x'][self.state]):\n                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n\n                \n                \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n                the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n                Unless there are no patients in the state t. In that case the distributio of total work just before t ends is equal \n                to the distribution of work at the beginning of t. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                \"\"\"Jump to next state\"\"\"\n                self.state += 1\n    \n    def impute_compositions(self, i=1, k=1):\n      self.state = i\n      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end.\n      j = min(len(self.parameters['x']), i+k)\n      k = j - i\n      c = self.parameters['x'][i:j]\n      n = c.sum()\n      # Generate compositions\n      compositions = weak_compositions(n, k)\n      for comp in compositions:\n        self.parameters['x'][i:j] = comp.copy()\n        self.state = i\n        self.calculate_system_states()\n        print(self.parameters['x'])\n        \n    \n    def calculate_wait_times(self):\n    # Initialize time counter\n      t = 0\n      # Calculate the expected waiting time for each time step\n      for t, w in enumerate(self.system['w']):\n          ew = 0\n          for i in w:\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(i))\n              b = i\n              wt = np.dot(a, b)\n              ew += wt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][t] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n         \n         values = self.system[dist]\n         trace = go.Heatmap(\n                    z=values,\n                    text=np.around(values, 2),\n                    texttemplate=\"%{text}\",\n                    textfont={\"size\":10}\n                    )\n         data = [trace]\n\n         layout = go.Layout(\n            title=f'{dist}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n         fig = go.Figure(data=data, layout=layout)\n         pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThe code above defines a Schedule class that is used to calculate the probability distributions of the amount of work in a system at different states. The class has a constructor that takes three parameters x, d, and s, which represent the number of clients scheduled, the interval length, and the service time distribution, respectively.\nThe constructor initializes the parameters dictionary with the input parameters, and the system dictionary with two NumPy arrays p_min and p_plus. The p_min array represents the probability distribution of the amount of work in the system just before a state starts, and the p_plus array represents the probability distribution of the total amount of work in the system until a state ends. The constructor also initializes the state variable to 0, and sets the first element of p_min in the initial state to 1. Additionally, the constructor initializes an array of arrays for saving waiting times distributions per patient, w, and an array for saving total expected waiting times per state, ew.\nThe Schedule class has two methods calculate_system_states and calculate_wait_times. The calculate_system_states method calculates the probability distributions of the amount of work in the system at different states. The method uses a while loop to iterate over the states, starting from state 1. For each state, the method calculates the probability distribution of the amount of work in the system just before the state starts (p_min), and the probability distribution of the amount of work in the system just after the state ends (p_plus). The method also calculates the waiting time distribution of the patients in the state (w). The calculate_wait_times method calculates the expected waiting time for each time step.\nThe Schedule class also has a visualize_p_plus method that visualizes the p_plus array in the last calculated state. The method uses the Plotly library to create a scatter plot of the p_plus array.\nFinally, the Schedule class has a __str__ method that returns a string representation of the p_min, w, p_plus, and ew arrays.\nTo improve the readability of the code, the Schedule class could be refactored to use more descriptive variable names. Additionally, the calculate_system_states method could be split into smaller methods to improve its readability and maintainability. Finally, the visualize_p_plus method could be modified to take a state parameter, allowing the user to visualize the p_plus array for any state.\n\ndef run_schedule(x, d, s, u=1, print_system=True):\n  schedule = Schedule(x=x, d=d, s=s)\n  schedule.calculate_system_states(until=u)\n  schedule.calculate_wait_times()\n  if(print_system): print(schedule)\n  print(f\"Expected wt per state: {schedule.system['ew']}\")\n  # schedule.impute_compositions(i=1, k=3)\n  return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nu = 4\nsch = run_schedule(x, d, s, u, False)\nsch.visualize_system('p_min')\n\nExpected wt per state: [2.25       0.         7.4399125  3.97027875 0.        ]\n\n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = 1\n  \nsch = run_schedule(x, d, s, u, True)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\np_min = [[1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0.]\n [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.\n  0. 0. 0. 0. 0.]] \nw = [[array([1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])], [array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n       0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])]] \np_plus = [[2.47875218e-03 1.48725131e-02 4.46175392e-02 8.92350784e-02\n  1.33852618e-01 1.60623141e-01 1.60623141e-01 1.37676978e-01\n  1.03257734e-01 6.88384890e-02 4.13030934e-02 2.25289600e-02\n  1.12644800e-02 5.19899078e-03 2.22813891e-03 8.91255562e-04\n  3.34220836e-04 1.17960295e-04 3.93200983e-05 1.24168732e-05\n  3.72506195e-06 1.06430341e-06 2.90264567e-07 7.57211915e-08\n  1.89302979e-08 4.54327149e-09 1.04844727e-09 2.32988281e-10\n  4.99260603e-11 1.03295297e-11 2.06590594e-12 3.99852763e-13\n  7.49723931e-14 1.36313442e-14 2.40553133e-15 4.12376799e-16\n  6.87294666e-17 1.11453189e-17 1.75978720e-18 2.70736492e-19\n  4.06104737e-20 5.94299616e-21 8.48999451e-22 1.18465040e-22\n  1.61543236e-23 2.15390981e-24 2.80944758e-25 3.58652883e-26\n  4.48316103e-27 5.48958494e-28 6.58750193e-29 7.75000227e-30\n  8.94231031e-31 1.01233702e-31 1.12481891e-32 1.22707517e-33\n  1.31472340e-34 1.38391937e-35 1.43164072e-36 1.45590582e-37\n  1.45590582e-38 1.43203851e-39 1.38584372e-40 1.31985116e-41\n  1.23736047e-42 1.14217889e-43 1.03834445e-44 9.29860698e-46\n  8.20465322e-47 7.13448106e-48 6.11526948e-49 5.16783336e-50\n  4.30652780e-51 3.53961189e-52 2.86995559e-53 2.29596447e-54\n  1.81260353e-55 1.41241833e-56 1.08647564e-57 8.25171374e-59\n  6.18878530e-60 4.58428541e-61 3.35435518e-62 2.42483507e-63\n  1.73202505e-64 1.22260592e-65 8.52980872e-67 5.88262671e-68\n  4.01088184e-69 2.70396529e-70 1.80264353e-71 1.18855617e-72\n  7.75145329e-74 5.00093760e-75 3.19208783e-76 2.01605547e-77\n  1.26003467e-78 7.79402889e-80 4.77185442e-81 2.89203298e-82\n  1.73521979e-83]\n [0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00\n  0.00000000e+00]] \new = [0. 0.]\nExpected wt per state: [0. 0.]\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = 4\n  \nsch = run_schedule(x, d, s, u, False)\n\nExpected wt per state: [0.         0.         6.15466973 0.         0.         0.\n 0.        ]\n\n\n\nsch.visualize_state(2)\n\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n\n                                                \n\n\n\nT = 24 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2 \nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T-1\nsch = run_schedule(x, d, s, u, False)\nsch.visualize_system('p_plus')\n\nInitial schedule: [2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1]\nExpected wt per state: [20.          0.         20.0003139   0.         20.00654104  0.\n 20.02974938  0.         20.07680883  0.         20.14909919  0.\n 20.24496897  0.         20.36160607  0.         20.49598958  0.\n 20.64529634  0.         20.8070411   0.         20.97909812  0.        ]\n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "sim-based-opt.html",
    "href": "sim-based-opt.html",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#setup",
    "href": "sim-based-opt.html#setup",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#run-simulations",
    "href": "sim-based-opt.html#run-simulations",
    "title": "Simulation Based Optimization",
    "section": "Run simulations",
    "text": "Run simulations\n\n# Simulation 1\n\ntic = time.time()\nsim = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nN = len(iats) # number of patients\n# T = len(sim) # number of intervals\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimreswt = []\nsimresln = 0\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = loss = 0.5 * mwt + 0.5 * mln\ntoc = time.time()\nprint(toc - tic)\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\n1.7743349075317383\n\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 1 1 1 1 1 1 1], mwt: 1.6202733334913653, mln: 1.9842411444960788, loss: 1.8022572389937221')\n\n\n\n\n\n\n\n\n\n# Simulation 2\n\nsim = np.array([2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [2 0 1 1 1 1 1 1 1 1 1 1], mwt: 2.20522509214409, mln: 1.980846286241098, loss: 2.093035689192594')\n\n\n\n\n\n\n\n\n\n# Simulation 3\n\nsim = np.array([1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 2 0 1 1 1 1 1 1 1], mwt: 2.2908353530876546, mln: 1.9736885363627914, loss: 2.132261944725223')\n\n\n\n\n\n\n\n\n\n# Simulation 4\n\nsim = np.array([1, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 2 0 1 1 1 1 1], mwt: 2.304122124864343, mln: 1.9588201184544953, loss: 2.131471121659419')"
  },
  {
    "objectID": "search-function.html",
    "href": "search-function.html",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#setup",
    "href": "search-function.html#setup",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#run-simulations-and-search",
    "href": "search-function.html#run-simulations-and-search",
    "title": "Search Function",
    "section": "Run simulations and search",
    "text": "Run simulations and search\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 30\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 8 patients and 12 timeslots.\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 20 20 20 20 20 10],\niats_diff: [  0  20   0   0   0   0 -10],\nloss = 3.6637530352843077, calc time: 1.3953261375427246 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 20 20 20 20 20 10  0],\niats_diff: [ 20   0   0   0   0 -10 -10],\nloss = 7.26550463743135, calc time: 1.387389898300171 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 10 30 20 20 20 10],\niats_diff: [  0  10  20 -10   0   0 -10],\nloss = 4.023301674498725, calc time: 1.3934667110443115 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 20 10 30 20 20 10],\niats_diff: [  0  20 -10  20 -10   0 -10],\nloss = 3.8946593736549184, calc time: 1.4504950046539307 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 20 20 10 30 20 10],\niats_diff: [  0  20   0 -10  20 -10 -10],\nloss = 3.831456915900775, calc time: 1.431230068206787 secs\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 20 20 20 10 30 10],\niats_diff: [  0  20   0   0 -10  20 -20],\nloss = 3.7673135407772285, calc time: 1.491117000579834 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 0 1 1 0 1] with loss: 3.047993432790925\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 20 20 20 20 10 20],\niats_diff: [  0  20   0   0   0 -10  10],\nloss = 3.047993432790925, calc time: 1.4093899726867676 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 1 0 2],\niats: [ 0 20 20 20 20 10 20  0],\niats_diff: [ 20   0   0   0 -10  10 -20],\nloss = 6.301083695035809, calc time: 1.5181400775909424 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 10 30 20 20 10 20],\niats_diff: [  0  10  20 -10   0 -10  10],\nloss = 3.407103400838696, calc time: 1.3633270263671875 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 1 0 1],\niats: [ 0  0 20 10 30 20 10 20],\niats_diff: [  0  20 -10  20 -10 -10  10],\nloss = 3.276324837353913, calc time: 1.368056058883667 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 1 0 1],\niats: [ 0  0 20 20 10 30 10 20],\niats_diff: [  0  20   0 -10  20 -20  10],\nloss = 3.201327768991583, calc time: 1.344383955001831 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 1 0 1 0 1] with loss: 2.9060852531221455\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 20 20 20 10 20 20],\niats_diff: [  0  20   0   0 -10  10   0],\nloss = 2.9060852531221455, calc time: 1.3838870525360107 secs\n\nschedule: [1 0 1 0 1 0 1 1 0 1 0 2],\niats: [ 0 20 20 20 10 20 20  0],\niats_diff: [ 20   0   0 -10  10   0 -20],\nloss = 6.063715080686039, calc time: 1.326279878616333 secs\n\nschedule: [2 1 0 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 10 30 20 10 20 20],\niats_diff: [  0  10  20 -10 -10  10   0],\nloss = 3.264166739190493, calc time: 1.3265259265899658 secs\n\nschedule: [2 0 1 1 0 0 1 1 0 1 0 1],\niats: [ 0  0 20 10 30 10 20 20],\niats_diff: [  0  20 -10  20 -20  10   0],\nloss = 3.1259259760258624, calc time: 1.3423984050750732 secs\n\n\n#### Found better schedule: [2 0 1 0 1 1 0 1 0 1 0 1] with loss: 2.900151376873269\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.900151376873269, calc time: 1.3242180347442627 secs\n\nschedule: [1 0 1 0 1 1 0 1 0 1 0 2],\niats: [ 0 20 20 10 20 20 20  0],\niats_diff: [ 20   0 -10  10   0   0 -20],\nloss = 5.996040377353448, calc time: 1.319566011428833 secs\n\nschedule: [2 1 0 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 10 30 10 20 20 20],\niats_diff: [  0  10  20 -20  10   0   0],\nloss = 3.2533302858290933, calc time: 1.334787130355835 secs\n\nschedule: [2 0 1 1 0 1 0 1 0 1 0 1],\niats: [ 0  0 20 10 20 20 20 20],\niats_diff: [  0  20 -10  10   0   0   0],\nloss = 2.9950812866799263, calc time: 1.3306829929351807 secs\n\nschedule: [2 0 1 0 2 0 0 1 0 1 0 1],\niats: [ 0  0 20 20  0 30 20 20],\niats_diff: [  0  20   0 -20  30 -10   0],\nloss = 3.3128500527146185, calc time: 1.3222758769989014 secs\n\nschedule: [2 0 1 0 1 1 1 0 0 1 0 1],\niats: [ 0  0 20 20 10 10 30 20],\niats_diff: [  0  20   0 -10   0  20 -10],\nloss = 3.1300279281732655, calc time: 1.3306190967559814 secs\n\nschedule: [2 0 1 0 1 1 0 1 1 0 0 1],\niats: [ 0  0 20 20 10 20 10 30],\niats_diff: [  0  20   0 -10  10 -10  20],\nloss = 3.0136483156362788, calc time: 1.4050579071044922 secs\n\nschedule: [2 0 1 0 1 1 0 1 0 1 1 0],\niats: [ 0  0 20 20 10 20 20 10],\niats_diff: [  0  20   0 -10  10   0 -10],\nloss = 4.0419166882816775, calc time: 1.3106930255889893 secs\n\nFinished iterating in: 35 seconds\n\nBest result:\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.900151376873269, calc time: 1.3271338939666748 secs\n\n\n\n\ndef distribute_elements(n, t):\n    quotient, remainder = divmod(t, n-1)\n    elements = np.zeros(t)\n    for i in range(n-1):\n        elements[i * quotient] = 1\n    elements[0] = elements[0] + 1\n    return elements\n  \n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 20 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 24 # number of intervals\nN = 9 # number of patients\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = distribute_elements(N, T)\nsim = sim.astype(int) # initial schedule\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\n\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 300\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 9 patients and 24 timeslots.\nGenerated new psm\n\nschedule: [2 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0],\niats: [ 0  0 30 30 30 30 30 30 30],\niats_diff: [ 0 30  0  0  0  0  0  0],\nloss = 5.1107385616214485, calc time: 1.4306910037994385 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1] with loss: 4.4907999451859135\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 30 30 20],\niats_diff: [ 30   0   0   0   0   0   0 -10],\nloss = 4.4907999451859135, calc time: 1.4037771224975586 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 2],\niats: [30 30 30 30 30 30 30 20  0],\niats_diff: [  0   0   0   0   0   0 -10 -20],\nloss = 12.163914175871449, calc time: 1.3815243244171143 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 20 40 30 30 30 30 30 20],\niats_diff: [ 20  20 -10   0   0   0   0 -10],\nloss = 4.562459936468603, calc time: 1.3903801441192627 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 20 40 30 30 30 30 20],\niats_diff: [ 30 -10  20 -10   0   0   0 -10],\nloss = 4.56485516017813, calc time: 1.3937079906463623 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 20 40 30 30 30 20],\niats_diff: [ 30   0 -10  20 -10   0   0 -10],\nloss = 4.563955213923492, calc time: 1.3913800716400146 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 20 40 30 30 20],\niats_diff: [ 30   0   0 -10  20 -10   0 -10],\nloss = 4.564412655392683, calc time: 1.4011917114257812 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 20 40 30 20],\niats_diff: [ 30   0   0   0 -10  20 -10 -10],\nloss = 4.563746840507218, calc time: 1.3900337219238281 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 20 40 20],\niats_diff: [ 30   0   0   0   0 -10  20 -20],\nloss = 4.544848585824591, calc time: 1.4352192878723145 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1] with loss: 4.01556359256188\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 30 20 30],\niats_diff: [ 30   0   0   0   0   0 -10  10],\nloss = 4.01556359256188, calc time: 1.396988868713379 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 2],\niats: [30 30 30 30 30 30 20 30  0],\niats_diff: [  0   0   0   0   0 -10  10 -30],\nloss = 11.510353086078503, calc time: 1.3669891357421875 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 30 20 30],\niats_diff: [ 20  20 -10   0   0   0 -10  10],\nloss = 4.087223242686264, calc time: 1.3990638256072998 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 30 20 30],\niats_diff: [ 30 -10  20 -10   0   0 -10  10],\nloss = 4.089616898419505, calc time: 1.4045822620391846 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 30 20 30],\niats_diff: [ 30   0 -10  20 -10   0 -10  10],\nloss = 4.088584592839334, calc time: 1.4026579856872559 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 30 20 30],\niats_diff: [ 30   0   0 -10  20 -10 -10  10],\nloss = 4.088809762191252, calc time: 1.414219856262207 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 40 20 30],\niats_diff: [ 30   0   0   0 -10  20 -20  10],\nloss = 4.0850172726944285, calc time: 1.391068935394287 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1] with loss: 3.9588553165505815\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 20 30 30],\niats_diff: [ 30   0   0   0   0 -10  10   0],\nloss = 3.9588553165505815, calc time: 1.412320852279663 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 30 20 30 30  0],\niats_diff: [  0   0   0   0 -10  10   0 -30],\nloss = 11.438995602910648, calc time: 1.4548087120056152 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 20 30 30],\niats_diff: [ 20  20 -10   0   0 -10  10   0],\nloss = 4.030509137376988, calc time: 1.461683988571167 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 20 30 30],\niats_diff: [ 30 -10  20 -10   0 -10  10   0],\nloss = 4.032886692969769, calc time: 1.4316301345825195 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 20 30 30],\niats_diff: [ 30   0 -10  20 -10 -10  10   0],\nloss = 4.031526123612429, calc time: 1.4305500984191895 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 20 30 30],\niats_diff: [ 30   0   0 -10  20 -20  10   0],\nloss = 4.02953943451847, calc time: 1.40437912940979 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.953595718291066\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 30 30 30],\niats_diff: [ 30   0   0   0 -10  10   0   0],\nloss = 3.953595718291066, calc time: 1.4033191204071045 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 20 30 30 30  0],\niats_diff: [  0   0   0 -10  10   0   0 -30],\nloss = 11.428615998589006, calc time: 1.3751940727233887 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 20 30 30 30],\niats_diff: [ 20  20 -10   0 -10  10   0   0],\nloss = 4.025222625574921, calc time: 1.3991990089416504 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 20 30 30 30],\niats_diff: [ 30 -10  20 -10 -10  10   0   0],\nloss = 4.027480003215937, calc time: 1.4093141555786133 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 20 30 30 30],\niats_diff: [ 30   0 -10  20 -20  10   0   0],\nloss = 4.023908747975138, calc time: 1.443800926208496 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.951785642198639\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.951785642198639, calc time: 1.392164945602417 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.425906627396456, calc time: 1.3896141052246094 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.023179482020513, calc time: 1.4092669486999512 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.023600273024683, calc time: 1.4107880592346191 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9505861025935505\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.3971140384674072 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.405630111694336 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.5432801246643066 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4494011402130127 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.445620059967041 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4271302223205566 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4302639961242676 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4217450618743896 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4259979724884033 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4546198844909668 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.458786964416504 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4250779151916504 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.441537857055664 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4217426776885986 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.424651861190796 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4207687377929688 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.414269208908081 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.3936359882354736 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4820291996002197 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4419331550598145 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.5189268589019775 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4287731647491455 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4075391292572021 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4012417793273926 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.4066109657287598 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4525790214538574 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4323749542236328 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4353117942810059 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4047040939331055 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4011600017547607 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4290921688079834 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4145832061767578 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4029860496520996 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.400465965270996 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.3964481353759766 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4286649227142334 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4281811714172363 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.407444953918457 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.40618896484375 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.398681879043579 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4241580963134766 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.3967978954315186 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.3922739028930664 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4000000953674316 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.3876402378082275 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.394869089126587 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4735889434814453 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4117650985717773 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4206161499023438 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4201889038085938 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.3976259231567383 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.385303020477295 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.406282901763916 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4100217819213867 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.3806841373443604 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.3996009826660156 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4302542209625244 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.3999481201171875 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4072198867797852 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4055490493774414 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4090080261230469 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4629828929901123 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.460144281387329 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4201312065124512 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.4185068607330322 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.3932769298553467 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.394031047821045 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4584112167358398 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4250481128692627 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.417099952697754 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4415690898895264 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4257638454437256 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4080989360809326 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4939351081848145 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.393244981765747 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.3929443359375 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.400137186050415 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4161992073059082 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.409966230392456 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.399491786956787 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4098820686340332 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.3760490417480469 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4016931056976318 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.3986010551452637 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.4021539688110352 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.433610200881958 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4062509536743164 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4005091190338135 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4519128799438477 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4041469097137451 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4067378044128418 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4143688678741455 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4056260585784912 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.418459177017212 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.3896350860595703 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4054126739501953 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.3884599208831787 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.3940160274505615 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4019148349761963 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4415321350097656 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.3921799659729004 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.382929801940918 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.400317907333374 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4054839611053467 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.3763809204101562 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4041500091552734 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4135417938232422 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.405170202255249 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.4000110626220703 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.387239933013916 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4243249893188477 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4181909561157227 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4562532901763916 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.415679931640625 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.3947319984436035 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.3997838497161865 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4191827774047852 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4339730739593506 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.3993310928344727 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.3913860321044922 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4776949882507324 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.3755569458007812 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.3985600471496582 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4182727336883545 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.3829379081726074 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.3881251811981201 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.413266897201538 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4087989330291748 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.3925390243530273 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.463123083114624 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.5743722915649414 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4421908855438232 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4223580360412598 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.476977825164795 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.414801836013794 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4458231925964355 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4389371871948242 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.4087531566619873 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.3881709575653076 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.3860969543457031 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.413412094116211 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.450019121170044 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.404500961303711 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.414335012435913 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.394334077835083 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.3913400173187256 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.3930490016937256 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.394129753112793 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.3973338603973389 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.393561840057373 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.426342248916626 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4044501781463623 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4433777332305908 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4215941429138184 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.4099557399749756 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4367470741271973 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4018700122833252 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.3979949951171875 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.3861308097839355 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4073262214660645 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4336929321289062 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.4186067581176758 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4372150897979736 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4079601764678955 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.400120735168457 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4078049659729004 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.3983721733093262 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.3962187767028809 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.3973078727722168 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4098939895629883 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.3917100429534912 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.426145881487015, calc time: 1.3805768489837646 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.019829038526128, calc time: 1.4079978466033936 secs\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9510880831965753, calc time: 1.4869990348815918 secs\n\nschedule: [1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 10 40 30 30 30 30],\niats_diff: [ 30   0 -20  30 -10   0   0   0],\nloss = 4.284980092969181, calc time: 1.4145898818969727 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 20 40 30 30 30],\niats_diff: [ 30   0 -10   0  20 -10   0   0],\nloss = 4.058098908132912, calc time: 1.4128172397613525 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 20 40 30 30],\niats_diff: [ 30   0 -10  10 -10  20 -10   0],\nloss = 4.028654643467076, calc time: 1.4238641262054443 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 20 40 30],\niats_diff: [ 30   0 -10  10   0 -10  20 -10],\nloss = 4.0216708200709474, calc time: 1.404097080230713 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 20 30 30 30 20 40],\niats_diff: [ 30   0 -10  10   0   0 -10  20],\nloss = 3.9939245288414322, calc time: 1.405165195465088 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 20 30 30 30 30 20],\niats_diff: [ 30   0 -10  10   0   0   0 -10],\nloss = 4.580201854138626, calc time: 1.4239411354064941 secs\n\nFinished iterating in: 307 seconds\n\nBest result:\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9505861025935505, calc time: 1.4154598712921143 secs"
  }
]