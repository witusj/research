[
  {
    "objectID": "local-search-schedule-probabilities.html",
    "href": "local-search-schedule-probabilities.html",
    "title": "Scheduling w/ Local Search",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\nfrom itertools import chain, combinations\nimport copy\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \ndef weak_compositions(n, k):\n    if k == 1:\n        return [[n]]\n    compositions = []\n    for i in range(n + 1):\n        for composition in weak_compositions(n - i, k - 1):\n            compositions.append([i] + composition)\n    return compositions\n  \nprint(f'Weak compositions are: {weak_compositions(2, 4)}')\n\n\nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n        \nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)\n    \ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]\n  \ndef get_v_star(t):\n    # Create an initial vector 'u' of zeros with length 't'\n    u = np.zeros(t, dtype=np.int64)\n    # Set the first element of vector 'u' to -1\n    u[0] = -1\n    # Set the last element of vector 'u' to 1\n    u[-1] = 1\n    # Initialize the list 'v_star' with the initial vector 'u'\n    v_star = [u]\n    # Loop over the length of 'u' minus one times\n    for i in range(len(u) - 1):\n        # Append the last element of 'u' to the front of 'u'\n        u = np.append(u[-1], u)\n        # Remove the last element of 'u' to maintain the same length\n        u = np.delete(u, -1)\n        # Append the updated vector 'u' to the list 'v_star'\n        v_star.append(u)\n    # Convert the list of vectors 'v_star' into a NumPy array and return it\n    return(np.array(v_star))\n\n# Example of function call:\n# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row\n\ndef generate_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  logging.info(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}\n  # 'ids' will be a list of tuples, where each tuple is a subset of indices\n  ids = list(powerset(range(T)))\n\n  # Select the vectors from 'v_star' that correspond to the indices in each subset\n  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\n  sub_sets = [v_star[i] for i in ids]\n\n  # Sum the vectors within each subset and flatten the result to get a 1-D array\n  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\n  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n  \n  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  logging.info(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ndef generate_small_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  logging.info(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  neighborhood = np.array([schedule + v_star[i] for i in range(len(v_star))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  logging.info(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ndef distribute_patients(n_patients, n_timeslots):\n    # Create a list with all slots initially empty\n    distribution = [0] * n_timeslots\n\n    # Place patients in timeslots\n    for i in range(n_patients):\n        # Calculate the slot for each patient\n        slot = round(i * n_timeslots / n_patients)\n        distribution[slot] = 1\n\n    return distribution\n\ndef plot_timeline(slots, title):\n    # Create a figure\n    fig = go.Figure()\n\n    # Iterate over each timeslot and add a bar for occupied slots\n    for i, slot in enumerate(slots):\n        fig.add_trace(go.Bar(x=[i], y=[slot], width=0.8, marker_color='black'))\n\n    # Update layout\n    fig.update_layout(\n        title=title,\n        xaxis_title=\"Timeslots\",\n        yaxis=dict(showticklabels=False, showgrid=False, zeroline=False),\n        showlegend=False\n    )\n\n    # Set y-axis range\n    fig.update_yaxes(range=[0, np.max(slots)])\n\n    # Show the figure\n    fig.show()\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.002s\n\nOK\n\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\nWeak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for functions defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s):\n            \"\"\"\n            Initialize the class with a schedule of patients and a service time distribution.\n            \n            Args:\n            d (int): An integer representing the time lenght of an interval.\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            s (list): A list of floats representing the probability distribution of service times.\n            \"\"\"\n            \n            self.parameters = dict({'x': x, 'd': d, 's': s})\n            logging.info(f'{datetime.datetime.now()} - x = {self.parameters[\"x\"]}')\n            # Initialize the system dictionary with p_min and p_plus. p_min has one element extra for storing tardiness\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.print(self.system)\n            self.state = 1\n        \n    def calculate_system_states(self, until = 1):\n            \"\"\"\n            Calculate the probabilities of of work in system and waiting times in each state.\n            \n            Args:\n            until (int): An optional integer representing the state until which to calculate the probabilities.\n            \"\"\"\n            \n            while self.state &lt; until:\n                logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n                \n                \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n                \n                \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n                \n                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n                \n                \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n                The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n                of waiting times of the first patient in state t and the service time distribution. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                     logging.info(f'{datetime.datetime.now()} - Done')\n                     for i in range(1, self.parameters['x'][self.state]):\n                            logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n\n                \n                \"\"\"The probablitity that the amount of work in the system equals i just after state t starts equals \n                the convolution of the waiting time distribution of the last arriving patient in t-1 and the service time distribution. \n                Unless there are no patients in the state t. In that case the distribution of total work just after t started is equal \n                to the distribution of work left over from t-1. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                \"\"\"Jump to next state\"\"\"\n                self.state += 1\n  \n      \n    def local_search(self, omega=0.5):\n      \"\"\"\n      Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting stop searching.  \n      \"\"\"\n      # Calculate initial loss\n      test_wt = self.system[\"ew\"].sum()\n      self.calculate_tardiness()\n      indices = np.arange(self.system['p_min'][-1].size) \n      exp_tard = (indices * self.system['p_min'][-1]).sum()\n      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n    \n      # Continue the search until no improvement is found\n      while True:  # Start an outer loop that will continue until explicitly broken\n          nh = generate_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood\n          improved = False  # Flag to check if an improvement was found in the inner loop\n          \n          for y in nh:  # Inner loop to search through the neighborhood\n              # Insert first element of nh in x\n              self.parameters['x'] = y.copy()\n              logging.info(f\"Test schedule = {self.parameters['x']}\")\n              # Set starting state\n              self.state = 0\n              # If start state is 0 reinitialize p_min, w and p_plus in state 0\n              if(self.state == 0):\n                  self.system = dict({\n                      'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                      'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n                  })\n                  # Set the first element of p_min in the initial state to 1.\n                  self.system['p_min'][0][0] = 1\n                  # Initialize array of arrays for saving waiting times distributions per patient\n                  self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n                  if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                           self.system['w'][0][0] = self.system['p_min'][0].copy()\n                           for i in range(1, self.parameters['x'][0]):\n                                  self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                  self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                  # Initialize array for saving total expected waiting times per state\n                  self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n                  # Set the initial state to 1.\n                  self.state = 1\n              self.calculate_system_states(until=len(self.parameters['x']))\n              logging.info(\"System recalculated\")\n              self.calculate_wait_times()\n              test_wt = self.system[\"ew\"].sum()\n              logging.info(f\"Average waiting time={test_wt / self.parameters['x'].sum()}\")\n              self.calculate_tardiness()\n              indices = np.arange(self.system['p_min'][-1].size) \n              exp_tard = (indices * self.system['p_min'][-1]).sum()\n              logging.info(f'Expected tardiness={exp_tard}')\n              test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n              logging.info(f'obj_value = {test_loss}')\n              # If a schedule with a lower waiting time is found, store the system\n              if(test_loss &lt; lowest_loss):\n                lowest_loss = test_loss\n                store_optim['x'] = self.parameters['x'].copy()\n                newsystem = copy.deepcopy(self.system)\n                store_optim['system'] = newsystem\n                store_optim['tot_wt'] = test_wt\n                logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]}')\n                improved = True  # Set the flag because an improvement was found\n                break  # Exit the inner loop to generate a new neighborhood\n          \n          if not improved:  # If no improvement was found in the inner loop\n            logging.info(f'Finished searching')\n            # Set the system to the stored optimal system \n            logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n            self.parameters['x'] = store_optim['x'].copy()\n            self.system['p_min'] = store_optim['system']['p_min']\n            self.system['p_plus'] = store_optim['system']['p_plus']\n            self.system['w'] = store_optim['system']['w']\n            self.system['ew'] = store_optim['system']['ew']\n            break  # Exit the outer loop - the search is complete\n      \n    def small_local_search(self, omega=0.5):\n      \"\"\"\n      Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting stop searching.  \n      \"\"\"\n      # Calculate initial loss\n      test_wt = self.system[\"ew\"].sum()\n      self.calculate_tardiness()\n      indices = np.arange(self.system['p_min'][-1].size) \n      exp_tard = (indices * self.system['p_min'][-1]).sum()\n      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n    \n      # Continue the search until no improvement is found\n      while True:  # Start an outer loop that will continue until explicitly broken\n          nh = generate_small_search_neighborhood(self.parameters['x'])  # Generate a new neighborhood\n          improved = False  # Flag to check if an improvement was found in the inner loop\n          \n          for y in nh:  # Inner loop to search through the neighborhood\n              # Insert first element of nh in x\n              self.parameters['x'] = y.copy()\n              logging.info(f\"Test schedule = {self.parameters['x']}\")\n              # Set starting state\n              self.state = 0\n              # If start state is 0 reinitialize p_min, w and p_plus in state 0\n              if(self.state == 0):\n                  self.system = dict({\n                      'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                      'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n                  })\n                  # Set the first element of p_min in the initial state to 1.\n                  self.system['p_min'][0][0] = 1\n                  # Initialize array of arrays for saving waiting times distributions per patient\n                  self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n                  if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                           self.system['w'][0][0] = self.system['p_min'][0].copy()\n                           for i in range(1, self.parameters['x'][0]):\n                                  self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                  self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                  # Initialize array for saving total expected waiting times per state\n                  self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n                  # Set the initial state to 1.\n                  self.state = 1\n              self.calculate_system_states(until=len(self.parameters['x']))\n              logging.info(\"System recalculated\")\n              self.calculate_wait_times()\n              test_wt = self.system[\"ew\"].sum()\n              logging.info(f\"Average waiting time={test_wt / self.parameters['x'].sum()}\")\n              self.calculate_tardiness()\n              indices = np.arange(self.system['p_min'][-1].size) \n              exp_tard = (indices * self.system['p_min'][-1]).sum()\n              logging.info(f'Expected tardiness={exp_tard}')\n              test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n              logging.info(f'obj_value = {test_loss}')\n              # If a schedule with a lower waiting time is found, store the system\n              if(test_loss &lt; lowest_loss):\n                lowest_loss = test_loss\n                store_optim['x'] = self.parameters['x'].copy()\n                newsystem = copy.deepcopy(self.system)\n                store_optim['system'] = newsystem\n                store_optim['tot_wt'] = test_wt\n                logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]}')\n                improved = True  # Set the flag because an improvement was found\n                break  # Exit the inner loop to generate a new neighborhood\n          \n          if not improved:  # If no improvement was found in the inner loop\n            logging.info(f'Finished searching')\n            # Set the system to the stored optimal system \n            logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n            self.parameters['x'] = store_optim['x'].copy()\n            self.system['p_min'] = store_optim['system']['p_min']\n            self.system['p_plus'] = store_optim['system']['p_plus']\n            self.system['w'] = store_optim['system']['w']\n            self.system['ew'] = store_optim['system']['ew']\n            break  # Exit the outer loop - the search is complete\n          \n    def impute_compositions(self, s=0, k=2, omega=0.5):\n      \"\"\"\n      Impute the compositions of patients in a given time interval and establish the schedule with the lowest total waiting time.\n      \n      Args:\n      s (int): An integer representing the starting state.\n      k (int): An integer representing the number of states from the starting state to include in the compositions.\n      \"\"\"\n      logging.info(f'{datetime.datetime.now()} - Running impute_compositions() in state {self.state} with x = {self.parameters[\"x\"]}')\n      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end.\n      t = min(len(self.parameters['x']), s+k)\n      k = t - s\n      c = self.parameters['x'][s:t]\n      n = c.sum()\n      # Calculate initial loss\n      test_wt = self.system[\"ew\"].sum()\n      self.calculate_tardiness()\n      indices = np.arange(self.system['p_min'][-1].size) \n      exp_tard = (indices * self.system['p_min'][-1]).sum()\n      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n      # Generate compositions\n      compositions = weak_compositions(n, k)\n      logging.info(f'{datetime.datetime.now()} - Computing {len(compositions)} compositions')\n      # For all compositions calculate the waiting times\n      for comp in compositions:\n        # Insert composition in x\n        self.parameters['x'][s:t] = comp.copy()\n        # Set starting state\n        self.state = s\n        # Adjust the array for waiting time distributions to new x\n        self.system['w'][s:] = zero_arrays(self.parameters['x'][s:].copy(), len(self.parameters['s']))\n        # Recalculate distributions\n        # If start state is 0 reinitialize p_min, w and p_plus in state 0\n        if(self.state == 0):\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        self.calculate_system_states(until=len(self.parameters['x']))\n        self.calculate_wait_times()\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        # If a composition with a lower waiting time is found, store the system\n        if(test_loss &lt; lowest_loss):\n          lowest_loss = test_loss\n          store_optim['x'] = self.parameters['x'].copy()\n          newsystem = copy.deepcopy(self.system)\n          store_optim['system'] = newsystem\n          store_optim['tot_wt'] = test_wt\n          logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      # Set the system to the stored optimal system\n      self.parameters['x'] = store_optim['x'].copy()\n      self.system['p_min'] = store_optim['system']['p_min']\n      self.system['p_plus'] = store_optim['system']['p_plus']\n      self.system['w'] = store_optim['system']['w']\n      self.system['ew'] = store_optim['system']['ew']\n        \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      # logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def search_function(self, k=1, omega=0.5):\n      \"\"\"\n      Slide over the schedule intervals and run inpute_compositions()\n      \"\"\"\n      for i in range(0, len(self.parameters['x'] - k)):\n        self.impute_compositions(s=i, k=k, omega=omega)\n      \n      \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n      for interval, wtdists in enumerate(self.system['w']):\n          ew = 0\n          for nr, dist in enumerate(wtdists):\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(dist))\n              b = dist\n              meanwt = np.dot(a, b)\n              logging.info(f\"Mean waiting time for patient {nr} in interval {interval} = {meanwt}\")\n              ew += meanwt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][interval] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.local_search(omega=omega)\n    return(schedule)\n\n\ndef run_schedule_small_search(x, d, s, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.small_local_search(omega=omega)\n    return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 5\nomega = 0.5\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.5\nsch = run_schedule(x, d, s, u, omega, False)\nx_final = sch.parameters['x']\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\n\n\n                                                \n\n\n\n                                                \n\n\n\nsch.visualize_state(2)\n\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n\n                                                \n\n\n\nwith open(\"logs.txt\",'w') as file:\n  pass\nT = 12 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2\nx[1] = 1\nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.5\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nx_final = sch.parameters['x']\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\n\nInitial schedule: [2 1 1 0 1 0 1 0 1 0 1 1]\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n                                                \n\n\n\nwith open(\"logs.txt\",'w') as file:\n  pass\n\nT = 48 # number of intervals\nN = 10\nx = np.array(distribute_patients(N, T))\n\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 5\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.999\nsch = run_schedule_small_search(x, d, s, u, omega, False)\nx_final = sch.parameters['x']\nplot_timeline(x, \"Timeline of Occupied Timeslots - Initial Schedule\")\nplot_timeline(x_final, \"Timeline of Occupied Timeslots - Finale Schedule\")\nsch.visualize_system('p_min')\n\nInitial schedule: [1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0\n 0 1 0 0 0 0 1 0 0 0 0]\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "local-search-function.html",
    "href": "local-search-function.html",
    "title": "Local Search Function",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nfrom scipy.special import comb\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nfrom itertools import chain, combinations\nimport copy\n\nSchedule \\(x\\) is a vector with each element representing the number of scheduled patients.\n\n#x = [2, 1, 0, 2]\nx = [2, 0, 0, 0, 2]\n\nThe number of possible schedules is\n\\[\\dbinom{N+T-1}{N}\\]\n\nN = sum(x)\nT = len(x)\nresult = comb(N + T - 1, N, exact=True)  # exact=True returns the exact integer\nprint(result) \n\n70\n\n\n\ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]\n\n\ntest = powerset([1,2,3])\nlist(test)\n\n[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n\nDefine the vectors\n\\[\n\\left\\{\n\\begin{array}{c}\n\\vec{u_1}, \\\\\n\\vec{u_2}, \\\\\n\\vec{u_3}, \\\\\n\\vdots \\\\\n\\vec{u_{T-1}}, \\\\\n\\vec{u_T} \\\\\n\\end{array}\n\\right\\} =\n\\left\\{\n\\begin{array}{c}\n(-1, 0,...., 0, 1), \\\\\n(1, -1, 0,...., 0), \\\\\n(0, 1, -1,...., 0), \\\\\n\\vdots \\\\\n(0,...., 1, -1, 0), \\\\\n(0,...., 0, 1, -1) \\\\\n\\end{array}\n\\right\\}\n\\] and take \\(V^* = \\{u_1,....,u_T\\}\\).\n\ndef get_v_star(t):\n    # Create an initial vector 'u' of zeros with length 't'\n    u = np.zeros(t)\n    # Set the first element of vector 'u' to -1\n    u[0] = -1\n    # Set the last element of vector 'u' to 1\n    u[-1] = 1\n    # Initialize the list 'v_star' with the initial vector 'u'\n    v_star = [u]\n    # Loop over the length of 'u' minus one times\n    for i in range(len(u) - 1):\n        # Append the last element of 'u' to the front of 'u'\n        u = np.append(u[-1], u)\n        # Remove the last element of 'u' to maintain the same length\n        u = np.delete(u, -1)\n        # Append the updated vector 'u' to the list 'v_star'\n        v_star.append(u)\n    # Convert the list of vectors 'v_star' into a NumPy array and return it\n    return(np.array(v_star))\n\n# Example of function call:\n# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row\nget_v_star(4)\n\narray([[-1.,  0.,  0.,  1.],\n       [ 1., -1.,  0.,  0.],\n       [ 0.,  1., -1.,  0.],\n       [ 0.,  0.,  1., -1.]])\n\n\nAs the neighborhood of schedule \\(x\\) we take all vectors of the form \\(x + v_1+..+v_k\\) with \\(v_1,....,v_k \\in V^*\\)\n\n# Set the value of 't'\nt = len(x)\n\n# Generate a matrix 'v_star' using the 'get_v_star' function\nv_star = get_v_star(t)\n\n# Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., t-1}\n# 'ids' will be a list of tuples, where each tuple is a subset of indices\nids = list(powerset(range(t)))\n\n# Select the vectors from 'v_star' that correspond to the indices in each subset\n# 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\nsub_sets = [v_star[i] for i in ids]\n\n# Sum the vectors within each subset and flatten the result to get a 1-D array\n# 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\nsummed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n\n# 'summed_sets' is the final output\nsummed_sets\n\n[array([0., 0., 0., 0., 0.]),\n array([-1.,  0.,  0.,  0.,  1.]),\n array([ 1., -1.,  0.,  0.,  0.]),\n array([ 0.,  1., -1.,  0.,  0.]),\n array([ 0.,  0.,  1., -1.,  0.]),\n array([ 0.,  0.,  0.,  1., -1.]),\n array([ 0., -1.,  0.,  0.,  1.]),\n array([-1.,  1., -1.,  0.,  1.]),\n array([-1.,  0.,  1., -1.,  1.]),\n array([-1.,  0.,  0.,  1.,  0.]),\n array([ 1.,  0., -1.,  0.,  0.]),\n array([ 1., -1.,  1., -1.,  0.]),\n array([ 1., -1.,  0.,  1., -1.]),\n array([ 0.,  1.,  0., -1.,  0.]),\n array([ 0.,  1., -1.,  1., -1.]),\n array([ 0.,  0.,  1.,  0., -1.]),\n array([ 0.,  0., -1.,  0.,  1.]),\n array([ 0., -1.,  1., -1.,  1.]),\n array([ 0., -1.,  0.,  1.,  0.]),\n array([-1.,  1.,  0., -1.,  1.]),\n array([-1.,  1., -1.,  1.,  0.]),\n array([-1.,  0.,  1.,  0.,  0.]),\n array([ 1.,  0.,  0., -1.,  0.]),\n array([ 1.,  0., -1.,  1., -1.]),\n array([ 1., -1.,  1.,  0., -1.]),\n array([ 0.,  1.,  0.,  0., -1.]),\n array([ 0.,  0.,  0., -1.,  1.]),\n array([ 0.,  0., -1.,  1.,  0.]),\n array([ 0., -1.,  1.,  0.,  0.]),\n array([-1.,  1.,  0.,  0.,  0.]),\n array([ 1.,  0.,  0.,  0., -1.]),\n array([0., 0., 0., 0., 0.])]\n\n\n\ny = np.array([x + summed_sets[i] for i in range(len(summed_sets))])\ny\n\narray([[ 2.,  0.,  0.,  0.,  2.],\n       [ 1.,  0.,  0.,  0.,  3.],\n       [ 3., -1.,  0.,  0.,  2.],\n       [ 2.,  1., -1.,  0.,  2.],\n       [ 2.,  0.,  1., -1.,  2.],\n       [ 2.,  0.,  0.,  1.,  1.],\n       [ 2., -1.,  0.,  0.,  3.],\n       [ 1.,  1., -1.,  0.,  3.],\n       [ 1.,  0.,  1., -1.,  3.],\n       [ 1.,  0.,  0.,  1.,  2.],\n       [ 3.,  0., -1.,  0.,  2.],\n       [ 3., -1.,  1., -1.,  2.],\n       [ 3., -1.,  0.,  1.,  1.],\n       [ 2.,  1.,  0., -1.,  2.],\n       [ 2.,  1., -1.,  1.,  1.],\n       [ 2.,  0.,  1.,  0.,  1.],\n       [ 2.,  0., -1.,  0.,  3.],\n       [ 2., -1.,  1., -1.,  3.],\n       [ 2., -1.,  0.,  1.,  2.],\n       [ 1.,  1.,  0., -1.,  3.],\n       [ 1.,  1., -1.,  1.,  2.],\n       [ 1.,  0.,  1.,  0.,  2.],\n       [ 3.,  0.,  0., -1.,  2.],\n       [ 3.,  0., -1.,  1.,  1.],\n       [ 3., -1.,  1.,  0.,  1.],\n       [ 2.,  1.,  0.,  0.,  1.],\n       [ 2.,  0.,  0., -1.,  3.],\n       [ 2.,  0., -1.,  1.,  2.],\n       [ 2., -1.,  1.,  0.,  2.],\n       [ 1.,  1.,  0.,  0.,  2.],\n       [ 3.,  0.,  0.,  0.,  1.],\n       [ 2.,  0.,  0.,  0.,  2.]])\n\n\nsuch that \\(x + v_1+..+v_k \\ge 0\\)\n\nimport numpy as np\n\n# Create a mask for rows with negative values\nmask = ~np.any(y &lt; 0, axis=1)\n\n# Filter out rows with negative values using the mask\nfiltered_y = y[mask]\n\nfiltered_y\n\narray([[2., 0., 0., 0., 2.],\n       [1., 0., 0., 0., 3.],\n       [2., 0., 0., 1., 1.],\n       [1., 0., 0., 1., 2.],\n       [2., 0., 1., 0., 1.],\n       [1., 0., 1., 0., 2.],\n       [2., 1., 0., 0., 1.],\n       [1., 1., 0., 0., 2.],\n       [3., 0., 0., 0., 1.],\n       [2., 0., 0., 0., 2.]])\n\n\nSo the whole neighborhood function becomes.\n\ndef generate_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  print(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}\n  # 'ids' will be a list of tuples, where each tuple is a subset of indices\n  ids = list(powerset(range(T)))\n\n  # Select the vectors from 'v_star' that correspond to the indices in each subset\n  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\n  sub_sets = [v_star[i] for i in ids]\n\n  # Sum the vectors within each subset and flatten the result to get a 1-D array\n  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\n  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n  \n  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  print(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ntestnh = generate_search_neighborhood(x)\n\nThe schedule = [2, 0, 0, 0, 2]\nAnd the neighborhood is [[2. 0. 0. 0. 2.]\n [1. 0. 0. 0. 3.]\n [2. 0. 0. 1. 1.]\n [1. 0. 0. 1. 2.]\n [2. 0. 1. 0. 1.]\n [1. 0. 1. 0. 2.]\n [2. 1. 0. 0. 1.]\n [1. 1. 0. 0. 2.]\n [3. 0. 0. 0. 1.]\n [2. 0. 0. 0. 2.]]\n\n\nLet the objective function be a simple sum of square.\n\ndef obj_function(x):\n  res = sum(map(lambda i: i * i, x))\n  return res\n\nobj_function(np.array(x))\n\n8\n\n\nThe algorithm for computing an optimal schedule becomes.\n\ndef search_best_solution(x):\n    obj_value = obj_function(x)\n    \n    # Keep track of the best solution found\n    best_solution = x.copy()\n    \n    # Continue the search until no improvement is found\n    while True:  # Start an outer loop that will continue until explicitly broken\n        nh = generate_search_neighborhood(best_solution)  # Generate a new neighborhood\n        improved = False  # Flag to check if an improvement was found in the inner loop\n        \n        for y in nh:  # Inner loop to search through the neighborhood\n            c = obj_function(y)\n            if c &lt; obj_value:\n                obj_value = c\n                best_solution = y.copy()\n                print(f'Found better schedule {best_solution} with objective value {obj_value}')\n                improved = True  # Set the flag because an improvement was found\n                break  # Exit the inner loop to generate a new neighborhood\n        \n        if not improved:  # If no improvement was found in the inner loop\n            break  # Exit the outer loop - the search is complete\n\n    return best_solution, obj_value\n\n# Example usage:\nx = [5, 0, 0, 0, 1]\ninitial_solution = x  # Replace this with your actual initial solution\nbest_solution, best_obj_value = search_best_solution(initial_solution)\nprint(\"Best solution found:\", best_solution)\nprint(\"Objective value of the best solution:\", best_obj_value)\n\nThe schedule = [5, 0, 0, 0, 1]\nAnd the neighborhood is [[5. 0. 0. 0. 1.]\n [4. 0. 0. 0. 2.]\n [5. 0. 0. 1. 0.]\n [4. 0. 0. 1. 1.]\n [5. 0. 1. 0. 0.]\n [4. 0. 1. 0. 1.]\n [5. 1. 0. 0. 0.]\n [4. 1. 0. 0. 1.]\n [6. 0. 0. 0. 0.]\n [5. 0. 0. 0. 1.]]\nFound better schedule [4. 0. 0. 0. 2.] with objective value 20.0\nThe schedule = [4. 0. 0. 0. 2.]\nAnd the neighborhood is [[4. 0. 0. 0. 2.]\n [3. 0. 0. 0. 3.]\n [4. 0. 0. 1. 1.]\n [3. 0. 0. 1. 2.]\n [4. 0. 1. 0. 1.]\n [3. 0. 1. 0. 2.]\n [4. 1. 0. 0. 1.]\n [3. 1. 0. 0. 2.]\n [5. 0. 0. 0. 1.]\n [4. 0. 0. 0. 2.]]\nFound better schedule [3. 0. 0. 0. 3.] with objective value 18.0\nThe schedule = [3. 0. 0. 0. 3.]\nAnd the neighborhood is [[3. 0. 0. 0. 3.]\n [2. 0. 0. 0. 4.]\n [3. 0. 0. 1. 2.]\n [2. 0. 0. 1. 3.]\n [3. 0. 1. 0. 2.]\n [2. 0. 1. 0. 3.]\n [3. 1. 0. 0. 2.]\n [2. 1. 0. 0. 3.]\n [4. 0. 0. 0. 2.]\n [3. 0. 0. 0. 3.]]\nFound better schedule [3. 0. 0. 1. 2.] with objective value 14.0\nThe schedule = [3. 0. 0. 1. 2.]\nAnd the neighborhood is [[3. 0. 0. 1. 2.]\n [2. 0. 0. 1. 3.]\n [3. 0. 1. 0. 2.]\n [3. 0. 0. 2. 1.]\n [2. 0. 1. 0. 3.]\n [2. 0. 0. 2. 2.]\n [3. 1. 0. 0. 2.]\n [3. 0. 1. 1. 1.]\n [2. 1. 0. 0. 3.]\n [2. 0. 1. 1. 2.]\n [4. 0. 0. 0. 2.]\n [3. 1. 0. 1. 1.]\n [3. 0. 0. 0. 3.]\n [2. 1. 0. 1. 2.]\n [4. 0. 0. 1. 1.]\n [3. 0. 0. 1. 2.]]\nFound better schedule [2. 0. 0. 2. 2.] with objective value 12.0\nThe schedule = [2. 0. 0. 2. 2.]\nAnd the neighborhood is [[2. 0. 0. 2. 2.]\n [1. 0. 0. 2. 3.]\n [2. 0. 1. 1. 2.]\n [2. 0. 0. 3. 1.]\n [1. 0. 1. 1. 3.]\n [1. 0. 0. 3. 2.]\n [2. 1. 0. 1. 2.]\n [2. 0. 1. 2. 1.]\n [1. 1. 0. 1. 3.]\n [1. 0. 1. 2. 2.]\n [3. 0. 0. 1. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 0. 1. 3.]\n [1. 1. 0. 2. 2.]\n [3. 0. 0. 2. 1.]\n [2. 0. 0. 2. 2.]]\nFound better schedule [2. 0. 1. 1. 2.] with objective value 10.0\nThe schedule = [2. 0. 1. 1. 2.]\nAnd the neighborhood is [[2. 0. 1. 1. 2.]\n [1. 0. 1. 1. 3.]\n [2. 1. 0. 1. 2.]\n [2. 0. 2. 0. 2.]\n [2. 0. 1. 2. 1.]\n [1. 1. 0. 1. 3.]\n [1. 0. 2. 0. 3.]\n [1. 0. 1. 2. 2.]\n [3. 0. 0. 1. 2.]\n [2. 1. 1. 0. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 2. 1. 1.]\n [2. 0. 0. 1. 3.]\n [1. 1. 1. 0. 3.]\n [1. 1. 0. 2. 2.]\n [1. 0. 2. 1. 2.]\n [3. 0. 1. 0. 2.]\n [3. 0. 0. 2. 1.]\n [2. 1. 1. 1. 1.]\n [2. 0. 1. 0. 3.]\n [2. 0. 0. 2. 2.]\n [1. 1. 1. 1. 2.]\n [3. 0. 1. 1. 1.]\n [2. 0. 1. 1. 2.]]\nFound better schedule [2. 1. 1. 1. 1.] with objective value 8.0\nThe schedule = [2. 1. 1. 1. 1.]\nAnd the neighborhood is [[2. 1. 1. 1. 1.]\n [1. 1. 1. 1. 2.]\n [3. 0. 1. 1. 1.]\n [2. 2. 0. 1. 1.]\n [2. 1. 2. 0. 1.]\n [2. 1. 1. 2. 0.]\n [2. 0. 1. 1. 2.]\n [1. 2. 0. 1. 2.]\n [1. 1. 2. 0. 2.]\n [1. 1. 1. 2. 1.]\n [3. 1. 0. 1. 1.]\n [3. 0. 2. 0. 1.]\n [3. 0. 1. 2. 0.]\n [2. 2. 1. 0. 1.]\n [2. 2. 0. 2. 0.]\n [2. 1. 2. 1. 0.]\n [2. 1. 0. 1. 2.]\n [2. 0. 2. 0. 2.]\n [2. 0. 1. 2. 1.]\n [1. 2. 1. 0. 2.]\n [1. 2. 0. 2. 1.]\n [1. 1. 2. 1. 1.]\n [3. 1. 1. 0. 1.]\n [3. 1. 0. 2. 0.]\n [3. 0. 2. 1. 0.]\n [2. 2. 1. 1. 0.]\n [2. 1. 1. 0. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 2. 1. 1.]\n [1. 2. 1. 1. 1.]\n [3. 1. 1. 1. 0.]\n [2. 1. 1. 1. 1.]]\nBest solution found: [2. 1. 1. 1. 1.]\nObjective value of the best solution: 8.0\n\n\n\ndef search_solutions_3d(s, obj_func):\n    \"\"\"\n    Perform a search for the best solution in a solution space using a neighborhood-based search algorithm.\n\n    Args:\n    s (list): The initial solution from which the search starts. Needs three elements x, y, z\n    obj_func (function): The objective function that evaluates the quality of a solution.\n\n    Returns:\n    list: The x, y, z coordinates (or components) of each solution in the search history.\n    list: The corresponding objective function values for each solution in the search history.\n\n    The function initializes with an initial solution 's' and evaluates it using the objective function 'obj_func'.\n    It then iteratively generates neighboring solutions, evaluates them, and keeps track of the best solution found so far.\n    The search continues until no further improvement is found in the neighborhood of the current best solution.\n    \"\"\"\n\n    # Evaluate the initial solution\n    obj_value = obj_func(s)\n    \n    # Initialize the best solution as the initial solution\n    best_solution = s.copy()\n    \n    # Initialize lists to keep track of the search history\n    x, y, z, f_v = [], [], [], []\n    \n    # Start an outer loop that continues until no improvement is found\n    while True:\n        # Generate a new neighborhood of solutions around the current best solution\n        nh = generate_search_neighborhood(best_solution)\n        \n        # Flag to check if an improvement was found in the current iteration\n        improved = False\n        \n        # Iterate over each solution in the neighborhood\n        for s in nh:\n            # Append the components of the solution to the history lists\n            x.append(s[0])\n            y.append(s[1])\n            z.append(s[2])\n            \n            # Evaluate the current solution\n            c = obj_func(s)\n            f_v.append(c)\n            print(f'Tested solution {s} with objective value {c}')\n            \n            # Check if the current solution is an improvement\n            if c &lt; obj_value:\n                # Update the best solution and its objective value\n                obj_value = c\n                best_solution = s.copy()\n                print(f'Found better solution {best_solution} with objective value {obj_value}')\n                \n                # Mark that an improvement was found and exit the inner loop\n                improved = True\n                break\n        \n        # If no improvement was found in the entire neighborhood\n        if not improved:\n            # Exit the outer loop - the search is complete\n            break\n\n    # Return the search history\n    return x, y, z, f_v\n\n\ns = [3, 0, 0]\nx, y, z, f_v = search_solutions_3d(s, obj_function)\n\n# Determine the range for each axis to set the ticks\ns_range = range(int(min(s)), int(max(s)) + 1)\n\nfig = go.Figure(data=[go.Scatter3d(\n    x=x,\n    y=y,\n    z=z,\n    mode='markers',\n    marker=dict(\n        size=6,\n        color=f_v,  # Set color to function values\n        colorscale='Plotly3',\n        opacity=0.8,\n        showscale=True\n    ),\n    hoverinfo='text',\n    text=[f'x: {xi:.0f}, y: {yi:.0f}, z: {zi:.0f}, f_v: {value:.1f}' for xi, yi, zi, value in zip(x, y, z, f_v)]\n)])\n\nfig.update_layout(title='3D Function Visualization',\n                  scene=dict(\n                      xaxis=dict(title='X axis', tickmode='array', tickvals=list(s_range)),\n                      yaxis=dict(title='Y axis', tickmode='array', tickvals=list(s_range)),\n                      zaxis=dict(title='Z axis', tickmode='array', tickvals=list(s_range))\n                  ))\n\nfig.show()\n\nThe schedule = [3, 0, 0]\nAnd the neighborhood is [[3. 0. 0.]\n [2. 0. 1.]\n [2. 1. 0.]\n [3. 0. 0.]]\nTested solution [3. 0. 0.] with objective value 9.0\nTested solution [2. 0. 1.] with objective value 5.0\nFound better solution [2. 0. 1.] with objective value 5.0\nThe schedule = [2. 0. 1.]\nAnd the neighborhood is [[2. 0. 1.]\n [1. 0. 2.]\n [2. 1. 0.]\n [1. 1. 1.]\n [3. 0. 0.]\n [2. 0. 1.]]\nTested solution [2. 0. 1.] with objective value 5.0\nTested solution [1. 0. 2.] with objective value 5.0\nTested solution [2. 1. 0.] with objective value 5.0\nTested solution [1. 1. 1.] with objective value 3.0\nFound better solution [1. 1. 1.] with objective value 3.0\nThe schedule = [1. 1. 1.]\nAnd the neighborhood is [[1. 1. 1.]\n [0. 1. 2.]\n [2. 0. 1.]\n [1. 2. 0.]\n [1. 0. 2.]\n [0. 2. 1.]\n [2. 1. 0.]\n [1. 1. 1.]]\nTested solution [1. 1. 1.] with objective value 3.0\nTested solution [0. 1. 2.] with objective value 5.0\nTested solution [2. 0. 1.] with objective value 5.0\nTested solution [1. 2. 0.] with objective value 5.0\nTested solution [1. 0. 2.] with objective value 5.0\nTested solution [0. 2. 1.] with objective value 5.0\nTested solution [2. 1. 0.] with objective value 5.0\nTested solution [1. 1. 1.] with objective value 3.0\n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Experiments",
    "section": "",
    "text": "This site contains the code experiments for my research on appointment scheduling optimization. Specifically I am working on solution methods for single stage stochastic programming problems (1-SSP) and so-called off-line scheduling system. In an off-line scheduling system all patients that want an appointment in a specific time-frame (e.g. day) are gathered first and then given an appointment time. An example of such a problem is scheduling a number of patients into a series of fixed time slots for a single physician. Each patient will have a certain service time that can not be predicted, but has some known distribution with a mean and variance. If a certain patient needs more time to consult than his time slot the next patient will start later. In case the patient finishes earlier, the doctor has idle time.\nBoth waiting times - for patient and doctor - are undesirable. The question is how to find an optimal schedule that minimizes total waiting times. Weights can be given to both types of waiting times to accommodate for different utilities of saved time for patients and doctors.\nSolution methods for these kinds of problems can be divided into two types: (1) analytical and (2) numerical. Analytical methods applies mathematical principles to a problem in order to obtain provable results. Numerical methods use sets of iterative procedures to find solutions to problems that are hard to solve by analytical methods. A numerical method is considered accurate if it finds: (1) an optimal solution in a given time or (2) a perturbed (or near-optimal) solution with a known deterministic error bound, which is a bound on the solution’s (relative or absolute) optimality gap. An inaccurate method does not produce an error bound and the quality of the solution can not be determined (Ahmadi-Javid, Jalali, and Klassen 2017).\nIdeas:\n\nApply utility function to waiting times -&gt; one minute of waiting is more acceptable than 30 minutes of waiting.\n\n\n\n\n\n\nReferences\n\nAhmadi-Javid, Amir, Zahra Jalali, and Kenneth J Klassen. 2017. “Outpatient Appointment Systems in Healthcare: A Review of Optimization Studies.” European Journal of Operational Research 258 (1): 3–34. https://doi.org/10.1016/j.ejor.2016.06.064."
  },
  {
    "objectID": "sched-sim.html",
    "href": "sched-sim.html",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#setup",
    "href": "sched-sim.html#setup",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#run-simulation-1",
    "href": "sched-sim.html#run-simulation-1",
    "title": "Scheduling Simulation",
    "section": "Run simulation 1",
    "text": "Run simulation 1\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14 \nlns = 5\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], dtype=object) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time= {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time= 3.1445460268424377')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-2",
    "href": "sched-sim.html#run-simulation-2",
    "title": "Scheduling Simulation",
    "section": "Run simulation 2",
    "text": "Run simulation 2\n\nConfigure parameters.\n\n# Configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving silnmlation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n\nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times.\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 11.169643568694726')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-3",
    "href": "sched-sim.html#run-simulation-3",
    "title": "Scheduling Simulation",
    "section": "Run simulation 3",
    "text": "Run simulation 3\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 0, 0, 60, 0, 0, 0, 60, 0, 0, 0]) # inter-arrival times\n\nnsims = nsims # number of simulations\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 22.788852933919546')]"
  },
  {
    "objectID": "schedule-probabilities.html",
    "href": "schedule-probabilities.html",
    "title": "Scheduling w/ Nested Partitions",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \ndef weak_compositions(n, k):\n    if k == 1:\n        return [[n]]\n    compositions = []\n    for i in range(n + 1):\n        for composition in weak_compositions(n - i, k - 1):\n            compositions.append([i] + composition)\n    return compositions\n  \nprint(f'Weak compositions are: {weak_compositions(2, 4)}')\n\n\nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n        \nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\nWeak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for functions defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s):\n            \"\"\"\n            Initialize the class with a schedule of patients and a service time distribution.\n            \n            Args:\n            d (int): An integer representing the time lenght of an interval.\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            s (list): A list of floats representing the probability distribution of service times.\n            \"\"\"\n            \n            self.parameters = dict({'x': x, 'd': d, 's': s})\n            logging.info(f'{datetime.datetime.now()} - x = {self.parameters[\"x\"]}')\n            # Initialize the system dictionary with p_min and p_plus. p_min has one element extra for storing tardiness\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        \n    def calculate_system_states(self, until = 1):\n            \"\"\"\n            Calculate the probabilities of the system being in each state at each time step.\n            \n            Args:\n            until (int): An optional integer representing the state until which to calculate the probabilities.\n            \"\"\"\n            \n            while self.state &lt; until:\n                logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n                \n                \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n                \n                \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n                \n                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n                \n                \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n                The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n                of waiting times of the first patient in state t and the service time distribution. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                     logging.info(f'{datetime.datetime.now()} - Done')\n                     for i in range(1, self.parameters['x'][self.state]):\n                            logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n\n                \n                \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n                the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n                Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal \n                to the distribution of work at the beginning of t. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                \"\"\"Jump to next state\"\"\"\n                self.state += 1\n    \n    def impute_compositions(self, s=0, k=2, omega=0.5):\n      \"\"\"\n      Impute the compositions of patients in a given time interval and establish the schedule with the lowest total waiting time.\n      \n      Args:\n      s (int): An integer representing the starting state.\n      k (int): An integer representing the number of states from the starting state to include in the compositions.\n      \"\"\"\n      logging.info(f'{datetime.datetime.now()} - Running impute_compositions() in state {self.state} with x = {self.parameters[\"x\"]}')\n      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end.\n      t = min(len(self.parameters['x']), s+k)\n      k = t - s\n      c = self.parameters['x'][s:t]\n      n = c.sum()\n      # Calculate initial loss\n      test_wt = self.system[\"ew\"].sum()\n      self.calculate_tardiness()\n      indices = np.arange(self.system['p_min'][-1].size) \n      exp_tard = (indices * self.system['p_min'][-1]).sum()\n      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n      # Generate compositions\n      compositions = weak_compositions(n, k)\n      logging.info(f'{datetime.datetime.now()} - Computing {len(compositions)} compositions')\n      # For all compositions calculate the waiting times\n      for comp in compositions:\n        # Insert composition in x\n        self.parameters['x'][s:t] = comp.copy()\n        # Set starting state\n        self.state = s\n        # Adjust the array for waiting time distributions to new x\n        self.system['w'][s:] = zero_arrays(self.parameters['x'][s:].copy(), len(self.parameters['s']))\n        # Recalculate distributions\n        # If start state is 0 reinitialize p_min, w and p_plus in state 0\n        if(self.state == 0):\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        self.calculate_system_states(until=len(self.parameters['x']))\n        self.calculate_wait_times()\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        # If a composition with a lower waiting time is found, store the system\n        if(test_loss &lt; lowest_loss):\n          lowest_loss = test_loss\n          store_optim['x'] = self.parameters['x'].copy()\n          newsystem = copy.deepcopy(self.system)\n          store_optim['system'] = newsystem\n          store_optim['tot_wt'] = test_wt\n          logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      # Set the system to the stored optimal system\n      self.parameters['x'] = store_optim['x'].copy()\n      self.system['p_min'] = store_optim['system']['p_min']\n      self.system['p_plus'] = store_optim['system']['p_plus']\n      self.system['w'] = store_optim['system']['w']\n      self.system['ew'] = store_optim['system']['ew']\n        \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def search_function(self, k=1, omega=0.5):\n      \"\"\"\n      Slide over the schedule intervals and run inpute_compositions()\n      \"\"\"\n      for i in range(0, len(self.parameters['x'] - k)):\n        self.impute_compositions(s=i, k=k, omega=omega)\n      \n      \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n    # Initialize time counter\n      t = 0\n      # Calculate the expected waiting time for each time step\n      for t, w in enumerate(self.system['w']):\n          ew = 0\n          for i in w:\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(i))\n              b = i\n              wt = np.dot(a, b)\n              ew += wt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][t] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.search_function(k=3, omega=omega)\n    return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 5\nomega = 0.5\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = len(x)\nomega = 1\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = len(x)\nomega = 0\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3  \nsch = run_schedule(x, d, s, u, omega, False)\n\n\nsch.visualize_state(2)\n\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n\n                                                \n\n\n\nT = 24 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2 \nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_plus')\n\nInitial schedule: [2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1]\n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "noshow.html",
    "href": "noshow.html",
    "title": "No-shows and emergency patients",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nLet the number of arriving emergency patients be \\(Y\\). Then the amount of work arriving is the Y-fold convolution of the vector representing the service time for emergency patients, \\(s_e^{(Y)}\\). In this vector the \\(j\\)th element \\(s_{ej}\\) denotes the probability that the service time of an emergency patient is \\(j\\) minutes. Then the distribution of the amount of emergency work arriving at the start of any interval is given by:\n\\[v_0(i) = \\sum\\limits_{y=1}^{\\infty}s_{ei}^{(Y)}P(Y=y) = \\Big(\\sum\\limits_{y=1}^{\\infty}P(Y=y)s_{e}^{(y)}\\Big)_i\\]\n\nimport numpy as np\nfrom scipy.stats import poisson\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\n\ndef service_time_with_no_shows(s, q):\n  # \"\"\"\n  # Function to adjust a distribution of service times for no-shows\n  # \n  # Args:\n  #     s (numpy.ndarray): An array with service times.\n  #     q (double): The fraction of no-shows.\n  # \n  # Returns:\n  #     numpy.ndarray: The adjusted array of service times.\n  # \"\"\"\n  \n  s_adj = s * (1-q)\n  s_adj[0] = s_adj[0] + q\n  \n  return(s_adj)\n\ndef add_lists(short_list, long_list):\n  # \"\"\"\n  # This function takes in two lists and returns a new list where each element \n  # is the sum of the elements from the input lists at the corresponding position.\n  # If the lists are of different lengths, the shorter list is extended with zeros \n  # to match the length of the longer list.\n  # \n  # Parameters:\n  # - short_list (list): The shorter list of numbers.\n  # - long_list (list): The longer list of numbers.\n  # \n  # Returns:\n  # - list: A list containing the element-wise sum of the two input lists.\n  # \"\"\"\n  \n  # Extend the short lists to the length of the long list with zeros\n  short_list.extend([0] * (len(long_list) - len(short_list)))\n  \n  # Sum the elements of the two lists element-wise\n  result = [a + b for a, b in zip(short_list, long_list)]\n  \n  return result\n\ndef calculate_rolling_convolution(p_y, s, limit):\n  conv_list = s\n  v = [x * p_y[0] for x in conv_list]\n  for i in range(1, limit):\n    conv_list = np.convolve(conv_list, s)\n    v = add_lists(v, [x * p_y[i] for x in conv_list])\n  print(f'conv_list = {conv_list[:10]} (first ten elements) with sum {sum(conv_list)}, v = {v[:10]} with sum {sum(v)}')\n  return(v)\n\n\n### TEST ###\n\ns = np.array([0.0, 0.5, 0.2, 0.3])\nq = 0.1\ns_adj = service_time_with_no_shows(s, q)\nprint(f'adjusted service times={s_adj}, with sum  {s_adj.sum()}')\n\nadjusted service times=[0.1  0.45 0.18 0.27], with sum  1.0\n\n\n\n### TEST 2 ###\n\np_y = [0.5, 0.3, 0.2]\ns = [0.1, 0.2, 0.7]\nlimit = 3\nv = calculate_rolling_convolution(p_y, s, limit)\n\nconv_list = [0.001 0.006 0.033 0.092 0.231 0.294 0.343] (first ten elements) with sum 1.0, v = [0.053200000000000004, 0.11320000000000001, 0.41059999999999997, 0.10239999999999999, 0.19319999999999996, 0.0588, 0.06859999999999998] with sum 0.9999999999999999\n\n\n\ntrace = go.Scatter(\n            x = list(range(len(v))),\n            y = v,\n            mode = 'lines'\n        )\n        \ndata = [trace]\n\nlayout = go.Layout(\n    title = f'distribution of v',\n    xaxis = dict(title='Time'),\n    yaxis = dict(title='Probability')\n)\n\nfig = go.Figure(data=data, layout=layout)\npyo.iplot(fig)\n\n\n                                                \n\n\n\n### TEST 3 ###\n\nlen_y = 300\nlen_se = 300\np_y = [poisson.pmf(i, 2) for i in range(0, len_y)]\nse = [poisson.pmf(j, 10) for j in range(0, len_se)]\nprint(sum(p_y), sum(se))\n\nv = calculate_rolling_convolution(p_y, se, len_y)\n\n0.9999999999999999 1.0000000000000022\nconv_list = [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] (first ten elements) with sum 1.0000000000006708, v = [6.144770272275882e-06, 6.145328216553419e-05, 0.00030732220778848765, 0.0010247793643651344, 0.002563808626256866, 0.0051350592539100804, 0.00858324446168137, 0.01233269472644276, 0.015593252353944275, 0.0177203279998164] with sum 1.0000000000000064\n\n\n\ntrace = go.Scatter(\n            x = list(range(len(v))),\n            y = v[:len_y],\n            mode = 'lines'\n        )\n        \ndata = [trace]\n\nlayout = go.Layout(\n    title = f'distribution of v',\n    xaxis = dict(title='Time'),\n    yaxis = dict(title='Probability')\n)\n\nfig = go.Figure(data=data, layout=layout)\npyo.iplot(fig)\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "sim-based-opt.html",
    "href": "sim-based-opt.html",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#setup",
    "href": "sim-based-opt.html#setup",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#run-simulations",
    "href": "sim-based-opt.html#run-simulations",
    "title": "Simulation Based Optimization",
    "section": "Run simulations",
    "text": "Run simulations\n\n# Simulation 1\n\ntic = time.time()\nsim = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nN = len(iats) # number of patients\n# T = len(sim) # number of intervals\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimreswt = []\nsimresln = 0\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = loss = 0.5 * mwt + 0.5 * mln\ntoc = time.time()\nprint(toc - tic)\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\n1.650622844696045\n\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 1 1 1 1 1 1 1], mwt: 1.623013626236916, mln: 2.0159991686124927, loss: 1.8195063974247043')\n\n\n\n\n\n\n\n\n\n# Simulation 2\n\nsim = np.array([2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [2 0 1 1 1 1 1 1 1 1 1 1], mwt: 2.2059217235466164, mln: 2.0121440981123744, loss: 2.1090329108294954')\n\n\n\n\n\n\n\n\n\n# Simulation 3\n\nsim = np.array([1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 2 0 1 1 1 1 1 1 1], mwt: 2.2903142778961825, mln: 2.0050766323792844, loss: 2.1476954551377334')\n\n\n\n\n\n\n\n\n\n# Simulation 4\n\nsim = np.array([1, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 2 0 1 1 1 1 1], mwt: 2.306221415126957, mln: 1.993071225402805, loss: 2.149646320264881')"
  },
  {
    "objectID": "search-function.html",
    "href": "search-function.html",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#setup",
    "href": "search-function.html#setup",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#run-simulations-and-search",
    "href": "search-function.html#run-simulations-and-search",
    "title": "Search Function",
    "section": "Run simulations and search",
    "text": "Run simulations and search\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 30\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 8 patients and 12 timeslots.\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 20 20 20 20 20 10],\niats_diff: [  0  20   0   0   0   0 -10],\nloss = 3.6636334116053373, calc time: 1.2856969833374023 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 20 20 20 20 20 10  0],\niats_diff: [ 20   0   0   0   0 -10 -10],\nloss = 7.251486695484076, calc time: 1.2664740085601807 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 10 30 20 20 20 10],\niats_diff: [  0  10  20 -10   0   0 -10],\nloss = 4.023104911017024, calc time: 1.3996679782867432 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 20 10 30 20 20 10],\niats_diff: [  0  20 -10  20 -10   0 -10],\nloss = 3.897219272804179, calc time: 1.2673380374908447 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 20 20 10 30 20 10],\niats_diff: [  0  20   0 -10  20 -10 -10],\nloss = 3.832647874558151, calc time: 1.2683939933776855 secs\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 20 20 20 10 30 10],\niats_diff: [  0  20   0   0 -10  20 -20],\nloss = 3.7675997015198543, calc time: 1.2625746726989746 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 0 1 1 0 1] with loss: 3.037022979603142\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 20 20 20 20 10 20],\niats_diff: [  0  20   0   0   0 -10  10],\nloss = 3.037022979603142, calc time: 1.2789831161499023 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 1 0 2],\niats: [ 0 20 20 20 20 10 20  0],\niats_diff: [ 20   0   0   0 -10  10 -20],\nloss = 6.289434594941872, calc time: 1.270392894744873 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 10 30 20 20 10 20],\niats_diff: [  0  10  20 -10   0 -10  10],\nloss = 3.3960494862507833, calc time: 1.4050920009613037 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 1 0 1],\niats: [ 0  0 20 10 30 20 10 20],\niats_diff: [  0  20 -10  20 -10 -10  10],\nloss = 3.2683415718877535, calc time: 1.3611869812011719 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 1 0 1],\niats: [ 0  0 20 20 10 30 10 20],\niats_diff: [  0  20   0 -10  20 -20  10],\nloss = 3.1910929038074882, calc time: 1.285851001739502 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 1 0 1 0 1] with loss: 2.898930749394828\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 20 20 20 10 20 20],\niats_diff: [  0  20   0   0 -10  10   0],\nloss = 2.898930749394828, calc time: 1.4061000347137451 secs\n\nschedule: [1 0 1 0 1 0 1 1 0 1 0 2],\niats: [ 0 20 20 20 10 20 20  0],\niats_diff: [ 20   0   0 -10  10   0 -20],\nloss = 6.058454554552079, calc time: 1.289099931716919 secs\n\nschedule: [2 1 0 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 10 30 20 10 20 20],\niats_diff: [  0  10  20 -10 -10  10   0],\nloss = 3.2568688734254705, calc time: 1.2839219570159912 secs\n\nschedule: [2 0 1 1 0 0 1 1 0 1 0 1],\niats: [ 0  0 20 10 30 10 20 20],\niats_diff: [  0  20 -10  20 -20  10   0],\nloss = 3.1219849234572488, calc time: 1.2718288898468018 secs\n\n\n#### Found better schedule: [2 0 1 0 1 1 0 1 0 1 0 1] with loss: 2.896105033047545\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.896105033047545, calc time: 1.303311824798584 secs\n\nschedule: [1 0 1 0 1 1 0 1 0 1 0 2],\niats: [ 0 20 20 10 20 20 20  0],\niats_diff: [ 20   0 -10  10   0   0 -20],\nloss = 5.995225266269035, calc time: 1.259354829788208 secs\n\nschedule: [2 1 0 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 10 30 10 20 20 20],\niats_diff: [  0  10  20 -20  10   0   0],\nloss = 3.249234567381676, calc time: 1.2811720371246338 secs\n\nschedule: [2 0 1 1 0 1 0 1 0 1 0 1],\niats: [ 0  0 20 10 20 20 20 20],\niats_diff: [  0  20 -10  10   0   0   0],\nloss = 2.9954443447685204, calc time: 1.412632942199707 secs\n\nschedule: [2 0 1 0 2 0 0 1 0 1 0 1],\niats: [ 0  0 20 20  0 30 20 20],\niats_diff: [  0  20   0 -20  30 -10   0],\nloss = 3.310561288126987, calc time: 1.2690391540527344 secs\n\nschedule: [2 0 1 0 1 1 1 0 0 1 0 1],\niats: [ 0  0 20 20 10 10 30 20],\niats_diff: [  0  20   0 -10   0  20 -10],\nloss = 3.1252576361490214, calc time: 1.2765130996704102 secs\n\nschedule: [2 0 1 0 1 1 0 1 1 0 0 1],\niats: [ 0  0 20 20 10 20 10 30],\niats_diff: [  0  20   0 -10  10 -10  20],\nloss = 3.010327223429842, calc time: 1.3144748210906982 secs\n\nschedule: [2 0 1 0 1 1 0 1 0 1 1 0],\niats: [ 0  0 20 20 10 20 20 10],\niats_diff: [  0  20   0 -10  10   0 -10],\nloss = 4.039832308108773, calc time: 1.3708040714263916 secs\n\nFinished iterating in: 34 seconds\n\nBest result:\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.896105033047545, calc time: 1.4389207363128662 secs\n\n\n\n\ndef distribute_elements(n, t):\n    quotient, remainder = divmod(t, n-1)\n    elements = np.zeros(t)\n    for i in range(n-1):\n        elements[i * quotient] = 1\n    elements[0] = elements[0] + 1\n    return elements\n  \n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 20 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 24 # number of intervals\nN = 9 # number of patients\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = distribute_elements(N, T)\nsim = sim.astype(int) # initial schedule\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\n\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 300\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 9 patients and 24 timeslots.\nGenerated new psm\n\nschedule: [2 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0],\niats: [ 0  0 30 30 30 30 30 30 30],\niats_diff: [ 0 30  0  0  0  0  0  0],\nloss = 5.1034086222256345, calc time: 1.4092040061950684 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1] with loss: 4.483070518426679\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 30 30 20],\niats_diff: [ 30   0   0   0   0   0   0 -10],\nloss = 4.483070518426679, calc time: 1.4832868576049805 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 2],\niats: [30 30 30 30 30 30 30 20  0],\niats_diff: [  0   0   0   0   0   0 -10 -20],\nloss = 12.141393301003372, calc time: 1.3221690654754639 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 20 40 30 30 30 30 30 20],\niats_diff: [ 20  20 -10   0   0   0   0 -10],\nloss = 4.55522088117743, calc time: 1.3329222202301025 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 20 40 30 30 30 30 20],\niats_diff: [ 30 -10  20 -10   0   0   0 -10],\nloss = 4.556797721866591, calc time: 1.3435189723968506 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 20 40 30 30 30 20],\niats_diff: [ 30   0 -10  20 -10   0   0 -10],\nloss = 4.557232868222677, calc time: 1.4979221820831299 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 20 40 30 30 20],\niats_diff: [ 30   0   0 -10  20 -10   0 -10],\nloss = 4.556508608368781, calc time: 1.370326042175293 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 20 40 30 20],\niats_diff: [ 30   0   0   0 -10  20 -10 -10],\nloss = 4.554553601575164, calc time: 1.3668289184570312 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 20 40 20],\niats_diff: [ 30   0   0   0   0 -10  20 -20],\nloss = 4.538516828163093, calc time: 1.475503921508789 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1] with loss: 4.0102981442441985\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 30 20 30],\niats_diff: [ 30   0   0   0   0   0 -10  10],\nloss = 4.0102981442441985, calc time: 1.4000871181488037 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 2],\niats: [30 30 30 30 30 30 20 30  0],\niats_diff: [  0   0   0   0   0 -10  10 -30],\nloss = 11.484531995407337, calc time: 1.3497929573059082 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 30 20 30],\niats_diff: [ 20  20 -10   0   0   0 -10  10],\nloss = 4.082448506994949, calc time: 1.4646258354187012 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 30 20 30],\niats_diff: [ 30 -10  20 -10   0   0 -10  10],\nloss = 4.083984055333939, calc time: 1.3544261455535889 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 30 20 30],\niats_diff: [ 30   0 -10  20 -10   0 -10  10],\nloss = 4.084417411445207, calc time: 1.3335061073303223 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 30 20 30],\niats_diff: [ 30   0   0 -10  20 -10 -10  10],\nloss = 4.0834290800128, calc time: 1.438551902770996 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 40 20 30],\niats_diff: [ 30   0   0   0 -10  20 -20  10],\nloss = 4.07835374138569, calc time: 1.466221809387207 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1] with loss: 3.9555383771988897\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 20 30 30],\niats_diff: [ 30   0   0   0   0 -10  10   0],\nloss = 3.9555383771988897, calc time: 1.353766918182373 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 30 20 30 30  0],\niats_diff: [  0   0   0   0 -10  10   0 -30],\nloss = 11.409532708505767, calc time: 1.4678127765655518 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 20 30 30],\niats_diff: [ 20  20 -10   0   0 -10  10   0],\nloss = 4.027687402997222, calc time: 1.3594887256622314 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 20 30 30],\niats_diff: [ 30 -10  20 -10   0 -10  10   0],\nloss = 4.029196243928684, calc time: 1.350052833557129 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 20 30 30],\niats_diff: [ 30   0 -10  20 -10 -10  10   0],\nloss = 4.029411186430586, calc time: 1.3423752784729004 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 20 30 30],\niats_diff: [ 30   0   0 -10  20 -20  10   0],\nloss = 4.026166738139311, calc time: 1.5235190391540527 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9467498663865372\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 30 30 30],\niats_diff: [ 30   0   0   0 -10  10   0   0],\nloss = 3.9467498663865372, calc time: 1.3315348625183105 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 20 30 30 30  0],\niats_diff: [  0   0   0 -10  10   0   0 -30],\nloss = 11.39932780287025, calc time: 1.483426809310913 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 20 30 30 30],\niats_diff: [ 20  20 -10   0 -10  10   0   0],\nloss = 4.018868352137226, calc time: 1.3578240871429443 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 20 30 30 30],\niats_diff: [ 30 -10  20 -10 -10  10   0   0],\nloss = 4.0201721323417425, calc time: 1.3814740180969238 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 20 30 30 30],\niats_diff: [ 30   0 -10  20 -20  10   0   0],\nloss = 4.018527556233803, calc time: 1.3681919574737549 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9456653833233166\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.3711330890655518 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3417401313781738 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.5575330257415771 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.3878271579742432 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3418498039245605 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.371924877166748 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.4989020824432373 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.3482179641723633 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.3367047309875488 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3847911357879639 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.441328763961792 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3331172466278076 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.400420904159546 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.4720962047576904 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3627750873565674 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.34785795211792 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3492600917816162 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.498161792755127 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.3708961009979248 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3670709133148193 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.4871211051940918 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3410758972167969 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3703131675720215 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.337886095046997 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.4830751419067383 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3309168815612793 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3365907669067383 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.394160270690918 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.431645154953003 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.338271141052246 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.3578228950500488 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.5018112659454346 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3501310348510742 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.33778715133667 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3422632217407227 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.4763941764831543 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3429012298583984 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.3479619026184082 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.4915390014648438 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3979060649871826 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.3763160705566406 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3296091556549072 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.4732320308685303 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.3376121520996094 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.33884596824646 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3830459117889404 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.456758975982666 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.3305599689483643 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.3444769382476807 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.544861078262329 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.3439478874206543 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.327728033065796 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.340852975845337 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.4759268760681152 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3350121974945068 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3232018947601318 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.478518009185791 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.3466219902038574 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.363710880279541 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3438951969146729 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.522420883178711 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3625741004943848 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3772947788238525 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.3883321285247803 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.4368319511413574 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3334951400756836 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3652291297912598 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.4656591415405273 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.33355712890625 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3566408157348633 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.342548131942749 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.4701502323150635 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3491370677947998 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.4525949954986572 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.4989748001098633 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.326246976852417 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3510539531707764 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.340425968170166 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.4652931690216064 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3517098426818848 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.3428137302398682 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3559176921844482 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.4783170223236084 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.3845760822296143 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3802881240844727 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.4536609649658203 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3352041244506836 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.360658884048462 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.3443350791931152 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.4924681186676025 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.3557450771331787 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.351572036743164 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.5185410976409912 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.3916189670562744 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.397773027420044 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3260421752929688 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.4793388843536377 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.331324815750122 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.3477778434753418 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.420954704284668 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.3933727741241455 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3416812419891357 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3669428825378418 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.5045878887176514 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3691771030426025 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3530962467193604 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3585171699523926 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.4696698188781738 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.3345720767974854 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3744068145751953 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.4779777526855469 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3326468467712402 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.339756727218628 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.338083028793335 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.4907619953155518 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3282959461212158 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.347987174987793 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.4004499912261963 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.416496992111206 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3452208042144775 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.4170010089874268 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.4596340656280518 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3541522026062012 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.3593909740447998 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3505890369415283 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.5007212162017822 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.377861738204956 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.3456549644470215 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.4902000427246094 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3450770378112793 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.333008050918579 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3497540950775146 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.5062599182128906 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.404905080795288 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3671491146087646 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.465935230255127 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3904821872711182 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.372412919998169 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.3700439929962158 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.4836921691894531 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.3702151775360107 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3475990295410156 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.409541130065918 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.4569311141967773 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3596158027648926 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3501613140106201 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.5608172416687012 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.4109492301940918 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.398871898651123 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.4387900829315186 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.6539719104766846 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3627040386199951 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3628668785095215 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.4709911346435547 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3691167831420898 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3411340713500977 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.383824110031128 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.4663918018341064 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.3616020679473877 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.360630750656128 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.491217851638794 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.3432283401489258 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3630378246307373 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.3551838397979736 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.483025074005127 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3330600261688232 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3502247333526611 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.497816801071167 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.4161200523376465 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.3971612453460693 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.4043281078338623 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.563204050064087 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3757379055023193 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.4014463424682617 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.5395631790161133 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.3926799297332764 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.434528112411499 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.3800179958343506 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.5169551372528076 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.359511137008667 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.383864164352417 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39797790827368, calc time: 1.4869639873504639 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.017602745258275, calc time: 1.3609259128570557 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.0169457690347405, calc time: 1.3682842254638672 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.945811540045379, calc time: 1.3678808212280273 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.281435339228626, calc time: 1.489349126815796 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.053053098306908, calc time: 1.3666417598724365 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.021448366426296, calc time: 1.367760181427002 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.99010795986195, calc time: 1.4875319004058838 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.5738305701286395, calc time: 1.4696087837219238 secs\n\nFinished iterating in: 310 seconds\n\nBest result:\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.9456653833233166, calc time: 1.4726181030273438 secs"
  },
  {
    "objectID": "convexity.html",
    "href": "convexity.html",
    "title": "Convexity",
    "section": "",
    "text": "import numpy as np\n\n# Define the function\ndef f(x):\n    return x**2\n\n# Define x1, x2 and t\nx1 = 1\nx2 = 3\nt = 0.5  # choose any value in [0, 1]\n\n# Compute the left-hand and right-hand side of the convexity inequality\nlhs = f(t*x1 + (1-t)*x2)\nrhs = t*f(x1) + (1-t)*f(x2)\n\n# Print the results\nprint(f\"Left-hand side: {lhs}\")\nprint(f\"Right-hand side: {rhs}\")\n\n# Check if the inequality holds\nif lhs &lt;= rhs:\n    print(\"The function is convex.\")\nelse:\n    print(\"The function is not convex.\")\n\na = (f(x2) - f(x1)) / (x2 - x1)\n\nb = f(x1) - a*x1\n\nprint(f'y = {a}x + {b}')\n\nLeft-hand side: 4.0\nRight-hand side: 5.0\nThe function is convex.\ny = 4.0x + -3.0\n\n\n\nfrom sympy import *\n\ndef g(x):\n  return 4*x - 3\n\nx = symbols('x')\nf = f(x)\ng = g(x)\n\nplot(f, g, (x, -1, 4))\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x108f1eeb0&gt;"
  }
]