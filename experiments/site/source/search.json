[
  {
    "objectID": "convexity.html",
    "href": "convexity.html",
    "title": "Convexity",
    "section": "",
    "text": "import numpy as np\n\n# Define the function\ndef f(x):\n    return x**2\n\n# Define x1, x2 and t\nx1 = 1\nx2 = 3\nt = 0.5  # choose any value in [0, 1]\n\n# Compute the left-hand and right-hand side of the convexity inequality\nlhs = f(t*x1 + (1-t)*x2)\nrhs = t*f(x1) + (1-t)*f(x2)\n\n# Print the results\nprint(f\"Left-hand side: {lhs}\")\nprint(f\"Right-hand side: {rhs}\")\n\n# Check if the inequality holds\nif lhs &lt;= rhs:\n    print(\"The function is convex.\")\nelse:\n    print(\"The function is not convex.\")\n\na = (f(x2) - f(x1)) / (x2 - x1)\n\nb = f(x1) - a*x1\n\nprint(f'y = {a}x + {b}')\n\nLeft-hand side: 4.0\nRight-hand side: 5.0\nThe function is convex.\ny = 4.0x + -3.0\n\n\n\nfrom sympy import *\n\ndef g(x):\n  return 4*x - 3\n\nx = symbols('x')\nf = f(x)\ng = g(x)\n\nplot(f, g, (x, -1, 4))\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x109f79040&gt;"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Experiments",
    "section": "",
    "text": "This site contains the code experiments for my research on appointment scheduling optimization. Specifically I am working on solution methods for single stage stochastic programming problems (1-SSP) and so-called off-line scheduling system. In an off-line scheduling system all patients that want an appointment in a specific time-frame (e.g. day) are gathered first and then given an appointment time. An example of such a problem is scheduling a number of patients into a series of fixed time slots for a single physician. Each patient will have a certain service time that can not be predicted, but has some known distribution with a mean and variance. If a certain patient needs more time to consult than his time slot the next patient will start later. In case the patient finishes earlier, the doctor has idle time.\nBoth waiting times - for patient and doctor - are undesirable. The question is how to find an optimal schedule that minimizes total waiting times. Weights can be given to both types of waiting times to accommodate for different utilities of saved time for patients and doctors.\nSolution methods for these kinds of problems can be divided into two types: (1) analytical and (2) numerical. Analytical methods applies mathematical principles to a problem in order to obtain provable results. Numerical methods use sets of iterative procedures to find solutions to problems that are hard to solve by analytical methods. A numerical method is considered accurate if it finds: (1) an optimal solution in a given time or (2) a perturbed (or near-optimal) solution with a known deterministic error bound, which is a bound on the solution’s (relative or absolute) optimality gap. An inaccurate method does not produce an error bound and the quality of the solution can not be determined (Ahmadi-Javid, Jalali, and Klassen 2017).\nIdeas:\n\nApply utility function to waiting times -&gt; one minute of waiting is more acceptable than 30 minutes of waiting.\n\n\n\n\n\n\nReferences\n\nAhmadi-Javid, Amir, Zahra Jalali, and Kenneth J Klassen. 2017. “Outpatient Appointment Systems in Healthcare: A Review of Optimization Studies.” European Journal of Operational Research 258 (1): 3–34. https://doi.org/10.1016/j.ejor.2016.06.064."
  },
  {
    "objectID": "sched-sim.html",
    "href": "sched-sim.html",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#setup",
    "href": "sched-sim.html#setup",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#run-simulation-1",
    "href": "sched-sim.html#run-simulation-1",
    "title": "Scheduling Simulation",
    "section": "Run simulation 1",
    "text": "Run simulation 1\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14 \nlns = 5\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], dtype=object) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time= {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time= 3.1223231734403294')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-2",
    "href": "sched-sim.html#run-simulation-2",
    "title": "Scheduling Simulation",
    "section": "Run simulation 2",
    "text": "Run simulation 2\n\nConfigure parameters.\n\n# Configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving silnmlation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n\nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times.\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 11.185811879088888')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-3",
    "href": "sched-sim.html#run-simulation-3",
    "title": "Scheduling Simulation",
    "section": "Run simulation 3",
    "text": "Run simulation 3\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 0, 0, 60, 0, 0, 0, 60, 0, 0, 0]) # inter-arrival times\n\nnsims = nsims # number of simulations\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 22.786011753241198')]"
  },
  {
    "objectID": "schedule-probabilities.html",
    "href": "schedule-probabilities.html",
    "title": "Scheduling w/ Nested Partitions",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \ndef weak_compositions(n, k):\n    if k == 1:\n        return [[n]]\n    compositions = []\n    for i in range(n + 1):\n        for composition in weak_compositions(n - i, k - 1):\n            compositions.append([i] + composition)\n    return compositions\n  \nprint(f'Weak compositions are: {weak_compositions(2, 4)}')\n\n\nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n        \nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\nWeak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for functions defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s):\n            \"\"\"\n            Initialize the class with a schedule of patients and a service time distribution.\n            \n            Args:\n            d (int): An integer representing the time lenght of an interval.\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            s (list): A list of floats representing the probability distribution of service times.\n            \"\"\"\n            \n            self.parameters = dict({'x': x, 'd': d, 's': s})\n            logging.info(f'{datetime.datetime.now()} - x = {self.parameters[\"x\"]}')\n            # Initialize the system dictionary with p_min and p_plus. p_min has one element extra for storing tardiness\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        \n    def calculate_system_states(self, until = 1):\n            \"\"\"\n            Calculate the probabilities of the system being in each state at each time step.\n            \n            Args:\n            until (int): An optional integer representing the state until which to calculate the probabilities.\n            \"\"\"\n            \n            while self.state &lt; until:\n                logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n                \n                \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n                \n                \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n                \n                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n                \n                \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n                The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n                of waiting times of the first patient in state t and the service time distribution. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                     logging.info(f'{datetime.datetime.now()} - Done')\n                     for i in range(1, self.parameters['x'][self.state]):\n                            logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n\n                \n                \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n                the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n                Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal \n                to the distribution of work at the beginning of t. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                \"\"\"Jump to next state\"\"\"\n                self.state += 1\n    \n    def impute_compositions(self, s=0, k=2, omega=0.5):\n      \"\"\"\n      Impute the compositions of patients in a given time interval and establish the schedule with the lowest total waiting time.\n      \n      Args:\n      s (int): An integer representing the starting state.\n      k (int): An integer representing the number of states from the starting state to include in the compositions.\n      \"\"\"\n      logging.info(f'{datetime.datetime.now()} - Running impute_compositions() in state {self.state} with x = {self.parameters[\"x\"]}')\n      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end.\n      t = min(len(self.parameters['x']), s+k)\n      k = t - s\n      c = self.parameters['x'][s:t]\n      n = c.sum()\n      # Calculate initial loss\n      # lowest_wt = self.system[\"ew\"].sum()\n      omega = omega\n      test_wt = self.system[\"ew\"].sum()\n      self.calculate_tardiness()\n      indices = np.arange(self.system['p_min'][-1].size) \n      exp_tard = (indices * self.system['p_min'][-1]).sum()\n      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n      # Generate compositions\n      compositions = weak_compositions(n, k)\n      logging.info(f'{datetime.datetime.now()} - Computing {len(compositions)} compositions')\n      # For all compositions calculate the waiting times\n      for comp in compositions:\n        # Insert composition in x\n        self.parameters['x'][s:t] = comp.copy()\n        # Set starting state\n        self.state = s\n        # Adjust the array for waiting time distributions to new x\n        self.system['w'][s:] = zero_arrays(self.parameters['x'][s:].copy(), len(self.parameters['s']))\n        # Recalculate distributions\n        # If start state is 0 reinitialize p_min, w and p_plus in state 0\n        if(self.state == 0):\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        self.calculate_system_states(until=len(self.parameters['x']))\n        self.calculate_wait_times()\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        # If a composition with a lower waiting time is found, store the system\n        if(test_loss &lt; lowest_loss):\n          lowest_loss = test_loss\n          store_optim['x'] = self.parameters['x'].copy()\n          newsystem = copy.deepcopy(self.system)\n          store_optim['system'] = newsystem\n          store_optim['tot_wt'] = test_wt\n          logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      # Set the system to the stored optimal system\n      self.parameters['x'] = store_optim['x'].copy()\n      self.system['p_min'] = store_optim['system']['p_min']\n      self.system['p_plus'] = store_optim['system']['p_plus']\n      self.system['w'] = store_optim['system']['w']\n      self.system['ew'] = store_optim['system']['ew']\n        \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def search_function(self, k=1, omega=0.5):\n      \"\"\"\n      Slide over the schedule intervals and run inpute_compositions()\n      \"\"\"\n      for i in range(0, len(self.parameters['x'] - k)):\n        self.impute_compositions(s=i, k=k, omega=omega)\n      \n      \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n    # Initialize time counter\n      t = 0\n      # Calculate the expected waiting time for each time step\n      for t, w in enumerate(self.system['w']):\n          ew = 0\n          for i in w:\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(i))\n              b = i\n              wt = np.dot(a, b)\n              ew += wt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][t] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, u=1, print_system=True):\n  file_to_clear = open(\"logs.txt\",'w')\n  file_to_clear.close()\n  schedule = Schedule(x=x, d=d, s=s)\n  schedule.calculate_system_states(until=u)\n  schedule.calculate_wait_times()\n  if(print_system): print(schedule)\n  schedule.search_function(k=3, omega=0.3)\n  return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 4\nsch = run_schedule(x, d, s, u, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\n\nsch = run_schedule(x, d, s, u, False)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = 4\n  \nsch = run_schedule(x, d, s, u, False)\n\n\nsch.visualize_state(2)\n\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n\n                                                \n\n\n\nT = 24 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2 \nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nsch = run_schedule(x, d, s, u, False)\nsch.visualize_system('p_plus')\n\nInitial schedule: [2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1]\n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "noshow.html",
    "href": "noshow.html",
    "title": "No-shows and emergency patients",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\n\nimport numpy as np\n\ndef service_time_with_no_shows(s, q):\n  # \"\"\"\n  # Function to adjust a distribution of service times for no-shows\n  # \n  # Args:\n  #     s (numpy.ndarray): An array with service times.\n  #     q (double): The fraction of no-shows.\n  # \n  # Returns:\n  #     numpy.ndarray: The adjusted array of service times.\n  # \"\"\"\n  \n  s_adj = s * (1-q)\n  s_adj[0] = s_adj[0] + q\n  \n  return(s_adj)\n\ndef add_lists(short_list, long_list):\n    \n    # Extend the short lists to the length of the long list with zeros\n    short_list.extend([0] * (len(long_list) - len(short_list)))\n    \n    # Sum the elements of the two lists element-wise\n    result = [a + b for a, b in zip(short_list, long_list)]\n    \n    return result\n\ndef calculate_rolling_convolution(y, s, limit):\n  conv_list = s\n  v = [x * y[0] for x in conv_list]\n  print(0, v, len(v))\n  for i in range(1, limit):\n    conv_list = np.convolve(conv_list, s)\n    v = add_lists(v, [x * y[i] for x in conv_list])\n    print(i, v, len(v))\n  print(f'conv_list = {conv_list} with sum {sum(conv_list)}, v = {v} with sum {sum(v)}')\n\n\n### TEST ###\n\ns = np.array([0.5, 0.1, 0.4, 0.2])\nq = 0.1\ns_adj = service_time_with_no_shows(s, q)\nprint(s_adj, s_adj.sum())\n\n[0.55 0.09 0.36 0.18] 1.18\n\n\n\n### TEST ###\n\ny = [0.5, 0.3, 0.2]\ns = [0.1, 0.2, 0.7]\nlimit = 3\ncalculate_rolling_convolution(y, s, limit)\n\n0 [0.05, 0.1, 0.35] 3\n1 [0.053000000000000005, 0.112, 0.40399999999999997, 0.08399999999999999, 0.14699999999999996] 5\n2 [0.053200000000000004, 0.11320000000000001, 0.41059999999999997, 0.10239999999999999, 0.19319999999999996, 0.0588, 0.06859999999999998] 7\nconv_list = [0.001 0.006 0.033 0.092 0.231 0.294 0.343] with sum 1.0, v = [0.053200000000000004, 0.11320000000000001, 0.41059999999999997, 0.10239999999999999, 0.19319999999999996, 0.0588, 0.06859999999999998] with sum 0.9999999999999999\n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "sim-based-opt.html",
    "href": "sim-based-opt.html",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#setup",
    "href": "sim-based-opt.html#setup",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#run-simulations",
    "href": "sim-based-opt.html#run-simulations",
    "title": "Simulation Based Optimization",
    "section": "Run simulations",
    "text": "Run simulations\n\n# Simulation 1\n\ntic = time.time()\nsim = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nN = len(iats) # number of patients\n# T = len(sim) # number of intervals\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimreswt = []\nsimresln = 0\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = loss = 0.5 * mwt + 0.5 * mln\ntoc = time.time()\nprint(toc - tic)\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\n1.6246871948242188\n\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 1 1 1 1 1 1 1], mwt: 1.6241629404913747, mln: 1.9739231955328602, loss: 1.7990430680121174')\n\n\n\n\n\n\n\n\n\n# Simulation 2\n\nsim = np.array([2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [2 0 1 1 1 1 1 1 1 1 1 1], mwt: 2.2092174062748975, mln: 1.970680703741858, loss: 2.0899490550083777')\n\n\n\n\n\n\n\n\n\n# Simulation 3\n\nsim = np.array([1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 2 0 1 1 1 1 1 1 1], mwt: 2.2995420557461466, mln: 1.9641366872322303, loss: 2.1318393714891886')\n\n\n\n\n\n\n\n\n\n# Simulation 4\n\nsim = np.array([1, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 2 0 1 1 1 1 1], mwt: 2.3065832934319994, mln: 1.9510318487658247, loss: 2.1288075710989123')"
  },
  {
    "objectID": "search-function.html",
    "href": "search-function.html",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#setup",
    "href": "search-function.html#setup",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#run-simulations-and-search",
    "href": "search-function.html#run-simulations-and-search",
    "title": "Search Function",
    "section": "Run simulations and search",
    "text": "Run simulations and search\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 30\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 8 patients and 12 timeslots.\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 20 20 20 20 20 10],\niats_diff: [  0  20   0   0   0   0 -10],\nloss = 3.6496175282016967, calc time: 1.3126139640808105 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 20 20 20 20 20 10  0],\niats_diff: [ 20   0   0   0   0 -10 -10],\nloss = 7.2424848778894955, calc time: 1.303192138671875 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 10 30 20 20 20 10],\niats_diff: [  0  10  20 -10   0   0 -10],\nloss = 4.01001613077692, calc time: 1.2890598773956299 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 20 10 30 20 20 10],\niats_diff: [  0  20 -10  20 -10   0 -10],\nloss = 3.881506381761284, calc time: 1.3108501434326172 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 20 20 10 30 20 10],\niats_diff: [  0  20   0 -10  20 -10 -10],\nloss = 3.8162676180305555, calc time: 1.296860933303833 secs\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 20 20 20 10 30 10],\niats_diff: [  0  20   0   0 -10  20 -20],\nloss = 3.754006926836283, calc time: 1.2976408004760742 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 0 1 1 0 1] with loss: 3.0370882641932937\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 20 20 20 20 10 20],\niats_diff: [  0  20   0   0   0 -10  10],\nloss = 3.0370882641932937, calc time: 1.3108618259429932 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 1 0 2],\niats: [ 0 20 20 20 20 10 20  0],\niats_diff: [ 20   0   0   0 -10  10 -20],\nloss = 6.282881265968765, calc time: 1.3050861358642578 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 10 30 20 20 10 20],\niats_diff: [  0  10  20 -10   0 -10  10],\nloss = 3.3970213566285024, calc time: 1.2981879711151123 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 1 0 1],\niats: [ 0  0 20 10 30 20 10 20],\niats_diff: [  0  20 -10  20 -10 -10  10],\nloss = 3.2664132085068687, calc time: 1.3401432037353516 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 1 0 1],\niats: [ 0  0 20 20 10 30 10 20],\niats_diff: [  0  20   0 -10  20 -20  10],\nloss = 3.189259880270897, calc time: 1.3112130165100098 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 1 0 1 0 1] with loss: 2.899245746929612\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 20 20 20 10 20 20],\niats_diff: [  0  20   0   0 -10  10   0],\nloss = 2.899245746929612, calc time: 1.3043599128723145 secs\n\nschedule: [1 0 1 0 1 0 1 1 0 1 0 2],\niats: [ 0 20 20 20 10 20 20  0],\niats_diff: [ 20   0   0 -10  10   0 -20],\nloss = 6.0445899200291855, calc time: 1.2893881797790527 secs\n\nschedule: [2 1 0 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 10 30 20 10 20 20],\niats_diff: [  0  10  20 -10 -10  10   0],\nloss = 3.258056236701294, calc time: 1.337449073791504 secs\n\nschedule: [2 0 1 1 0 0 1 1 0 1 0 1],\niats: [ 0  0 20 10 30 10 20 20],\niats_diff: [  0  20 -10  20 -20  10   0],\nloss = 3.120409498676315, calc time: 1.2943987846374512 secs\n\n\n#### Found better schedule: [2 0 1 0 1 1 0 1 0 1 0 1] with loss: 2.8895784035774597\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.8895784035774597, calc time: 1.30218505859375 secs\n\nschedule: [1 0 1 0 1 1 0 1 0 1 0 2],\niats: [ 0 20 20 10 20 20 20  0],\niats_diff: [ 20   0 -10  10   0   0 -20],\nloss = 5.9766476501053205, calc time: 1.3075520992279053 secs\n\nschedule: [2 1 0 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 10 30 10 20 20 20],\niats_diff: [  0  10  20 -20  10   0   0],\nloss = 3.243375328207678, calc time: 1.321418046951294 secs\n\nschedule: [2 0 1 1 0 1 0 1 0 1 0 1],\niats: [ 0  0 20 10 20 20 20 20],\niats_diff: [  0  20 -10  10   0   0   0],\nloss = 2.9864567302642047, calc time: 1.324436902999878 secs\n\nschedule: [2 0 1 0 2 0 0 1 0 1 0 1],\niats: [ 0  0 20 20  0 30 20 20],\niats_diff: [  0  20   0 -20  30 -10   0],\nloss = 3.302480638545115, calc time: 1.2905769348144531 secs\n\nschedule: [2 0 1 0 1 1 1 0 0 1 0 1],\niats: [ 0  0 20 20 10 10 30 20],\niats_diff: [  0  20   0 -10   0  20 -10],\nloss = 3.120295946628384, calc time: 1.3160300254821777 secs\n\nschedule: [2 0 1 0 1 1 0 1 1 0 0 1],\niats: [ 0  0 20 20 10 20 10 30],\niats_diff: [  0  20   0 -10  10 -10  20],\nloss = 3.0033538966382434, calc time: 1.3435819149017334 secs\n\nschedule: [2 0 1 0 1 1 0 1 0 1 1 0],\niats: [ 0  0 20 20 10 20 20 10],\niats_diff: [  0  20   0 -10  10   0 -10],\nloss = 4.026720638673287, calc time: 1.3206329345703125 secs\n\nFinished iterating in: 34 seconds\n\nBest result:\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.8895784035774597, calc time: 1.2813541889190674 secs\n\n\n\n\ndef distribute_elements(n, t):\n    quotient, remainder = divmod(t, n-1)\n    elements = np.zeros(t)\n    for i in range(n-1):\n        elements[i * quotient] = 1\n    elements[0] = elements[0] + 1\n    return elements\n  \n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 20 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 24 # number of intervals\nN = 9 # number of patients\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = distribute_elements(N, T)\nsim = sim.astype(int) # initial schedule\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\n\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 300\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 9 patients and 24 timeslots.\nGenerated new psm\n\nschedule: [2 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0],\niats: [ 0  0 30 30 30 30 30 30 30],\niats_diff: [ 0 30  0  0  0  0  0  0],\nloss = 5.090776049565977, calc time: 1.413287878036499 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1] with loss: 4.47196676299962\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 30 30 20],\niats_diff: [ 30   0   0   0   0   0   0 -10],\nloss = 4.47196676299962, calc time: 1.3591718673706055 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 2],\niats: [30 30 30 30 30 30 30 20  0],\niats_diff: [  0   0   0   0   0   0 -10 -20],\nloss = 12.128866057226219, calc time: 1.341660737991333 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 20 40 30 30 30 30 30 20],\niats_diff: [ 20  20 -10   0   0   0   0 -10],\nloss = 4.542985863243612, calc time: 1.348600149154663 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 20 40 30 30 30 30 20],\niats_diff: [ 30 -10  20 -10   0   0   0 -10],\nloss = 4.5466012559249265, calc time: 1.4092848300933838 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 20 40 30 30 30 20],\niats_diff: [ 30   0 -10  20 -10   0   0 -10],\nloss = 4.5462494446182635, calc time: 1.382641077041626 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 20 40 30 30 20],\niats_diff: [ 30   0   0 -10  20 -10   0 -10],\nloss = 4.545842896770356, calc time: 1.3634841442108154 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 20 40 30 20],\niats_diff: [ 30   0   0   0 -10  20 -10 -10],\nloss = 4.544278743213078, calc time: 1.3685357570648193 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 20 40 20],\niats_diff: [ 30   0   0   0   0 -10  20 -20],\nloss = 4.5274732971388705, calc time: 1.396941900253296 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1] with loss: 3.9955897564415173\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 30 20 30],\niats_diff: [ 30   0   0   0   0   0 -10  10],\nloss = 3.9955897564415173, calc time: 1.369607925415039 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 2],\niats: [30 30 30 30 30 30 20 30  0],\niats_diff: [  0   0   0   0   0 -10  10 -30],\nloss = 11.478839309991452, calc time: 1.3640120029449463 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 30 20 30],\niats_diff: [ 20  20 -10   0   0   0 -10  10],\nloss = 4.066608153278085, calc time: 1.3538289070129395 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 30 20 30],\niats_diff: [ 30 -10  20 -10   0   0 -10  10],\nloss = 4.070223137549635, calc time: 1.4080841541290283 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 30 20 30],\niats_diff: [ 30   0 -10  20 -10   0 -10  10],\nloss = 4.069856207872398, calc time: 1.3755569458007812 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 30 20 30],\niats_diff: [ 30   0   0 -10  20 -10 -10  10],\nloss = 4.069101956222394, calc time: 1.3648288249969482 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 40 20 30],\niats_diff: [ 30   0   0   0 -10  20 -20  10],\nloss = 4.0645853472091735, calc time: 1.3900501728057861 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1] with loss: 3.940318058855623\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 20 30 30],\niats_diff: [ 30   0   0   0   0 -10  10   0],\nloss = 3.940318058855623, calc time: 1.3833320140838623 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 30 20 30 30  0],\niats_diff: [  0   0   0   0 -10  10   0 -30],\nloss = 11.405885130761698, calc time: 1.3498449325561523 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 20 30 30],\niats_diff: [ 20  20 -10   0   0 -10  10   0],\nloss = 4.011326785372078, calc time: 1.3592000007629395 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 20 30 30],\niats_diff: [ 30 -10  20 -10   0 -10  10   0],\nloss = 4.014932840098152, calc time: 1.365725040435791 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 20 30 30],\niats_diff: [ 30   0 -10  20 -10 -10  10   0],\nloss = 4.01439334680429, calc time: 1.3779618740081787 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 20 30 30],\niats_diff: [ 30   0   0 -10  20 -20  10   0],\nloss = 4.011701321114751, calc time: 1.3615190982818604 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9338321018457263\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 30 30 30],\niats_diff: [ 30   0   0   0 -10  10   0   0],\nloss = 3.9338321018457263, calc time: 1.3829586505889893 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 20 30 30 30  0],\niats_diff: [  0   0   0 -10  10   0   0 -30],\nloss = 11.395519713900011, calc time: 1.3581087589263916 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 20 30 30 30],\niats_diff: [ 20  20 -10   0 -10  10   0   0],\nloss = 4.004809461825142, calc time: 1.3869712352752686 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 20 30 30 30],\niats_diff: [ 30 -10  20 -10 -10  10   0   0],\nloss = 4.008246842163091, calc time: 1.351975917816162 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 20 30 30 30],\niats_diff: [ 30   0 -10  20 -20  10   0   0],\nloss = 4.005667573723645, calc time: 1.3717577457427979 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.932662057069036\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3780529499053955 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3655250072479248 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.378288745880127 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3598239421844482 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3740758895874023 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3741111755371094 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.386667013168335 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3790199756622314 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3571879863739014 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.369610071182251 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3613648414611816 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3525917530059814 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3930151462554932 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3688011169433594 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3700721263885498 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.334745168685913 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3709690570831299 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3554837703704834 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3843309879302979 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.345216989517212 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3618910312652588 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3414452075958252 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3565969467163086 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3564140796661377 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3602309226989746 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3552699089050293 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3758320808410645 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.5420329570770264 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3791370391845703 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3633296489715576 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3591117858886719 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.343343734741211 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3573367595672607 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3653450012207031 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3563978672027588 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3527190685272217 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3582689762115479 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3549280166625977 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.377336025238037 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3604497909545898 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.406045913696289 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3375990390777588 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3676338195800781 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3854331970214844 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3762428760528564 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3399899005889893 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.374791145324707 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3701550960540771 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3588461875915527 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.376215934753418 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.47214674949646 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3752009868621826 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3964030742645264 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3946070671081543 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3720629215240479 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3737578392028809 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3969111442565918 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3767061233520508 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.4860310554504395 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3850440979003906 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.364612102508545 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3511459827423096 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.4011471271514893 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3674070835113525 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.4431891441345215 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.377161979675293 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3715739250183105 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3494610786437988 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3576209545135498 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3523731231689453 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.4088928699493408 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3777821063995361 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3849451541900635 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.364131212234497 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.374197006225586 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3561270236968994 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3613839149475098 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3525981903076172 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3417532444000244 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3512330055236816 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3540050983428955 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.350271224975586 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.386815071105957 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3884291648864746 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3818778991699219 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3650691509246826 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3497281074523926 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3567230701446533 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3638529777526855 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3626060485839844 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3470818996429443 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3504912853240967 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3801579475402832 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.391115665435791 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3769440650939941 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.350963830947876 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3593578338623047 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3560960292816162 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3595738410949707 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.381350040435791 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3631360530853271 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.350080966949463 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3687412738800049 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3620710372924805 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.37015700340271 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3752639293670654 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3468029499053955 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3649048805236816 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.343299150466919 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3749990463256836 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3632850646972656 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.345207929611206 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3743572235107422 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3577659130096436 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.4134199619293213 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3933298587799072 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.4098892211914062 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.371802806854248 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.372168779373169 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3721461296081543 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3589088916778564 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3471510410308838 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3735089302062988 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3618412017822266 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3632240295410156 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3720510005950928 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3794710636138916 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.4072997570037842 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3560607433319092 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3524069786071777 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3702609539031982 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3539319038391113 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3814952373504639 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.372291088104248 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.392341136932373 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3639960289001465 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3566808700561523 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3774137496948242 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.408639907836914 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3442091941833496 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3622701168060303 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3586671352386475 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3980739116668701 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3985679149627686 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3861281871795654 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3425030708312988 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.4097447395324707 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3703489303588867 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3514752388000488 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3750948905944824 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3579800128936768 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3376266956329346 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3502027988433838 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.3504748344421387 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.3663809299468994 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3323450088500977 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3572301864624023 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3735158443450928 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.366189956665039 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.3750810623168945 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3880577087402344 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.343487024307251 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3658418655395508 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.411207914352417 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.5383391380310059 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.4806511402130127 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.4557030200958252 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.4469032287597656 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.5321321487426758 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.487894058227539 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.4704060554504395 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.4011309146881104 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.4572761058807373 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.4124388694763184 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.404317855834961 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.3788909912109375 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.426361083984375 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.4653968811035156 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.5103092193603516 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.4386181831359863 secs\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.432237148284912 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.39429864020982, calc time: 1.3835787773132324 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.0033632762088, calc time: 1.3875541687011719 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.004941560773591, calc time: 1.4362070560455322 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.9327844176879427, calc time: 1.4170279502868652 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 10 40 30 30 30],\niats_diff: [ 30   0   0 -20  30 -10   0   0],\nloss = 4.2689305071905865, calc time: 1.364159107208252 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 20 40 30 30],\niats_diff: [ 30   0   0 -10   0  20 -10   0],\nloss = 4.040562360495525, calc time: 1.3689448833465576 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 20 40 30],\niats_diff: [ 30   0   0 -10  10 -10  20 -10],\nloss = 4.008191456419132, calc time: 1.3826889991760254 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 30 30 30 20 30 30 20 40],\niats_diff: [ 30   0   0 -10  10   0 -10  20],\nloss = 3.97418834184477, calc time: 1.3846709728240967 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 30 30 30 20 30 30 30 20],\niats_diff: [ 30   0   0 -10  10   0   0 -10],\nloss = 4.562800299372071, calc time: 1.4028360843658447 secs\n\nFinished iterating in: 306 seconds\n\nBest result:\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.932662057069036, calc time: 1.3781869411468506 secs"
  }
]