[
  {
    "objectID": "local-search-schedule-probabilities.html",
    "href": "local-search-schedule-probabilities.html",
    "title": "Scheduling w/ Local Search",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \ndef weak_compositions(n, k):\n    if k == 1:\n        return [[n]]\n    compositions = []\n    for i in range(n + 1):\n        for composition in weak_compositions(n - i, k - 1):\n            compositions.append([i] + composition)\n    return compositions\n  \nprint(f'Weak compositions are: {weak_compositions(2, 4)}')\n\n\nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n        \nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)\n    \ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]\n  \ndef get_v_star(t):\n    # Create an initial vector 'u' of zeros with length 't'\n    u = np.zeros(t)\n    # Set the first element of vector 'u' to -1\n    u[0] = -1\n    # Set the last element of vector 'u' to 1\n    u[-1] = 1\n    # Initialize the list 'v_star' with the initial vector 'u'\n    v_star = [u]\n    # Loop over the length of 'u' minus one times\n    for i in range(len(u) - 1):\n        # Append the last element of 'u' to the front of 'u'\n        u = np.append(u[-1], u)\n        # Remove the last element of 'u' to maintain the same length\n        u = np.delete(u, -1)\n        # Append the updated vector 'u' to the list 'v_star'\n        v_star.append(u)\n    # Convert the list of vectors 'v_star' into a NumPy array and return it\n    return(np.array(v_star))\n\n# Example of function call:\n# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row\n\ndef generate_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  print(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}\n  # 'ids' will be a list of tuples, where each tuple is a subset of indices\n  ids = list(powerset(range(T)))\n\n  # Select the vectors from 'v_star' that correspond to the indices in each subset\n  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\n  sub_sets = [v_star[i] for i in ids]\n\n  # Sum the vectors within each subset and flatten the result to get a 1-D array\n  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\n  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n  \n  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  print(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.001s\n\nOK\n\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\nWeak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for functions defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s):\n            \"\"\"\n            Initialize the class with a schedule of patients and a service time distribution.\n            \n            Args:\n            d (int): An integer representing the time lenght of an interval.\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            s (list): A list of floats representing the probability distribution of service times.\n            \"\"\"\n            \n            self.parameters = dict({'x': x, 'd': d, 's': s})\n            logging.info(f'{datetime.datetime.now()} - x = {self.parameters[\"x\"]}')\n            # Initialize the system dictionary with p_min and p_plus. p_min has one element extra for storing tardiness\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        \n    def calculate_system_states(self, until = 1):\n            \"\"\"\n            Calculate the probabilities of the system being in each state at each time step.\n            \n            Args:\n            until (int): An optional integer representing the state until which to calculate the probabilities.\n            \"\"\"\n            \n            while self.state &lt; until:\n                logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n                \n                \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n                \n                \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n                \n                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n                \n                \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n                The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n                of waiting times of the first patient in state t and the service time distribution. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                     logging.info(f'{datetime.datetime.now()} - Done')\n                     for i in range(1, self.parameters['x'][self.state]):\n                            logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n\n                \n                \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n                the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n                Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal \n                to the distribution of work at the beginning of t. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                \"\"\"Jump to next state\"\"\"\n                self.state += 1\n                \n    def local_search(self):\n      \"\"\"\n      Generate for a given schedule a local search environment, establish for each schedule in the environment the lowest total waiting time, if a schedule with a lower waiting time is found, use this schedule to generate a new local environment and search this environment for lower waiting times. When a local environment contains no schedules with lower waiting stop searching.  \n      \"\"\"\n      \n      # Establish search environment\n      obj_value = self.system[\"ew\"].sum()\n    \n      # Keep track of the best solution found\n      best_solution = copy.deepcopy(parameters['x'])\n    \n      # Continue the search until no improvement is found\n      while True:  # Start an outer loop that will continue until explicitly broken\n          nh = generate_search_neighborhood(best_solution)  # Generate a new neighborhood\n          improved = False  # Flag to check if an improvement was found in the inner loop\n          \n          for y in nh:  # Inner loop to search through the neighborhood\n              c = obj_function(y)\n              if c &lt; obj_value:\n                  obj_value = c\n                  best_solution = y.copy()\n                  print(f'Found better schedule {best_solution} with objective value {obj_value}')\n                  improved = True  # Set the flag because an improvement was found\n                  break  # Exit the inner loop to generate a new neighborhood\n          \n          if not improved:  # If no improvement was found in the inner loop\n              break  # Exit the outer loop - the search is complete\n  \n      return best_solution, obj_value\n      \n      \n    \n    def impute_compositions(self, s=0, k=2, omega=0.5):\n      \"\"\"\n      Impute the compositions of patients in a given time interval and establish the schedule with the lowest total waiting time.\n      \n      Args:\n      s (int): An integer representing the starting state.\n      k (int): An integer representing the number of states from the starting state to include in the compositions.\n      \"\"\"\n      logging.info(f'{datetime.datetime.now()} - Running impute_compositions() in state {self.state} with x = {self.parameters[\"x\"]}')\n      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end.\n      t = min(len(self.parameters['x']), s+k)\n      k = t - s\n      c = self.parameters['x'][s:t]\n      n = c.sum()\n      # Calculate initial loss\n      test_wt = self.system[\"ew\"].sum()\n      self.calculate_tardiness()\n      indices = np.arange(self.system['p_min'][-1].size) \n      exp_tard = (indices * self.system['p_min'][-1]).sum()\n      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n      # Generate compositions\n      compositions = weak_compositions(n, k)\n      logging.info(f'{datetime.datetime.now()} - Computing {len(compositions)} compositions')\n      # For all compositions calculate the waiting times\n      for comp in compositions:\n        # Insert composition in x\n        self.parameters['x'][s:t] = comp.copy()\n        # Set starting state\n        self.state = s\n        # Adjust the array for waiting time distributions to new x\n        self.system['w'][s:] = zero_arrays(self.parameters['x'][s:].copy(), len(self.parameters['s']))\n        # Recalculate distributions\n        # If start state is 0 reinitialize p_min, w and p_plus in state 0\n        if(self.state == 0):\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        self.calculate_system_states(until=len(self.parameters['x']))\n        self.calculate_wait_times()\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        # If a composition with a lower waiting time is found, store the system\n        if(test_loss &lt; lowest_loss):\n          lowest_loss = test_loss\n          store_optim['x'] = self.parameters['x'].copy()\n          newsystem = copy.deepcopy(self.system)\n          store_optim['system'] = newsystem\n          store_optim['tot_wt'] = test_wt\n          logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      # Set the system to the stored optimal system\n      self.parameters['x'] = store_optim['x'].copy()\n      self.system['p_min'] = store_optim['system']['p_min']\n      self.system['p_plus'] = store_optim['system']['p_plus']\n      self.system['w'] = store_optim['system']['w']\n      self.system['ew'] = store_optim['system']['ew']\n        \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def search_function(self, k=1, omega=0.5):\n      \"\"\"\n      Slide over the schedule intervals and run inpute_compositions()\n      \"\"\"\n      for i in range(0, len(self.parameters['x'] - k)):\n        self.impute_compositions(s=i, k=k, omega=omega)\n      \n      \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n    # Initialize time counter\n      t = 0\n      # Calculate the expected waiting time for each time step\n      for t, w in enumerate(self.system['w']):\n          ew = 0\n          for i in w:\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(i))\n              b = i\n              wt = np.dot(a, b)\n              ew += wt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][t] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.search_function(k=3, omega=omega)\n    return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 5\nomega = 0.5\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = len(x)\nomega = 1\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = len(x)\nomega = 0\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3  \nsch = run_schedule(x, d, s, u, omega, False)\n\n\nsch.visualize_state(2)\n\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n\n                                                \n\n\n\nT = 24 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2 \nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_plus')\n\nInitial schedule: [2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1]\n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "local-search-function.html",
    "href": "local-search-function.html",
    "title": "Local Search Function",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nfrom scipy.special import comb\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nfrom itertools import chain, combinations\nimport copy\n\nSchedule \\(x\\) is a vector with each element representing the number of scheduled patients.\n\n#x = [2, 1, 0, 2]\nx = [2, 0, 0, 0, 2]\n\nThe number of possible schedules is\n\\[\\dbinom{N+T-1}{N}\\]\n\nN = sum(x)\nT = len(x)\nresult = comb(N + T - 1, N, exact=True)  # exact=True returns the exact integer\nprint(result) \n\n70\n\n\n\ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return [list(item) for item in chain.from_iterable(combinations(s, r) for r in range(len(s)+1))]\n\n\ntest = powerset([1,2,3])\nlist(test)\n\n[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n\nDefine the vectors\n\\[\n\\left\\{\n\\begin{array}{c}\n\\vec{u_1}, \\\\\n\\vec{u_2}, \\\\\n\\vec{u_3}, \\\\\n\\vdots \\\\\n\\vec{u_{T-1}}, \\\\\n\\vec{u_T} \\\\\n\\end{array}\n\\right\\} =\n\\left\\{\n\\begin{array}{c}\n(-1, 0,...., 0, 1), \\\\\n(1, -1, 0,...., 0), \\\\\n(0, 1, -1,...., 0), \\\\\n\\vdots \\\\\n(0,...., 1, -1, 0), \\\\\n(0,...., 0, 1, -1) \\\\\n\\end{array}\n\\right\\}\n\\] and take \\(V^* = \\{u_1,....,u_T\\}\\).\n\ndef get_v_star(t):\n    # Create an initial vector 'u' of zeros with length 't'\n    u = np.zeros(t)\n    # Set the first element of vector 'u' to -1\n    u[0] = -1\n    # Set the last element of vector 'u' to 1\n    u[-1] = 1\n    # Initialize the list 'v_star' with the initial vector 'u'\n    v_star = [u]\n    # Loop over the length of 'u' minus one times\n    for i in range(len(u) - 1):\n        # Append the last element of 'u' to the front of 'u'\n        u = np.append(u[-1], u)\n        # Remove the last element of 'u' to maintain the same length\n        u = np.delete(u, -1)\n        # Append the updated vector 'u' to the list 'v_star'\n        v_star.append(u)\n    # Convert the list of vectors 'v_star' into a NumPy array and return it\n    return(np.array(v_star))\n\n# Example of function call:\n# This will create a 4x4 matrix where each row is a cyclically shifted version of the first row\nget_v_star(4)\n\narray([[-1.,  0.,  0.,  1.],\n       [ 1., -1.,  0.,  0.],\n       [ 0.,  1., -1.,  0.],\n       [ 0.,  0.,  1., -1.]])\n\n\nAs the neighborhood of schedule \\(x\\) we take all vectors of the form \\(x + v_1+..+v_k\\) with \\(v_1,....,v_k \\in V^*\\)\n\n# Set the value of 't'\nt = len(x)\n\n# Generate a matrix 'v_star' using the 'get_v_star' function\nv_star = get_v_star(t)\n\n# Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., t-1}\n# 'ids' will be a list of tuples, where each tuple is a subset of indices\nids = list(powerset(range(t)))\n\n# Select the vectors from 'v_star' that correspond to the indices in each subset\n# 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\nsub_sets = [v_star[i] for i in ids]\n\n# Sum the vectors within each subset and flatten the result to get a 1-D array\n# 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\nsummed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n\n# 'summed_sets' is the final output\nsummed_sets\n\n[array([0., 0., 0., 0., 0.]),\n array([-1.,  0.,  0.,  0.,  1.]),\n array([ 1., -1.,  0.,  0.,  0.]),\n array([ 0.,  1., -1.,  0.,  0.]),\n array([ 0.,  0.,  1., -1.,  0.]),\n array([ 0.,  0.,  0.,  1., -1.]),\n array([ 0., -1.,  0.,  0.,  1.]),\n array([-1.,  1., -1.,  0.,  1.]),\n array([-1.,  0.,  1., -1.,  1.]),\n array([-1.,  0.,  0.,  1.,  0.]),\n array([ 1.,  0., -1.,  0.,  0.]),\n array([ 1., -1.,  1., -1.,  0.]),\n array([ 1., -1.,  0.,  1., -1.]),\n array([ 0.,  1.,  0., -1.,  0.]),\n array([ 0.,  1., -1.,  1., -1.]),\n array([ 0.,  0.,  1.,  0., -1.]),\n array([ 0.,  0., -1.,  0.,  1.]),\n array([ 0., -1.,  1., -1.,  1.]),\n array([ 0., -1.,  0.,  1.,  0.]),\n array([-1.,  1.,  0., -1.,  1.]),\n array([-1.,  1., -1.,  1.,  0.]),\n array([-1.,  0.,  1.,  0.,  0.]),\n array([ 1.,  0.,  0., -1.,  0.]),\n array([ 1.,  0., -1.,  1., -1.]),\n array([ 1., -1.,  1.,  0., -1.]),\n array([ 0.,  1.,  0.,  0., -1.]),\n array([ 0.,  0.,  0., -1.,  1.]),\n array([ 0.,  0., -1.,  1.,  0.]),\n array([ 0., -1.,  1.,  0.,  0.]),\n array([-1.,  1.,  0.,  0.,  0.]),\n array([ 1.,  0.,  0.,  0., -1.]),\n array([0., 0., 0., 0., 0.])]\n\n\n\ny = np.array([x + summed_sets[i] for i in range(len(summed_sets))])\ny\n\narray([[ 2.,  0.,  0.,  0.,  2.],\n       [ 1.,  0.,  0.,  0.,  3.],\n       [ 3., -1.,  0.,  0.,  2.],\n       [ 2.,  1., -1.,  0.,  2.],\n       [ 2.,  0.,  1., -1.,  2.],\n       [ 2.,  0.,  0.,  1.,  1.],\n       [ 2., -1.,  0.,  0.,  3.],\n       [ 1.,  1., -1.,  0.,  3.],\n       [ 1.,  0.,  1., -1.,  3.],\n       [ 1.,  0.,  0.,  1.,  2.],\n       [ 3.,  0., -1.,  0.,  2.],\n       [ 3., -1.,  1., -1.,  2.],\n       [ 3., -1.,  0.,  1.,  1.],\n       [ 2.,  1.,  0., -1.,  2.],\n       [ 2.,  1., -1.,  1.,  1.],\n       [ 2.,  0.,  1.,  0.,  1.],\n       [ 2.,  0., -1.,  0.,  3.],\n       [ 2., -1.,  1., -1.,  3.],\n       [ 2., -1.,  0.,  1.,  2.],\n       [ 1.,  1.,  0., -1.,  3.],\n       [ 1.,  1., -1.,  1.,  2.],\n       [ 1.,  0.,  1.,  0.,  2.],\n       [ 3.,  0.,  0., -1.,  2.],\n       [ 3.,  0., -1.,  1.,  1.],\n       [ 3., -1.,  1.,  0.,  1.],\n       [ 2.,  1.,  0.,  0.,  1.],\n       [ 2.,  0.,  0., -1.,  3.],\n       [ 2.,  0., -1.,  1.,  2.],\n       [ 2., -1.,  1.,  0.,  2.],\n       [ 1.,  1.,  0.,  0.,  2.],\n       [ 3.,  0.,  0.,  0.,  1.],\n       [ 2.,  0.,  0.,  0.,  2.]])\n\n\nsuch that \\(x + v_1+..+v_k \\ge 0\\)\n\nimport numpy as np\n\n# Create a mask for rows with negative values\nmask = ~np.any(y &lt; 0, axis=1)\n\n# Filter out rows with negative values using the mask\nfiltered_y = y[mask]\n\nfiltered_y\n\narray([[2., 0., 0., 0., 2.],\n       [1., 0., 0., 0., 3.],\n       [2., 0., 0., 1., 1.],\n       [1., 0., 0., 1., 2.],\n       [2., 0., 1., 0., 1.],\n       [1., 0., 1., 0., 2.],\n       [2., 1., 0., 0., 1.],\n       [1., 1., 0., 0., 2.],\n       [3., 0., 0., 0., 1.],\n       [2., 0., 0., 0., 2.]])\n\n\nSo the whole neighborhood function becomes.\n\ndef generate_search_neighborhood(schedule):\n  N = sum(schedule)\n  T = len(schedule)\n  print(f'The schedule = {schedule}')\n  \n  # Generate a matrix 'v_star' using the 'get_v_star' function\n  v_star = get_v_star(T)\n  \n  # Generate all possible non-empty subsets (powerset) of the set {0, 1, 2, ..., T-1}\n  # 'ids' will be a list of tuples, where each tuple is a subset of indices\n  ids = list(powerset(range(T)))\n\n  # Select the vectors from 'v_star' that correspond to the indices in each subset\n  # 'sub_sets' will be a list of lists, where each inner list contains vectors from 'v_star'\n  sub_sets = [v_star[i] for i in ids]\n\n  # Sum the vectors within each subset and flatten the result to get a 1-D array\n  # 'summed_sets' will be a list of 1-D numpy arrays, where each array is the sum of vectors\n  summed_sets = [np.sum(sub_sets[i], axis=0).flatten() for i in range(len(sub_sets))]\n  \n  neighborhood = np.array([schedule + summed_sets[i] for i in range(len(summed_sets))])\n  \n  # Create a mask for rows with negative values\n  mask = ~np.any(neighborhood &lt; 0, axis=1)\n\n  # Filter out rows with negative values using the mask\n  filtered_neighborhood = neighborhood[mask]\n  print(f'And the neighborhood is {filtered_neighborhood}')\n  return filtered_neighborhood\n\ntestnh = generate_search_neighborhood(x)\n\nThe schedule = [2, 0, 0, 0, 2]\nAnd the neighborhood is [[2. 0. 0. 0. 2.]\n [1. 0. 0. 0. 3.]\n [2. 0. 0. 1. 1.]\n [1. 0. 0. 1. 2.]\n [2. 0. 1. 0. 1.]\n [1. 0. 1. 0. 2.]\n [2. 1. 0. 0. 1.]\n [1. 1. 0. 0. 2.]\n [3. 0. 0. 0. 1.]\n [2. 0. 0. 0. 2.]]\n\n\nLet the objective function be a simple sum of square.\n\ndef obj_function(x):\n  res = sum(map(lambda i: i * i, x))\n  return res\n\nobj_function(np.array(x))\n\n8\n\n\nThe algorithm for computing an optimal schedule becomes.\n\ndef search_best_solution(x):\n    obj_value = obj_function(x)\n    \n    # Keep track of the best solution found\n    best_solution = x.copy()\n    \n    # Continue the search until no improvement is found\n    while True:  # Start an outer loop that will continue until explicitly broken\n        nh = generate_search_neighborhood(best_solution)  # Generate a new neighborhood\n        improved = False  # Flag to check if an improvement was found in the inner loop\n        \n        for y in nh:  # Inner loop to search through the neighborhood\n            c = obj_function(y)\n            if c &lt; obj_value:\n                obj_value = c\n                best_solution = y.copy()\n                print(f'Found better schedule {best_solution} with objective value {obj_value}')\n                improved = True  # Set the flag because an improvement was found\n                break  # Exit the inner loop to generate a new neighborhood\n        \n        if not improved:  # If no improvement was found in the inner loop\n            break  # Exit the outer loop - the search is complete\n\n    return best_solution, obj_value\n\n# Example usage:\nx = [5, 0, 0, 0, 1]\ninitial_solution = x  # Replace this with your actual initial solution\nbest_solution, best_obj_value = search_best_solution(initial_solution)\nprint(\"Best solution found:\", best_solution)\nprint(\"Objective value of the best solution:\", best_obj_value)\n\nThe schedule = [5, 0, 0, 0, 1]\nAnd the neighborhood is [[5. 0. 0. 0. 1.]\n [4. 0. 0. 0. 2.]\n [5. 0. 0. 1. 0.]\n [4. 0. 0. 1. 1.]\n [5. 0. 1. 0. 0.]\n [4. 0. 1. 0. 1.]\n [5. 1. 0. 0. 0.]\n [4. 1. 0. 0. 1.]\n [6. 0. 0. 0. 0.]\n [5. 0. 0. 0. 1.]]\nFound better schedule [4. 0. 0. 0. 2.] with objective value 20.0\nThe schedule = [4. 0. 0. 0. 2.]\nAnd the neighborhood is [[4. 0. 0. 0. 2.]\n [3. 0. 0. 0. 3.]\n [4. 0. 0. 1. 1.]\n [3. 0. 0. 1. 2.]\n [4. 0. 1. 0. 1.]\n [3. 0. 1. 0. 2.]\n [4. 1. 0. 0. 1.]\n [3. 1. 0. 0. 2.]\n [5. 0. 0. 0. 1.]\n [4. 0. 0. 0. 2.]]\nFound better schedule [3. 0. 0. 0. 3.] with objective value 18.0\nThe schedule = [3. 0. 0. 0. 3.]\nAnd the neighborhood is [[3. 0. 0. 0. 3.]\n [2. 0. 0. 0. 4.]\n [3. 0. 0. 1. 2.]\n [2. 0. 0. 1. 3.]\n [3. 0. 1. 0. 2.]\n [2. 0. 1. 0. 3.]\n [3. 1. 0. 0. 2.]\n [2. 1. 0. 0. 3.]\n [4. 0. 0. 0. 2.]\n [3. 0. 0. 0. 3.]]\nFound better schedule [3. 0. 0. 1. 2.] with objective value 14.0\nThe schedule = [3. 0. 0. 1. 2.]\nAnd the neighborhood is [[3. 0. 0. 1. 2.]\n [2. 0. 0. 1. 3.]\n [3. 0. 1. 0. 2.]\n [3. 0. 0. 2. 1.]\n [2. 0. 1. 0. 3.]\n [2. 0. 0. 2. 2.]\n [3. 1. 0. 0. 2.]\n [3. 0. 1. 1. 1.]\n [2. 1. 0. 0. 3.]\n [2. 0. 1. 1. 2.]\n [4. 0. 0. 0. 2.]\n [3. 1. 0. 1. 1.]\n [3. 0. 0. 0. 3.]\n [2. 1. 0. 1. 2.]\n [4. 0. 0. 1. 1.]\n [3. 0. 0. 1. 2.]]\nFound better schedule [2. 0. 0. 2. 2.] with objective value 12.0\nThe schedule = [2. 0. 0. 2. 2.]\nAnd the neighborhood is [[2. 0. 0. 2. 2.]\n [1. 0. 0. 2. 3.]\n [2. 0. 1. 1. 2.]\n [2. 0. 0. 3. 1.]\n [1. 0. 1. 1. 3.]\n [1. 0. 0. 3. 2.]\n [2. 1. 0. 1. 2.]\n [2. 0. 1. 2. 1.]\n [1. 1. 0. 1. 3.]\n [1. 0. 1. 2. 2.]\n [3. 0. 0. 1. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 0. 1. 3.]\n [1. 1. 0. 2. 2.]\n [3. 0. 0. 2. 1.]\n [2. 0. 0. 2. 2.]]\nFound better schedule [2. 0. 1. 1. 2.] with objective value 10.0\nThe schedule = [2. 0. 1. 1. 2.]\nAnd the neighborhood is [[2. 0. 1. 1. 2.]\n [1. 0. 1. 1. 3.]\n [2. 1. 0. 1. 2.]\n [2. 0. 2. 0. 2.]\n [2. 0. 1. 2. 1.]\n [1. 1. 0. 1. 3.]\n [1. 0. 2. 0. 3.]\n [1. 0. 1. 2. 2.]\n [3. 0. 0. 1. 2.]\n [2. 1. 1. 0. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 2. 1. 1.]\n [2. 0. 0. 1. 3.]\n [1. 1. 1. 0. 3.]\n [1. 1. 0. 2. 2.]\n [1. 0. 2. 1. 2.]\n [3. 0. 1. 0. 2.]\n [3. 0. 0. 2. 1.]\n [2. 1. 1. 1. 1.]\n [2. 0. 1. 0. 3.]\n [2. 0. 0. 2. 2.]\n [1. 1. 1. 1. 2.]\n [3. 0. 1. 1. 1.]\n [2. 0. 1. 1. 2.]]\nFound better schedule [2. 1. 1. 1. 1.] with objective value 8.0\nThe schedule = [2. 1. 1. 1. 1.]\nAnd the neighborhood is [[2. 1. 1. 1. 1.]\n [1. 1. 1. 1. 2.]\n [3. 0. 1. 1. 1.]\n [2. 2. 0. 1. 1.]\n [2. 1. 2. 0. 1.]\n [2. 1. 1. 2. 0.]\n [2. 0. 1. 1. 2.]\n [1. 2. 0. 1. 2.]\n [1. 1. 2. 0. 2.]\n [1. 1. 1. 2. 1.]\n [3. 1. 0. 1. 1.]\n [3. 0. 2. 0. 1.]\n [3. 0. 1. 2. 0.]\n [2. 2. 1. 0. 1.]\n [2. 2. 0. 2. 0.]\n [2. 1. 2. 1. 0.]\n [2. 1. 0. 1. 2.]\n [2. 0. 2. 0. 2.]\n [2. 0. 1. 2. 1.]\n [1. 2. 1. 0. 2.]\n [1. 2. 0. 2. 1.]\n [1. 1. 2. 1. 1.]\n [3. 1. 1. 0. 1.]\n [3. 1. 0. 2. 0.]\n [3. 0. 2. 1. 0.]\n [2. 2. 1. 1. 0.]\n [2. 1. 1. 0. 2.]\n [2. 1. 0. 2. 1.]\n [2. 0. 2. 1. 1.]\n [1. 2. 1. 1. 1.]\n [3. 1. 1. 1. 0.]\n [2. 1. 1. 1. 1.]]\nBest solution found: [2. 1. 1. 1. 1.]\nObjective value of the best solution: 8.0\n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Experiments",
    "section": "",
    "text": "This site contains the code experiments for my research on appointment scheduling optimization. Specifically I am working on solution methods for single stage stochastic programming problems (1-SSP) and so-called off-line scheduling system. In an off-line scheduling system all patients that want an appointment in a specific time-frame (e.g. day) are gathered first and then given an appointment time. An example of such a problem is scheduling a number of patients into a series of fixed time slots for a single physician. Each patient will have a certain service time that can not be predicted, but has some known distribution with a mean and variance. If a certain patient needs more time to consult than his time slot the next patient will start later. In case the patient finishes earlier, the doctor has idle time.\nBoth waiting times - for patient and doctor - are undesirable. The question is how to find an optimal schedule that minimizes total waiting times. Weights can be given to both types of waiting times to accommodate for different utilities of saved time for patients and doctors.\nSolution methods for these kinds of problems can be divided into two types: (1) analytical and (2) numerical. Analytical methods applies mathematical principles to a problem in order to obtain provable results. Numerical methods use sets of iterative procedures to find solutions to problems that are hard to solve by analytical methods. A numerical method is considered accurate if it finds: (1) an optimal solution in a given time or (2) a perturbed (or near-optimal) solution with a known deterministic error bound, which is a bound on the solution’s (relative or absolute) optimality gap. An inaccurate method does not produce an error bound and the quality of the solution can not be determined (Ahmadi-Javid, Jalali, and Klassen 2017).\nIdeas:\n\nApply utility function to waiting times -&gt; one minute of waiting is more acceptable than 30 minutes of waiting.\n\n\n\n\n\n\nReferences\n\nAhmadi-Javid, Amir, Zahra Jalali, and Kenneth J Klassen. 2017. “Outpatient Appointment Systems in Healthcare: A Review of Optimization Studies.” European Journal of Operational Research 258 (1): 3–34. https://doi.org/10.1016/j.ejor.2016.06.064."
  },
  {
    "objectID": "sched-sim.html",
    "href": "sched-sim.html",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#setup",
    "href": "sched-sim.html#setup",
    "title": "Scheduling Simulation",
    "section": "",
    "text": "Load libraries.\n\n## Libraries\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\n\nDefine functions:\n\nlogn_mean_lns(m, s) transforms a mean and standard deviation from a lognormal distribution to parameters for a normal distribution. This is necessary when using the random lognormal sampling function. It uses a normal mean and standard deviation as inputs. However, for our simulation we define a mean and standard deviations from a lognormal distribution:\n\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an array with normal mean and standard deviation\ngenerate_logn_sts(s, n, mu, lns) generates a matrix with service times randomly selected from a lognormal distribution:\n\ns = number of rows\nn = number of columns\nlnm = lognormal mean\nlns = lognormal standard deviation\n\nReturns an s x n matrix with random service times.\ngenerate_client(cts, sts, pct, ns=0) generates one client. A client is represented by a client type and a service time:\n\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\n\nReturns an array with client type and service time (zero when no-show).\nsimulate(iats, cts, sts, pct, ns, logs=False) simulates one schedule:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Used for sampling.\nsts is an array with randomly generated service times. Used for sampling.\npct is an array with distributions for samplling client types.\nns is a fraction of no-shows. When a client is a no-show the service time will be set to zero.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\nsimulate_crn(iats, cts, sts, logs=False) simulates one schedule using common random numbers.:\n\niats is an array with interarrival times for each client\ncts is an array with randomly generated client types. Must have same length as iats.\nsts is an array with randomly generated service times (with zeros for no-shows). Must have same length as iats.\nlogs a boolean flag: should results be printed (True) or not (False)?\n\nReturns an array of waiting times.\ntransform_iats_schedule(iats: list[int], d: int, T: int) transforms a list with inter-arrival times per client to a schedule with clients per time slot.:\n\niats is a list with interarrival times per client as integers\nd is the length of a time slot\nT is the number of intervals in the schedule\n\nReturns an array of number of clients.\ntransform_schedule_iats(schedule: list[int], d: int) transforms a schedule with clients per time slot to a list with inter-arrival times per client :\n\nschedule is a list with number of clients per time slot as integers\nd is the length of a time slot\n\nReturns an array of inter-arrival times.\n\n\n## Functions\n\n### Lognormal mean and lns / see: https://en.wikipedia.org/wiki/Log-normal_distribution\n\ndef logn_mean_lns(lnm, lns):\n  sigma = np.sqrt(np.log(1 + (lns/lnm)**2))\n  mu = np.log(lnm**2 / np.sqrt(lnm**2 + lns**2))\n  return np.array([mu, sigma])\n\n### Random lognormal service times generator\ndef generate_logn_sts(s, n, lnm, lns):\n  sts = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=s * n)\n  return np.reshape(sts, (s, n))\n\n##############\n#### TEST ####\ngenerate_logn_sts(5, 5, 14, 10)\ngenerate_logn_sts(1, 8, 14, 10)\n##############\n\n### Client generator\ndef generate_client(cts, sts, pct, ns=0):\n  ct = np.random.choice(cts, size = 1, p=pct)[0] # generate random client type\n  st = np.random.binomial(n=1, p=1-ns)*np.random.choice(sts, size = 1)[0] # generate random service time / if no-show -&gt; st = 0\n  return np.array([ct, st])\n\n### Simulation\n### ATTENTION: handling of emergency patients has not yet been implemented\n\ndef simulate(iats, cts, sts, pct, ns, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct, st = generate_client(cts, sts, pct, ns) # client type and service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef simulate_crn(iats, cts, sts, logs=False):\n  wt = 0 # initial value waiting time\n  wts = [] # array for saving waiting times\n  for i in range(len(iats)):\n    if(i != 0): # don't calculate waiting time for first client in schedule\n      wt = max(0, tis - iats[i]) # calculate waiting time\n    ct =  cts[i]# client type\n    st =  sts[i]# service time\n    tis = wt + st # calculate time in system\n    wts.append(wt)\n    if(logs): print(iats[i], wt, st, tis, ct)\n  return np.array(wts)\n\ndef transform_iats_schedule(iats: list, d: int, T: int):\n  iats = np.array(iats)\n  ats = np.cumsum(iats)\n  sats = np.arange(d*(T+1),step = d)\n  schedule = np.histogram(ats, bins=sats)\n  return schedule\n\n##############\n#### TEST ####\ntransform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)\n##############\n\ndef transform_schedule_iats(schedule: list, d: int):\n  schedule = np.array(schedule)\n  T = schedule.size\n  sats = np.arange(d*T,step = d)\n  ats = np.repeat(sats, schedule)\n  iats = np.diff(ats)\n  iats = np.insert(iats, 0, ats[0])\n  return iats\n\n##############\n#### TEST ####\nschedule = transform_iats_schedule([0, 0 ,30, 0, 60, 0, 0, 0, 60, 0, 0, 0], d = 15, T = 11)[0]\ntransform_schedule_iats(schedule, d = 15)\n##############\n\narray([ 0,  0, 30,  0, 60,  0,  0,  0, 60,  0,  0,  0])\n\n\nConfigure global simulation parameters.\n\n## Variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # Percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False"
  },
  {
    "objectID": "sched-sim.html#run-simulation-1",
    "href": "sched-sim.html#run-simulation-1",
    "title": "Scheduling Simulation",
    "section": "Run simulation 1",
    "text": "Run simulation 1\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14 \nlns = 5\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15], dtype=object) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time= {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time= 3.1299587190616083')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-2",
    "href": "sched-sim.html#run-simulation-2",
    "title": "Scheduling Simulation",
    "section": "Run simulation 2",
    "text": "Run simulation 2\n\nConfigure parameters.\n\n# Configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15]) # inter-arrival times\nnsims = nsims # number of simulations\nctsm = np.random.choice(cts, size = (nsims * len(iats)), p=pct).reshape((nsims, len(iats))) # client types matrix\nstsm = np.random.lognormal(mean = logn_mean_lns(lnm, lns)[0], sigma=logn_mean_lns(lnm, lns)[1], size=(nsims * len(iats))).reshape((nsims, len(iats))) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = nsims * len(iats)).reshape((nsims, len(iats))) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimres = [] # array for saving silnmlation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n\nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times.\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 11.188288913306442')]"
  },
  {
    "objectID": "sched-sim.html#run-simulation-3",
    "href": "sched-sim.html#run-simulation-3",
    "title": "Scheduling Simulation",
    "section": "Run simulation 3",
    "text": "Run simulation 3\n\nConfigure parameters.\n\n# configure parameters\nlnm = 14\nlns = 10\nsts = generate_logn_sts(1, 1000, lnm, lns)[0] # sampling population for array service times\niats = np.array([0, 0, 0, 0, 60, 0, 0, 0, 60, 0, 0, 0]) # inter-arrival times\n\nnsims = nsims # number of simulations\nsimres = [] # array for saving simulation results\n\nRun simulations.\n\n# run simulations\nfor s in range(nsims):\n  # experiment = simulate(iats, cts, sts, pct, ns, logs=logs)\n  experiment = simulate_crn(iats, ctsm[s], stsm[s], logs=logs)\n  simres.append(experiment.mean())\n  \nmwt = np.array(simres).mean()\n\nPlot histogram of waiting times\n\n# plot histogram of waiting times\nfig = sns.histplot(simres)\nfig.set(title=f\"Mean waiting time = {mwt}\")\n\n[Text(0.5, 1.0, 'Mean waiting time = 22.805628339827134')]"
  },
  {
    "objectID": "schedule-probabilities.html",
    "href": "schedule-probabilities.html",
    "title": "Scheduling w/ Nested Partitions",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nimport logging\nimport copy\nimport datetime\nimport numpy as np\nfrom scipy.stats import poisson\nfrom scipy.stats import lognorm\nfrom scipy import signal\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\nimport unittest\nimport functions as fn\n\nlogging.basicConfig(filename='logs.txt', encoding='utf-8', level=logging.DEBUG)\n\n# \"\"\"\n# Function to calculate the convolution of two arrays.\n# \n# Args:\n#     a (numpy.ndarray): The first array to be convolved.\n#     b (numpy.ndarray): The second array to be convolved.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the two input arrays.\n# \"\"\"\ndef convolve(a, b):\n    \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # Compute the convolution of the two arrays.\n    for i in range(len(a)):\n        # Get subsets of array expanded to the right.\n        a_sub = a[0:i + 1].copy()\n        b_sub = b[0:i + 1].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n    \n    for i in range(1,len(a)):\n        # Get subsets of array collapse from the right.\n        a_sub = a[i:].copy()\n        b_sub = b[i:].copy()\n        # Reverse b.\n        b_rev = b_sub[::-1]\n        # Compute the dot product of a and b_rev.\n        c = np.append(c, np.dot(a_sub, b_rev))\n        \n    return c\n\n\n# \"\"\"\n# Function to convolve a distribution with itself n times.\n# \n# Args:\n#     a (numpy.ndarray): The distribution to be convolved.\n#     n (int): The number of times to convolve the distribution with itself.\n# \n# Returns:\n#     numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\ndef convolve_n(a, n):\n        \n    # Initialize an empty array to store the result.\n    c = np.array([])\n    \n    # If n is 0, return an array of zeros with length equal to the length of a, except for the first element which is 1.\n    if n == 0:\n        c = np.array(np.zeros(len(a)), dtype=np.float64)\n        c[0] = 1\n        return c\n    \n    # Convolve the distribution with itself n times.\n    for i in range(n):\n        # If this is the first iteration, set c equal to a.\n        if i == 0:\n            c = a\n        # Otherwise, convolve c with a.\n        else:\n            c = np.convolve(c, a)\n            \n    return c\n# \n# \"\"\"\n# Function to create an array of zero arrays according to a given shape array.\n# \n# Args:\n#      num_zeros (numpy.ndarray): The shape array.\n#      l (int): The length of the zeros array.\n#  \n# Returns:\n#      numpy.ndarray: The convolution of the input distribution with itself n times.\n# \"\"\"\n\ndef zero_arrays(num_zeros, l):\n    result = []\n    for n in num_zeros:\n        zeros = np.zeros(l)\n        result.append([zeros] * n)\n    return result\n\nprint(f'Zero arrays are: {zero_arrays(np.array([1, 0, 3]), 4)}')\n\ndef calc_distr_limit(l):\n    return int(max(l+4*l**0.5, 100))\n  \ndef weak_compositions(n, k):\n    if k == 1:\n        return [[n]]\n    compositions = []\n    for i in range(n + 1):\n        for composition in weak_compositions(n - i, k - 1):\n            compositions.append([i] + composition)\n    return compositions\n  \nprint(f'Weak compositions are: {weak_compositions(2, 4)}')\n\n\nclass TestConvolve(unittest.TestCase):\n    \n    def test_convolve(self):\n        a = np.array([\n            0.4456796414,\n            0.160623141,\n            0.137676978,\n            0.1032577335])\n\n        b = np.array([\n            0.006737946999,\n            0.033689735,\n            0.08422433749,\n            0.1403738958])\n\n        expected_output = np.convolve(a, b)\n        \n        self.assertTrue(np.allclose(convolve(a, b), expected_output))\n        \nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)\n\n.\n----------------------------------------------------------------------\nRan 1 test in 0.002s\n\nOK\n\n\nZero arrays are: [[array([0., 0., 0., 0.])], [], [array([0., 0., 0., 0.]), array([0., 0., 0., 0.]), array([0., 0., 0., 0.])]]\nWeak compositions are: [[0, 0, 0, 2], [0, 0, 1, 1], [0, 0, 2, 0], [0, 1, 0, 1], [0, 1, 1, 0], [0, 2, 0, 0], [1, 0, 0, 1], [1, 0, 1, 0], [1, 1, 0, 0], [2, 0, 0, 0]]\n\n\nA schedule with \\(T\\) intervals can have \\(T\\) states. A state of a schedule at interval \\(t\\) is defined by:\n- \\(p^-_t(i)\\), the distribution of the amount of work (\\(i\\)) left at the end of the state at interval \\(t-1\\),\n- \\(w_{tk}(i)\\), the distribution of waiting time (\\(i\\)) for a patient \\(k\\) in interval \\(t\\)\n- \\(p^+_t(i)\\), the probability of the total amount of work (\\(i\\)) in interval \\(t\\), ergo: the work left from the previous state plus all work related to arriving patients.\n\\(p^+_t(i)\\) is equal to the convolution of the distribution of waiting times of the last patient with the distribution of his service time. The iteration is as follows with K patients scheduled at interval t:\n\nStep 1: \\(w_{t0}(i) = p^-_t(i)\\) # The first patient has to wait for all the work leftover from the previous interval\n\n\nStep 2: \\(w_{t1}(i) = w_{t0}(i)*s(i)\\) # The next patient has to wait for the previous patient waiting time and service time\n\n\n. . .\n\n\nStep K: \\(p^+_t(i) = w_{t(K-1)}(i)*s(i)\\)\n\nWith \\(s(i)\\) being the distribution of individual service times.\nNB:\nSuggestie Joost:\n\n\\(p_N := \\sum_{i=N}^\\infty p_i\\)\nZoeken op convexity in combinatorial problems / continuous vs discrete\nBewijzen Koole en Kuiper vergelijken\nconvexity for functions defined on discrete spaces (2002)\n\n\n\"\"\"\nA schedule class with a constructor and a method to calculate the system states.\n\"\"\"\nclass Schedule:\n    def __init__(self, x, d, s):\n            \"\"\"\n            Initialize the class with a schedule of patients and a service time distribution.\n            \n            Args:\n            d (int): An integer representing the time lenght of an interval.\n            x (list): A list of integers representing the number of patients scheduled to arrive at each time step.\n            s (list): A list of floats representing the probability distribution of service times.\n            \"\"\"\n            \n            self.parameters = dict({'x': x, 'd': d, 's': s})\n            logging.info(f'{datetime.datetime.now()} - x = {self.parameters[\"x\"]}')\n            # Initialize the system dictionary with p_min and p_plus. p_min has one element extra for storing tardiness\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        \n    def calculate_system_states(self, until = 1):\n            \"\"\"\n            Calculate the probabilities of the system being in each state at each time step.\n            \n            Args:\n            until (int): An optional integer representing the state until which to calculate the probabilities.\n            \"\"\"\n            \n            while self.state &lt; until:\n                logging.info(f'{datetime.datetime.now()} - State = {self.state}')\n                \n                \"\"\"The probability that the amount of work left in the system equals zero just before state t starts is the probablity that the total amount work in state t-1 was less than or equal to the interval length d.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_min in state {self.state}')\n                self.system['p_min'][self.state][0] = np.sum(self.system['p_plus'][self.state-1][:(self.parameters['d'] + 1)])\n                \n                \"\"\"The probability that the amount of work left in the system equals i just before state t starts is the probablity that the total amount work in state t-1 exceeded the interval length d with amount i.\"\"\"\n                \n                self.system['p_min'][self.state][1:(-1*self.parameters['d'])] = self.system['p_plus'][self.state-1][(self.parameters['d'] + 1):]\n                \n                \"\"\"The distribution of waiting times of the first patient in state t equals p_min. \n                The distribution of waiting times of the second patient in state t equals the convolution of the distribution \n                of waiting times of the first patient in state t and the service time distribution. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                if(self.parameters['x'][self.state] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][0] in state {self.state}')\n                     self.system['w'][self.state][0] = self.system['p_min'][self.state].copy()\n                     logging.info(f'{datetime.datetime.now()} - Done')\n                     for i in range(1, self.parameters['x'][self.state]):\n                            logging.info(f'{datetime.datetime.now()} - Calculating w[{self.state}][{i}] in state {self.state}')\n                            self.system['w'][self.state][i] = np.convolve(self.system['w'][self.state][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n\n                \n                \"\"\"The probablitity that the amount of work left in the system equals i just before state t ends equals \n                the convolution of the waiting time distribution of the last arriving patient and the service time distribution. \n                Unless there are no patients in the state t. In that case the distribution of total work just before t ends is equal \n                to the distribution of work at the beginning of t. \n                The resulting vector is truncated to the length of the service time distribution.\"\"\"\n                logging.info(f'{datetime.datetime.now()} - Calculating p_plus in state {self.state}')\n                self.system['p_plus'][self.state] = self.system['p_min'][self.state].copy() if self.parameters['x'][self.state] == 0 else np.convolve(self.system['w'][self.state][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n                \"\"\"Jump to next state\"\"\"\n                self.state += 1\n    \n    def impute_compositions(self, s=0, k=2, omega=0.5):\n      \"\"\"\n      Impute the compositions of patients in a given time interval and establish the schedule with the lowest total waiting time.\n      \n      Args:\n      s (int): An integer representing the starting state.\n      k (int): An integer representing the number of states from the starting state to include in the compositions.\n      \"\"\"\n      logging.info(f'{datetime.datetime.now()} - Running impute_compositions() in state {self.state} with x = {self.parameters[\"x\"]}')\n      # Select the subset from the schedule for the compositions. Truncate if subset falls outside of schedule's end.\n      t = min(len(self.parameters['x']), s+k)\n      k = t - s\n      c = self.parameters['x'][s:t]\n      n = c.sum()\n      # Calculate initial loss\n      test_wt = self.system[\"ew\"].sum()\n      self.calculate_tardiness()\n      indices = np.arange(self.system['p_min'][-1].size) \n      exp_tard = (indices * self.system['p_min'][-1]).sum()\n      lowest_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n      store_optim = dict({ 'x' : self.parameters['x'].copy(), 'system' : copy.deepcopy(self.system), 'tot_wt' : test_wt})\n      # Generate compositions\n      compositions = weak_compositions(n, k)\n      logging.info(f'{datetime.datetime.now()} - Computing {len(compositions)} compositions')\n      # For all compositions calculate the waiting times\n      for comp in compositions:\n        # Insert composition in x\n        self.parameters['x'][s:t] = comp.copy()\n        # Set starting state\n        self.state = s\n        # Adjust the array for waiting time distributions to new x\n        self.system['w'][s:] = zero_arrays(self.parameters['x'][s:].copy(), len(self.parameters['s']))\n        # Recalculate distributions\n        # If start state is 0 reinitialize p_min, w and p_plus in state 0\n        if(self.state == 0):\n            self.system = dict({\n                'p_min': np.zeros((len(self.parameters['x']) + 1, len(self.parameters['s'])), dtype=np.float64),\n                'p_plus': np.zeros((len(self.parameters['x']), len(self.parameters['s'])), dtype=np.float64)\n            })\n            # Set the first element of p_min in the initial state to 1.\n            self.system['p_min'][0][0] = 1\n            # Initialize array of arrays for saving waiting times distributions per patient\n            self.system['w'] = zero_arrays(self.parameters['x'].copy(), len(self.parameters['s']))\n            if(self.parameters['x'][0] &gt; 0): # Only calculate waiting times if there are patients scheduled in the state\n                     self.system['w'][0][0] = self.system['p_min'][0].copy()\n                     for i in range(1, self.parameters['x'][0]):\n                            self.system['w'][0][i] = np.convolve(self.system['w'][0][i-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            self.system['p_plus'][0] = self.system['p_min'][0].copy() if self.parameters['x'][0] == 0 else np.convolve(self.system['w'][0][-1], self.parameters['s'])[:(len(self.parameters['s']))]\n            # Initialize array for saving total expected waiting times per state\n            self.system['ew'] = np.zeros(len(self.parameters['x']), dtype=np.float64)\n            # Set the initial state to 1.\n            self.state = 1\n        self.calculate_system_states(until=len(self.parameters['x']))\n        self.calculate_wait_times()\n        test_wt = self.system[\"ew\"].sum()\n        self.calculate_tardiness()\n        indices = np.arange(self.system['p_min'][-1].size) \n        exp_tard = (indices * self.system['p_min'][-1]).sum()\n        test_loss = omega * test_wt / self.parameters['x'].sum() + (1 - omega) * exp_tard\n        # If a composition with a lower waiting time is found, store the system\n        if(test_loss &lt; lowest_loss):\n          lowest_loss = test_loss\n          store_optim['x'] = self.parameters['x'].copy()\n          newsystem = copy.deepcopy(self.system)\n          store_optim['system'] = newsystem\n          store_optim['tot_wt'] = test_wt\n          logging.info(f'{datetime.datetime.now()} - Found lower loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      logging.info(f'{datetime.datetime.now()} - Final result lowest loss = {lowest_loss} with x = {store_optim[\"x\"]} and system = {store_optim[\"system\"]}')\n      # Set the system to the stored optimal system\n      self.parameters['x'] = store_optim['x'].copy()\n      self.system['p_min'] = store_optim['system']['p_min']\n      self.system['p_plus'] = store_optim['system']['p_plus']\n      self.system['w'] = store_optim['system']['w']\n      self.system['ew'] = store_optim['system']['ew']\n        \n    def calculate_tardiness(self):\n      \"\"\"\n      Calculate the tardiness for the current system and add it as the last element to p_min - the distribution of work in interval t just before any patient has arrived. \n      \"\"\"\n      self.system['p_min'][-1][0] = np.sum(self.system['p_plus'][-1][:(self.parameters['d'] + 1)])\n      self.system['p_min'][-1][1:(-1*self.parameters['d'])] = self.system['p_plus'][-1][(self.parameters['d'] + 1):]\n      logging.info(f'{datetime.datetime.now()} - calculating tardiness distribution:  {self.system[\"p_min\"][-1]}')\n      \n    \n    def search_function(self, k=1, omega=0.5):\n      \"\"\"\n      Slide over the schedule intervals and run inpute_compositions()\n      \"\"\"\n      for i in range(0, len(self.parameters['x'] - k)):\n        self.impute_compositions(s=i, k=k, omega=omega)\n      \n      \n    def calculate_wait_times(self):\n      \"\"\"\n      Calculate the expected waiting time for each time step.\n      \"\"\"\n    # Initialize time counter\n      t = 0\n      # Calculate the expected waiting time for each time step\n      for t, w in enumerate(self.system['w']):\n          ew = 0\n          for i in w:\n              # Calculate the weighted sum of the waiting time distribution\n              a = range(len(i))\n              b = i\n              wt = np.dot(a, b)\n              ew += wt\n          # Store the expected waiting time for the current time step\n          self.system['ew'][t] = ew\n        \n        \n    def visualize_state(self, state='', dist='p_plus'):\n        \"\"\"\n        Visualize a distribution in the last given state.\n        \n        Args:\n        state (int): An optional integer representing the state to visualize. If not provided, the current state is used.\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        if state == '':\n            state = self.state\n        trace = go.Scatter(\n            x=list(range(len(self.system[dist][state]))),\n            y=self.system[dist][state],\n            mode='lines'\n        )\n        \n        data = [trace]\n        \n        layout = go.Layout(\n            title=f'{dist} in state {state} with x = {self.parameters[\"x\"]}&lt;br&gt;&lt;sub&gt;AUR = {np.round(np.sum(self.system[dist][state]), 3)}&lt;/sub&gt;',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Probability')\n        )\n        \n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n    \n    def visualize_system(self, dist='p_plus'):\n        l = len(self.parameters[\"x\"])\n        suffix = \"\"\n        if(dist=='p_min'): suffix = f'&lt;br&gt;NB: p_min[{l}] contains tardiness distribution'\n        \"\"\"\n        Visualize a distribution for the entire system.\n        \n        Args:\n        dist (str): An optional string representing the distribution to visualize. Defaults to 'p_plus'.\n        \"\"\"\n        values = self.system[dist]\n        trace = go.Heatmap(\n                    z=values\n                    )\n        data = [trace]\n        layout = go.Layout(\n            title=f'{dist} with x = {self.parameters[\"x\"]}{suffix}',\n            xaxis=dict(title='Time'),\n            yaxis=dict(title='Interval')\n        )\n        fig = go.Figure(data=data, layout=layout)\n        pyo.iplot(fig)\n        \n    def __str__(self):\n        \"\"\"\n        Print all probabilities\n        \"\"\"\n        return(\"p_min = % s \\nw = % s \\np_plus = % s \\new = % s\" % (self.system['p_min'], self.system['w'], self.system['p_plus'], self.system['ew']))\n\nThis Python class, named Schedule, simulates a scheduling system. Itis be used for analyzing a scheduling system that has time intervals with varying numbers of scheduled patients.\nHere’s a breakdown of what happens in the class:\n\nInitialization (__init__): In the initialization function, parameters x, d, s are set which represent the patients scheduled in each interval, the interval length, and the service time distribution, respectively. It also initializes certain elements of the system dictionary such as p_min, p_plus, and w which are used for storing the distributions of work in the system at the start and end of each state and the distributions of waiting times of each patient.\ncalculate_system_states: This function is used to calculate the system states. This involves calculation of the amount of work left in the system just before the start of each state (p_min) and just before the end of each state (p_plus), along with the waiting time distributions of patients (w) using convolution. The until parameter can be used to control until which state the system states should be calculated.\nimpute_compositions: This function changes the scheduling of patients (represented by the array x) for a certain number of intervals (k intervals starting from interval s). All possible ways of distributing a certain number of patients (n) over the intervals are generated (compositions), for each possible distribution the system states are recalculated and the schedule with the lowest total waiting time is established. NB: The system only requires recalculation starting from interval ‘s’, because the schedule has not changed before that that interval.\nsearch_function(k): This function invokes impute_compositions() for different start states to find the optimal schedule with the lowest waiting time.\ncalculate_wait_times: This function calculates the expected waiting times for each interval by adding up the expected waiting times of all tasks in the interval.\nvisualize_state and visualize_system: These functions are used to visualize a certain distribution (p_min, p_plus, or w) for a certain state or for all states in a heat map. The visualization is done using Plotly.\n__str__: This function is used to get a string representation of the schedule instance, which shows the values of the p_min, w, p_plus, and ew arrays.\n\n\ndef run_schedule(x, d, s, u=1, omega=0.3, print_system=True):\n    file_to_clear = open(\"logs.txt\",'w')\n    file_to_clear.close()\n    schedule = Schedule(x=x, d=d, s=s)\n    schedule.calculate_system_states(until=u)\n    schedule.calculate_wait_times()\n    if(print_system): print(schedule)\n    schedule.search_function(k=3, omega=omega)\n    return(schedule)\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = 5\nomega = 0.5\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = len(x)\nomega = 1\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Simple test case\"\"\"\n# clear the data in the info file\n# with open(\"logs.txt\",'w') as file:\n  # pass\nx = np.array([2, 0, 3, 1, 1], dtype=np.int64)\nd = 3\ns=np.array(\n    [0.1, 0.2, 0.3, 0.2, 0.15, 0.05, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.float64)\nindices = np.arange(s.size)\nexp_s = (indices * s).sum()\nprint(f'exp_s = {exp_s}')\nu = len(x)\nomega = 0\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_min')\nsch.visualize_system('p_plus')\n\nexp_s = 2.25\n\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with validation in spreadsheet\nurl: https://docs.google.com/spreadsheets/d/1_l9bMqEfLT2-TpZz3MrDFIid30ZsywTVH8Lzc5uHrGw/edit?usp=sharing\"\"\"\nx = np.array([1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\n\nsch.visualize_system('p_min')\nsch.visualize_state(1, 'p_min')\n\n\n                                                \n\n\n\n                                                \n\n\n\n\"\"\"Test case with more than 1 clients in the system in the same interval\"\"\"\nwith open(\"logs.txt\",'w') as file:\n  pass\nx = np.array([1, 0, 2, 0, 1, 1, 1], dtype=np.int64)\nd = 5\nl = 6\nlimit = calc_distr_limit(l * x.sum())+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = len(x)\nomega = 0.3  \nsch = run_schedule(x, d, s, u, omega, False)\n\n\nsch.visualize_state(2)\n\n\n                                                \n\n\n\nsch.visualize_system(dist='p_min')\n\n\n                                                \n\n\n\nsch.visualize_system('p_plus')\n\n\n                                                \n\n\n\nT = 24 # number of intervals\nx = np.zeros(T) \nt = np.arange(T, step=2)\nx[t] = 1\nx[-1] = 1\nx[0] = 2 \nx = x.astype(int) # initial schedule\nprint(f'Initial schedule: {x}')\nN = np.sum(x)\nd = 10\nl = 20\nlimit = calc_distr_limit(l * N)+1\nservice_times = range(0, limit)\ns = np.array([poisson.pmf(i, l) for i in service_times], dtype=np.float64)\nu = T\nomega = 0.3\nsch = run_schedule(x, d, s, u, omega, False)\nsch.visualize_system('p_plus')\n\nInitial schedule: [2 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 1]\n\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "noshow.html",
    "href": "noshow.html",
    "title": "No-shows and emergency patients",
    "section": "",
    "text": "This code replicates methods from Kaandorp and Koole (2007).\n\nLet the number of arriving emergency patients be \\(Y\\). Then the amount of work arriving is the Y-fold convolution of the vector representing the service time for emergency patients, \\(s_e^{(Y)}\\). In this vector the \\(j\\)th element \\(s_{ej}\\) denotes the probability that the service time of an emergency patient is \\(j\\) minutes. Then the distribution of the amount of emergency work arriving at the start of any interval is given by:\n\\[v_0(i) = \\sum\\limits_{y=1}^{\\infty}s_{ei}^{(Y)}P(Y=y) = \\Big(\\sum\\limits_{y=1}^{\\infty}P(Y=y)s_{e}^{(y)}\\Big)_i\\]\n\nimport numpy as np\nfrom scipy.stats import poisson\nimport plotly.graph_objs as go\nimport plotly.offline as pyo\n\ndef service_time_with_no_shows(s, q):\n  # \"\"\"\n  # Function to adjust a distribution of service times for no-shows\n  # \n  # Args:\n  #     s (numpy.ndarray): An array with service times.\n  #     q (double): The fraction of no-shows.\n  # \n  # Returns:\n  #     numpy.ndarray: The adjusted array of service times.\n  # \"\"\"\n  \n  s_adj = s * (1-q)\n  s_adj[0] = s_adj[0] + q\n  \n  return(s_adj)\n\ndef add_lists(short_list, long_list):\n  # \"\"\"\n  # This function takes in two lists and returns a new list where each element \n  # is the sum of the elements from the input lists at the corresponding position.\n  # If the lists are of different lengths, the shorter list is extended with zeros \n  # to match the length of the longer list.\n  # \n  # Parameters:\n  # - short_list (list): The shorter list of numbers.\n  # - long_list (list): The longer list of numbers.\n  # \n  # Returns:\n  # - list: A list containing the element-wise sum of the two input lists.\n  # \"\"\"\n  \n  # Extend the short lists to the length of the long list with zeros\n  short_list.extend([0] * (len(long_list) - len(short_list)))\n  \n  # Sum the elements of the two lists element-wise\n  result = [a + b for a, b in zip(short_list, long_list)]\n  \n  return result\n\ndef calculate_rolling_convolution(p_y, s, limit):\n  conv_list = s\n  v = [x * p_y[0] for x in conv_list]\n  for i in range(1, limit):\n    conv_list = np.convolve(conv_list, s)\n    v = add_lists(v, [x * p_y[i] for x in conv_list])\n  print(f'conv_list = {conv_list[:10]} (first ten elements) with sum {sum(conv_list)}, v = {v[:10]} with sum {sum(v)}')\n  return(v)\n\n\n### TEST ###\n\ns = np.array([0.0, 0.5, 0.2, 0.3])\nq = 0.1\ns_adj = service_time_with_no_shows(s, q)\nprint(f'adjusted service times={s_adj}, with sum  {s_adj.sum()}')\n\nadjusted service times=[0.1  0.45 0.18 0.27], with sum  1.0\n\n\n\n### TEST 2 ###\n\np_y = [0.5, 0.3, 0.2]\ns = [0.1, 0.2, 0.7]\nlimit = 3\nv = calculate_rolling_convolution(p_y, s, limit)\n\nconv_list = [0.001 0.006 0.033 0.092 0.231 0.294 0.343] (first ten elements) with sum 1.0, v = [0.053200000000000004, 0.11320000000000001, 0.41059999999999997, 0.10239999999999999, 0.19319999999999996, 0.0588, 0.06859999999999998] with sum 0.9999999999999999\n\n\n\ntrace = go.Scatter(\n            x = list(range(len(v))),\n            y = v,\n            mode = 'lines'\n        )\n        \ndata = [trace]\n\nlayout = go.Layout(\n    title = f'distribution of v',\n    xaxis = dict(title='Time'),\n    yaxis = dict(title='Probability')\n)\n\nfig = go.Figure(data=data, layout=layout)\npyo.iplot(fig)\n\n\n                                                \n\n\n\n### TEST 3 ###\n\nlen_y = 300\nlen_se = 300\np_y = [poisson.pmf(i, 2) for i in range(0, len_y)]\nse = [poisson.pmf(j, 10) for j in range(0, len_se)]\nprint(sum(p_y), sum(se))\n\nv = calculate_rolling_convolution(p_y, se, len_y)\n\n0.9999999999999999 1.0000000000000022\nconv_list = [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] (first ten elements) with sum 1.0000000000006708, v = [6.144770272275882e-06, 6.145328216553419e-05, 0.00030732220778848765, 0.0010247793643651344, 0.002563808626256866, 0.0051350592539100804, 0.00858324446168137, 0.01233269472644276, 0.015593252353944275, 0.0177203279998164] with sum 1.0000000000000064\n\n\n\ntrace = go.Scatter(\n            x = list(range(len(v))),\n            y = v[:len_y],\n            mode = 'lines'\n        )\n        \ndata = [trace]\n\nlayout = go.Layout(\n    title = f'distribution of v',\n    xaxis = dict(title='Time'),\n    yaxis = dict(title='Probability')\n)\n\nfig = go.Figure(data=data, layout=layout)\npyo.iplot(fig)\n\n\n                                                \n\n\n\n\n\n\nReferences\n\nKaandorp, Guido C., and Ger Koole. 2007. “Optimal Outpatient Appointment Scheduling.” Health Care Management Science 10 (3): 217–29. https://doi.org/10.1007/s10729-007-9015-x."
  },
  {
    "objectID": "sim-based-opt.html",
    "href": "sim-based-opt.html",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#setup",
    "href": "sim-based-opt.html#setup",
    "title": "Simulation Based Optimization",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\nimport seaborn as sns\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nns = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 15 # interval time\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for array service"
  },
  {
    "objectID": "sim-based-opt.html#run-simulations",
    "href": "sim-based-opt.html#run-simulations",
    "title": "Simulation Based Optimization",
    "section": "Run simulations",
    "text": "Run simulations\n\n# Simulation 1\n\ntic = time.time()\nsim = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nN = len(iats) # number of patients\n# T = len(sim) # number of intervals\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\nsimreswt = []\nsimresln = 0\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = loss = 0.5 * mwt + 0.5 * mln\ntoc = time.time()\nprint(toc - tic)\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\n1.5800740718841553\n\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 1 1 1 1 1 1 1], mwt: 1.6254904401340913, mln: 2.010012643229616, loss: 1.8177515416818535')\n\n\n\n\n\n\n\n\n\n# Simulation 2\n\nsim = np.array([2, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [2 0 1 1 1 1 1 1 1 1 1 1], mwt: 2.2127279372802695, mln: 2.006492327939499, loss: 2.109610132609884')\n\n\n\n\n\n\n\n\n\n# Simulation 3\n\nsim = np.array([1, 1, 1, 2, 0, 1, 1, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plot histogram of waiting times\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 2 0 1 1 1 1 1 1 1], mwt: 2.2961451129953705, mln: 2.000481608709304, loss: 2.1483133608523373')\n\n\n\n\n\n\n\n\n\n# Simulation 4\n\nsim = np.array([1, 1, 1, 1, 1, 2, 0, 1, 1, 1, 1, 1]) # initial schedule\niats = fn.transform_schedule_iats(sim, d) # initial inter-arrival times\niats_d = np.diff(iats)\nsimreswt = []\nsimresln = 0\n\n\nfor i in range(nsims):\n  experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n  simreswt.append(experiment[0].mean())\n  ln = max(0, (experiment[1] - d))\n  simresln += ln\n  \n\nmwt = np.array(simreswt).mean()\nmln = simresln / nsims\nloss = 0.5 * mwt + 0.5 * mln\n\n# plots\n\nfig1, (axs1, axs2) = plt.subplots(2, sharey=True, tight_layout=True)\naxs1.plot(iats, label=\"iats\")\naxs1.set_title(f'iats: {iats}')\naxs2.plot(iats_d, label=\"iats_d\")\naxs2.set_title(f'iats_d: {iats_d}')\nfig2, axs3 = plt.subplots(1, sharey=True, tight_layout=True)\naxs3.hist(simreswt, bins = 300)\naxs3.set_title(f'schedule: {sim}, mwt: {mwt}, mln: {mln}, loss: {loss}')\n\nText(0.5, 1.0, 'schedule: [1 1 1 1 1 2 0 1 1 1 1 1], mwt: 2.3055590155715158, mln: 1.984407952894501, loss: 2.144983484233008')"
  },
  {
    "objectID": "search-function.html",
    "href": "search-function.html",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#setup",
    "href": "search-function.html#setup",
    "title": "Search Function",
    "section": "",
    "text": "See “Scheduling Simulation” for all function descriptions.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport time\nimport functions as fn\n\nConfigure global simulation parameters.\n\n## Global variables\n\ncts = np.array([0, 1]) # client types -&gt; normal or emergency\npct = np.array([1, 0]) # distribution of client types -&gt; normal or emergency\n# sts = np.array([14, 14, 14, 15, 16]) # service times - for simple numerical testing\n# sts = np.random.poisson(lam=14, size=1000) - using poisson distribution\n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 14 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 12 # number of intervals\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = np.zeros(T) \ni = np.arange(T, step=2)\nsim[i] = 1\nsim[-1] = 1\nsim[0] = 2 \nsim = sim.astype(int) # initial schedule\nN = np.sum(sim)\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows"
  },
  {
    "objectID": "search-function.html#run-simulations-and-search",
    "href": "search-function.html#run-simulations-and-search",
    "title": "Search Function",
    "section": "Run simulations and search",
    "text": "Run simulations and search\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 30\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 8 patients and 12 timeslots.\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 20 20 20 20 20 10],\niats_diff: [  0  20   0   0   0   0 -10],\nloss = 3.6529262967215343, calc time: 1.287578821182251 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 0 1 2],\niats: [ 0 20 20 20 20 20 10  0],\niats_diff: [ 20   0   0   0   0 -10 -10],\nloss = 7.236866919284625, calc time: 1.3139550685882568 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 0 1 1],\niats: [ 0  0 10 30 20 20 20 10],\niats_diff: [  0  10  20 -10   0   0 -10],\nloss = 4.012646819905118, calc time: 1.2808387279510498 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 0 1 1],\niats: [ 0  0 20 10 30 20 20 10],\niats_diff: [  0  20 -10  20 -10   0 -10],\nloss = 3.882533552424607, calc time: 1.2880842685699463 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 0 1 1],\niats: [ 0  0 20 20 10 30 20 10],\niats_diff: [  0  20   0 -10  20 -10 -10],\nloss = 3.820123841436766, calc time: 1.2687461376190186 secs\n\nschedule: [2 0 1 0 1 0 1 1 0 0 1 1],\niats: [ 0  0 20 20 20 10 30 10],\niats_diff: [  0  20   0   0 -10  20 -20],\nloss = 3.7542266303524854, calc time: 1.288280963897705 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 0 1 1 0 1] with loss: 3.037454193824985\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 20 20 20 20 10 20],\niats_diff: [  0  20   0   0   0 -10  10],\nloss = 3.037454193824985, calc time: 1.3480618000030518 secs\n\nschedule: [1 0 1 0 1 0 1 0 1 1 0 2],\niats: [ 0 20 20 20 20 10 20  0],\niats_diff: [ 20   0   0   0 -10  10 -20],\nloss = 6.269955255329869, calc time: 1.2774670124053955 secs\n\nschedule: [2 1 0 0 1 0 1 0 1 1 0 1],\niats: [ 0  0 10 30 20 20 10 20],\niats_diff: [  0  10  20 -10   0 -10  10],\nloss = 3.396855839814907, calc time: 1.2797009944915771 secs\n\nschedule: [2 0 1 1 0 0 1 0 1 1 0 1],\niats: [ 0  0 20 10 30 20 10 20],\niats_diff: [  0  20 -10  20 -10 -10  10],\nloss = 3.264109039944019, calc time: 1.2668390274047852 secs\n\nschedule: [2 0 1 0 1 1 0 0 1 1 0 1],\niats: [ 0  0 20 20 10 30 10 20],\niats_diff: [  0  20   0 -10  20 -20  10],\nloss = 3.1901815417365063, calc time: 1.2771689891815186 secs\n\n\n#### Found better schedule: [2 0 1 0 1 0 1 1 0 1 0 1] with loss: 2.8965816600164525\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 20 20 20 10 20 20],\niats_diff: [  0  20   0   0 -10  10   0],\nloss = 2.8965816600164525, calc time: 1.292748212814331 secs\n\nschedule: [1 0 1 0 1 0 1 1 0 1 0 2],\niats: [ 0 20 20 20 10 20 20  0],\niats_diff: [ 20   0   0 -10  10   0 -20],\nloss = 6.03652300214235, calc time: 1.2947299480438232 secs\n\nschedule: [2 1 0 0 1 0 1 1 0 1 0 1],\niats: [ 0  0 10 30 20 10 20 20],\niats_diff: [  0  10  20 -10 -10  10   0],\nloss = 3.2547292828275474, calc time: 1.2926709651947021 secs\n\nschedule: [2 0 1 1 0 0 1 1 0 1 0 1],\niats: [ 0  0 20 10 30 10 20 20],\niats_diff: [  0  20 -10  20 -20  10   0],\nloss = 3.1146119333445927, calc time: 1.294140100479126 secs\n\n\n#### Found better schedule: [2 0 1 0 1 1 0 1 0 1 0 1] with loss: 2.891346100931801\n\nGenerated new psm\n\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.891346100931801, calc time: 1.293968915939331 secs\n\nschedule: [1 0 1 0 1 1 0 1 0 1 0 2],\niats: [ 0 20 20 10 20 20 20  0],\niats_diff: [ 20   0 -10  10   0   0 -20],\nloss = 5.97025592537051, calc time: 1.293849229812622 secs\n\nschedule: [2 1 0 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 10 30 10 20 20 20],\niats_diff: [  0  10  20 -20  10   0   0],\nloss = 3.2448081033989897, calc time: 1.3408417701721191 secs\n\nschedule: [2 0 1 1 0 1 0 1 0 1 0 1],\niats: [ 0  0 20 10 20 20 20 20],\niats_diff: [  0  20 -10  10   0   0   0],\nloss = 2.985957052769142, calc time: 1.3000671863555908 secs\n\nschedule: [2 0 1 0 2 0 0 1 0 1 0 1],\niats: [ 0  0 20 20  0 30 20 20],\niats_diff: [  0  20   0 -20  30 -10   0],\nloss = 3.3040051718999837, calc time: 1.2802848815917969 secs\n\nschedule: [2 0 1 0 1 1 1 0 0 1 0 1],\niats: [ 0  0 20 20 10 10 30 20],\niats_diff: [  0  20   0 -10   0  20 -10],\nloss = 3.1197207602588977, calc time: 1.2698900699615479 secs\n\nschedule: [2 0 1 0 1 1 0 1 1 0 0 1],\niats: [ 0  0 20 20 10 20 10 30],\niats_diff: [  0  20   0 -10  10 -10  20],\nloss = 3.0035773879495853, calc time: 1.2784228324890137 secs\n\nschedule: [2 0 1 0 1 1 0 1 0 1 1 0],\niats: [ 0  0 20 20 10 20 20 10],\niats_diff: [  0  20   0 -10  10   0 -10],\nloss = 4.025964770930288, calc time: 1.2853312492370605 secs\n\nFinished iterating in: 33 seconds\n\nBest result:\nschedule: [2 0 1 0 1 1 0 1 0 1 0 1],\niats: [ 0  0 20 20 10 20 20 20],\niats_diff: [  0  20   0 -10  10   0   0],\nloss = 2.891346100931801, calc time: 1.2813119888305664 secs\n\n\n\n\ndef distribute_elements(n, t):\n    quotient, remainder = divmod(t, n-1)\n    elements = np.zeros(t)\n    for i in range(n-1):\n        elements[i * quotient] = 1\n    elements[0] = elements[0] + 1\n    return elements\n  \n\nnsh = 0.1 # percentage of no-shows\nnsims = 100000 # number of simulations\nlogs = False # do not print simulation logs\nlnm = 20 # lognormal mean\nlns = 5 # lognormal standard deviation\nnm = fn.logn_mean_lns(lnm, lns)[0] # normal mean\nns = fn.logn_mean_lns(lnm, lns)[1] # normal standard deviation\nd = 10 # interval time\nT = 24 # number of intervals\nN = 9 # number of patients\nsts = fn.generate_logn_sts(1, 10000, lnm, lns)[0] # sampling population for service times\nsim = distribute_elements(N, T)\nsim = sim.astype(int) # initial schedule\n\nctsm = np.random.choice(cts, size = (nsims * N), p=pct).reshape((nsims, N)) # client types matrix\nstsm = np.random.lognormal(mean = nm, sigma=ns, size=(nsims * N)).reshape(nsims, N) # service times matrix\nnsm = np.random.binomial(n=1, p=1-ns, size = (nsims * N)).reshape(nsims, N) # no-shows matrix\nstsm = stsm * nsm # service times matrix with no-shows\n\n\nprint(f'Running {nsims} simulations with {N} patients and {T} timeslots.')\n\n# Get start time and set timer seconds\nstart_time = time.time()\nseconds = 300\nbestresult = {\n          'schedule': None,\n          'iats': None,\n          'iats_diff': None,\n          'loss': None,\n          'calc_time': None\n          } # Dictionary for saving best result\n\n# Start timer while loop\nwhile True:\n    current_time = time.time()\n    elapsed_time = current_time - start_time\n    \n    if elapsed_time &gt; seconds:\n        print(f\"Finished iterating in: {str(int(elapsed_time))} seconds\\n\")\n        print(f\"Best result:\\nschedule: {bestresult['schedule']},\\niats: {bestresult['iats']},\\niats_diff: {bestresult['iats_diff']},\\nloss = {bestresult['loss']}, calc time: {bestresult['calc_time']} secs\\n\")\n        break\n      \n    \n    ## data preparation\n    psm = fn.patient_shift_matrix(sim).astype(int)\n    print(\"Generated new psm\\n\")\n    transf_to_iats = lambda x: fn.transform_schedule_iats(x, d) \n    iats_sm = np.apply_along_axis(transf_to_iats, 1, psm) # iats shifting matrix\n    iats_d_sm = np.diff(iats_sm) # first derivative iats shifting matrix\n    \n    ## Start iterator for inter arrival times in shift matrix\n    results = [] # start list for saving results\n    for iats in iats_sm:\n      tic = time.time()\n      simreswt = [None] * nsims # array for saving waiting times\n      simresln = 0 # array for saving lateness\n      \n      for i in range(nsims): # simulate nsims number of times\n        experiment = fn.simulate_crn(iats, ctsm[i], stsm[i], logs=logs)\n        simreswt[i] = experiment[0].mean()\n        ln = max(0, (experiment[1] - d))\n        simresln += ln\n        \n      mwt = np.array(simreswt).mean()\n      mln = simresln / nsims\n      loss = 0.5 * mwt + 0.5 * mln\n      toc = time.time()\n      result = {\n          'schedule': fn.transform_iats_schedule(iats, d, T)[0],\n          'iats': iats,\n          'iats_diff': np.diff(iats),\n          'loss': loss,\n          'calc_time': toc - tic\n        }\n      if bestresult['loss'] == None: # save first result as bestresult\n            bestresult = result\n      if result['loss'] &lt; bestresult['loss']: # break loop on first improvement of loss value\n            sim = result['schedule'] # assign current best schedule as new starting point for search\n            bestresult = result\n            print(f\"\\n#### Found better schedule: {result['schedule']} with loss: {result['loss']}\\n\")\n            break\n      \n      results.append(result)\n      print(f\"schedule: {result['schedule']},\\niats: {result['iats']},\\niats_diff: {result['iats_diff']},\\nloss = {result['loss']}, calc time: {result['calc_time']} secs\\n\")\n\nRunning 100000 simulations with 9 patients and 24 timeslots.\nGenerated new psm\n\nschedule: [2 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0],\niats: [ 0  0 30 30 30 30 30 30 30],\niats_diff: [ 0 30  0  0  0  0  0  0],\nloss = 5.1126678457284225, calc time: 1.4836571216583252 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1] with loss: 4.503178650280136\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 30 30 20],\niats_diff: [ 30   0   0   0   0   0   0 -10],\nloss = 4.503178650280136, calc time: 1.387751817703247 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 2],\niats: [30 30 30 30 30 30 30 20  0],\niats_diff: [  0   0   0   0   0   0 -10 -20],\nloss = 12.190765306075381, calc time: 1.3465690612792969 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 20 40 30 30 30 30 30 20],\niats_diff: [ 20  20 -10   0   0   0   0 -10],\nloss = 4.575259018479838, calc time: 1.4695758819580078 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 20 40 30 30 30 30 20],\niats_diff: [ 30 -10  20 -10   0   0   0 -10],\nloss = 4.577134908005929, calc time: 1.3810250759124756 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 20 40 30 30 30 20],\niats_diff: [ 30   0 -10  20 -10   0   0 -10],\nloss = 4.577112071549381, calc time: 1.3626477718353271 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 20 40 30 30 20],\niats_diff: [ 30   0   0 -10  20 -10   0 -10],\nloss = 4.577211808067285, calc time: 1.3706550598144531 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1],\niats: [ 0 30 30 30 30 20 40 30 20],\niats_diff: [ 30   0   0   0 -10  20 -10 -10],\nloss = 4.5766864459272485, calc time: 1.3574728965759277 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1],\niats: [ 0 30 30 30 30 30 20 40 20],\niats_diff: [ 30   0   0   0   0 -10  20 -20],\nloss = 4.559523942371023, calc time: 1.3549349308013916 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1] with loss: 4.017097368936738\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 30 20 30],\niats_diff: [ 30   0   0   0   0   0 -10  10],\nloss = 4.017097368936738, calc time: 1.3848309516906738 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 2],\niats: [30 30 30 30 30 30 20 30  0],\niats_diff: [  0   0   0   0   0 -10  10 -30],\nloss = 11.533907424741972, calc time: 1.3492379188537598 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 30 20 30],\niats_diff: [ 20  20 -10   0   0   0 -10  10],\nloss = 4.089177440729528, calc time: 1.3639140129089355 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 30 20 30],\niats_diff: [ 30 -10  20 -10   0   0 -10  10],\nloss = 4.091050693688695, calc time: 1.3532688617706299 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 30 20 30],\niats_diff: [ 30   0 -10  20 -10   0 -10  10],\nloss = 4.090951396879829, calc time: 1.3756110668182373 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 30 20 30],\niats_diff: [ 30   0   0 -10  20 -10 -10  10],\nloss = 4.09081416264653, calc time: 1.3620758056640625 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 40 20 30],\niats_diff: [ 30   0   0   0 -10  20 -20  10],\nloss = 4.086687500575442, calc time: 1.3741559982299805 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1] with loss: 3.9626716554864436\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 30 20 30 30],\niats_diff: [ 30   0   0   0   0 -10  10   0],\nloss = 3.9626716554864436, calc time: 1.369757890701294 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 30 20 30 30  0],\niats_diff: [  0   0   0   0 -10  10   0 -30],\nloss = 11.458608503540836, calc time: 1.3796370029449463 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 30 20 30 30],\niats_diff: [ 20  20 -10   0   0 -10  10   0],\nloss = 4.034750118658257, calc time: 1.3745200634002686 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 30 20 30 30],\niats_diff: [ 30 -10  20 -10   0 -10  10   0],\nloss = 4.036589296315565, calc time: 1.370676040649414 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 30 20 30 30],\niats_diff: [ 30   0 -10  20 -10 -10  10   0],\nloss = 4.0362273186511235, calc time: 1.3922619819641113 secs\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 40 20 30 30],\niats_diff: [ 30   0   0 -10  20 -20  10   0],\nloss = 4.034021653566766, calc time: 1.355309009552002 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9561688297586333\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 30 20 30 30 30],\niats_diff: [ 30   0   0   0 -10  10   0   0],\nloss = 3.9561688297586333, calc time: 1.443962812423706 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 30 20 30 30 30  0],\niats_diff: [  0   0   0 -10  10   0   0 -30],\nloss = 11.447952117937673, calc time: 1.3418829441070557 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 30 20 30 30 30],\niats_diff: [ 20  20 -10   0 -10  10   0   0],\nloss = 4.028221420606609, calc time: 1.3692541122436523 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 30 20 30 30 30],\niats_diff: [ 30 -10  20 -10 -10  10   0   0],\nloss = 4.02984291849933, calc time: 1.3603920936584473 secs\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 40 20 30 30 30],\niats_diff: [ 30   0 -10  20 -20  10   0   0],\nloss = 4.027470515279948, calc time: 1.361104965209961 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.954612019978345\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 30 20 30 30 30 30],\niats_diff: [ 30   0   0 -10  10   0   0   0],\nloss = 3.954612019978345, calc time: 1.3890068531036377 secs\n\nschedule: [0 0 0 1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 30 20 30 30 30 30  0],\niats_diff: [  0   0 -10  10   0   0   0 -30],\nloss = 11.446049977958463, calc time: 1.4664990901947021 secs\n\nschedule: [1 0 1 0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 30 20 30 30 30 30],\niats_diff: [ 20  20 -10 -10  10   0   0   0],\nloss = 4.026432770427395, calc time: 1.4115381240844727 secs\n\nschedule: [1 0 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 40 20 30 30 30 30],\niats_diff: [ 30 -10  20 -20  10   0   0   0],\nloss = 4.026032209237965, calc time: 1.4345998764038086 secs\n\n\n#### Found better schedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.954185993850166\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 30 20 30 30 30 30 30],\niats_diff: [ 30   0 -10  10   0   0   0   0],\nloss = 3.954185993850166, calc time: 1.4257590770721436 secs\n\nschedule: [0 0 0 1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 30 20 30 30 30 30 30  0],\niats_diff: [  0 -10  10   0   0   0   0 -30],\nloss = 11.445614941696443, calc time: 1.3413898944854736 secs\n\nschedule: [1 0 1 0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 40 20 30 30 30 30 30],\niats_diff: [ 20  20 -20  10   0   0   0   0],\nloss = 4.023812705049628, calc time: 1.3684837818145752 secs\n\n\n#### Found better schedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9539644849356383\n\nGenerated new psm\n\nschedule: [1 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 30 20 30 30 30 30 30 30],\niats_diff: [ 30 -10  10   0   0   0   0   0],\nloss = 3.9539644849356383, calc time: 1.3917608261108398 secs\n\nschedule: [0 0 0 1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [30 20 30 30 30 30 30 30  0],\niats_diff: [-10  10   0   0   0   0   0 -30],\nloss = 11.442927426630467, calc time: 1.3499619960784912 secs\n\n\n#### Found better schedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1] with loss: 3.9513447624362668\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.3735740184783936 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.3497495651245117 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.3485729694366455 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.4121389389038086 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.3783509731292725 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.3516108989715576 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.3641090393066406 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.3827457427978516 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.3578691482543945 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.3525240421295166 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.3777050971984863 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.3753211498260498 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.3574268817901611 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.3537850379943848 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.3959648609161377 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.3618800640106201 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.3644449710845947 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.3573939800262451 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.4298450946807861 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.381974220275879 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.4927728176116943 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.6206488609313965 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.5466952323913574 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.55283784866333 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.5578441619873047 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.502716064453125 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4144692420959473 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.430488109588623 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.3860628604888916 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.3880581855773926 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.3713507652282715 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.3648529052734375 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.3808848857879639 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.3715839385986328 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.3797760009765625 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4212782382965088 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.453341007232666 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.4496619701385498 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.4355671405792236 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.3932881355285645 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.459764003753662 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.3868579864501953 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.4023590087890625 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.3908038139343262 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.3828108310699463 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.3650951385498047 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4062626361846924 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.3551490306854248 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.3523509502410889 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.3494668006896973 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.3719890117645264 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.3526420593261719 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.4275028705596924 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.4019582271575928 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.4077630043029785 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4051332473754883 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4144201278686523 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.4713287353515625 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.413930892944336 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.3768630027770996 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.487621784210205 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.433351993560791 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.4238348007202148 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.4134299755096436 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.3811719417572021 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4494438171386719 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4140360355377197 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.4133801460266113 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.4291658401489258 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.3816628456115723 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.3756649494171143 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.383310079574585 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.4619200229644775 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.3905022144317627 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.361288070678711 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4065887928009033 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4209628105163574 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.3718290328979492 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.4974219799041748 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.427232027053833 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.3881399631500244 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.422393798828125 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.445033311843872 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.4469420909881592 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.4224531650543213 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4235849380493164 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4292151927947998 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.4307680130004883 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.45424485206604 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.4678480625152588 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.403291940689087 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.3946738243103027 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.405776023864746 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.4423279762268066 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.4322309494018555 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.3798868656158447 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4815559387207031 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.4142968654632568 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.4323351383209229 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.4493751525878906 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.4249639511108398 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.4054548740386963 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.4272089004516602 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.4821727275848389 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.4303977489471436 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4863672256469727 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.423492193222046 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.43709397315979 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.4659578800201416 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.51108980178833 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.5123310089111328 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.4339828491210938 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.4563629627227783 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.3799710273742676 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.4520721435546875 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4028370380401611 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.3736460208892822 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.4631860256195068 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.4815971851348877 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.4686188697814941 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.4332122802734375 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.3456478118896484 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.358959674835205 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.3767120838165283 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.5142598152160645 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.6182811260223389 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4938950538635254 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.511444330215454 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.5045299530029297 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.4317200183868408 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.5424373149871826 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.5513370037078857 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.6310467720031738 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.445727825164795 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.6032159328460693 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4855589866638184 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.5201950073242188 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.4753379821777344 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.6699628829956055 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.5396132469177246 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.5178940296173096 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.4546082019805908 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.5896401405334473 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.5229439735412598 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.507504940032959 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.5045549869537354 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.469618320465088 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.5065219402313232 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.4580941200256348 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.4338629245758057 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.4291069507598877 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.5341811180114746 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.5491540431976318 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.4132769107818604 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.4738569259643555 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4849801063537598 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.49778413772583 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.563683032989502 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.5189990997314453 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.5918331146240234 secs\n\nGenerated new psm\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.5802240371704102 secs\n\nschedule: [0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 2],\niats: [20 30 30 30 30 30 30 30  0],\niats_diff: [ 10   0   0   0   0   0   0 -30],\nloss = 11.355411371808977, calc time: 1.4433951377868652 secs\n\nschedule: [1 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 10 40 30 30 30 30 30 30],\niats_diff: [ 10  30 -10   0   0   0   0   0],\nloss = 4.285753539866366, calc time: 1.472783088684082 secs\n\nschedule: [1 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 20 40 30 30 30 30 30],\niats_diff: [ 20   0  20 -10   0   0   0   0],\nloss = 4.058893771111291, calc time: 1.490114688873291 secs\n\nschedule: [1 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 20 40 30 30 30 30],\niats_diff: [ 20  10 -10  20 -10   0   0   0],\nloss = 4.029014442585661, calc time: 1.5087270736694336 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 20 40 30 30 30],\niats_diff: [ 20  10   0 -10  20 -10   0   0],\nloss = 4.025995567158647, calc time: 1.4729831218719482 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 20 40 30 30],\niats_diff: [ 20  10   0   0 -10  20 -10   0],\nloss = 4.026275560025264, calc time: 1.4706988334655762 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 20 40 30],\niats_diff: [ 20  10   0   0   0 -10  20 -10],\nloss = 4.022386928151433, calc time: 1.8510792255401611 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0 0 0 1],\niats: [ 0 20 30 30 30 30 30 20 40],\niats_diff: [ 20  10   0   0   0   0 -10  20],\nloss = 3.9938845369248135, calc time: 1.437762975692749 secs\n\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 1 0],\niats: [ 0 20 30 30 30 30 30 30 20],\niats_diff: [ 20  10   0   0   0   0   0 -10],\nloss = 4.5906649132513975, calc time: 1.5053060054779053 secs\n\nFinished iterating in: 306 seconds\n\nBest result:\nschedule: [1 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1 0 0 1],\niats: [ 0 20 30 30 30 30 30 30 30],\niats_diff: [20 10  0  0  0  0  0  0],\nloss = 3.9513447624362668, calc time: 1.3879451751708984 secs"
  },
  {
    "objectID": "convexity.html",
    "href": "convexity.html",
    "title": "Convexity",
    "section": "",
    "text": "import numpy as np\n\n# Define the function\ndef f(x):\n    return x**2\n\n# Define x1, x2 and t\nx1 = 1\nx2 = 3\nt = 0.5  # choose any value in [0, 1]\n\n# Compute the left-hand and right-hand side of the convexity inequality\nlhs = f(t*x1 + (1-t)*x2)\nrhs = t*f(x1) + (1-t)*f(x2)\n\n# Print the results\nprint(f\"Left-hand side: {lhs}\")\nprint(f\"Right-hand side: {rhs}\")\n\n# Check if the inequality holds\nif lhs &lt;= rhs:\n    print(\"The function is convex.\")\nelse:\n    print(\"The function is not convex.\")\n\na = (f(x2) - f(x1)) / (x2 - x1)\n\nb = f(x1) - a*x1\n\nprint(f'y = {a}x + {b}')\n\nLeft-hand side: 4.0\nRight-hand side: 5.0\nThe function is convex.\ny = 4.0x + -3.0\n\n\n\nfrom sympy import *\n\ndef g(x):\n  return 4*x - 3\n\nx = symbols('x')\nf = f(x)\ng = g(x)\n\nplot(f, g, (x, -1, 4))\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x102f52f70&gt;"
  }
]