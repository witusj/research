---
title: "No-shows and emergency patients"
bibliography: "bibliography.bib"
---

This code replicates methods from @kaandorp_optimal_2007.

![](images/20230831_105330.jpeg)

```{python}
import numpy as np
from scipy.stats import poisson
import plotly.graph_objs as go
import plotly.offline as pyo

def service_time_with_no_shows(s, q):
  # """
  # Function to adjust a distribution of service times for no-shows
  # 
  # Args:
  #     s (numpy.ndarray): An array with service times.
  #     q (double): The fraction of no-shows.
  # 
  # Returns:
  #     numpy.ndarray: The adjusted array of service times.
  # """
  
  s_adj = s * (1-q)
  s_adj[0] = s_adj[0] + q
  
  return(s_adj)

def add_lists(short_list, long_list):
    
    # Extend the short lists to the length of the long list with zeros
    short_list.extend([0] * (len(long_list) - len(short_list)))
    
    # Sum the elements of the two lists element-wise
    result = [a + b for a, b in zip(short_list, long_list)]
    
    return result

def calculate_rolling_convolution(y, s, limit):
  conv_list = s
  v = [x * y[0] for x in conv_list]
  for i in range(1, limit):
    conv_list = np.convolve(conv_list, s)
    v = add_lists(v, [x * y[i] for x in conv_list])
  print(f'conv_list = {conv_list[:10]} with sum {sum(conv_list)}, v = {v[:10]} with sum {sum(v)}')
  return(v)
```

```{python}
### TEST ###

s = np.array([0.5, 0.1, 0.4, 0.2])
q = 0.1
s_adj = service_time_with_no_shows(s, q)
print(s_adj, s_adj.sum())

```

```{python}
### TEST 2 ###

y = [0.5, 0.3, 0.2]
s = [0.1, 0.2, 0.7]
limit = 3
v = calculate_rolling_convolution(y, s, limit)
```

```{python}
trace = go.Scatter(
            x = list(range(len(v))),
            y = v,
            mode = 'lines'
        )
        
data = [trace]

layout = go.Layout(
    title = f'distribution of v',
    xaxis = dict(title='Time'),
    yaxis = dict(title='Probability')
)

fig = go.Figure(data=data, layout=layout)
pyo.iplot(fig)
```


```{python}
### TEST 3 ###

len_y = 300
len_se = 300
y = [poisson.pmf(i, 1) for i in range(0, len_y)]
se = [poisson.pmf(j, 10) for j in range(0, len_se)]
print(sum(y), sum(se))

v = calculate_rolling_convolution(y, se, len_y)
```

```{python}
trace = go.Scatter(
            x = list(range(len(v[:100]))),
            y = v[:100],
            mode = 'lines'
        )
        
data = [trace]

layout = go.Layout(
    title = f'distribution of v',
    xaxis = dict(title='Time'),
    yaxis = dict(title='Probability')
)

fig = go.Figure(data=data, layout=layout)
pyo.iplot(fig)
```
