<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Witek ten Hove">

<title>2024-06-15</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="2024-06-25_files/libs/clipboard/clipboard.min.js"></script>
<script src="2024-06-25_files/libs/quarto-html/quarto.js"></script>
<script src="2024-06-25_files/libs/quarto-html/popper.min.js"></script>
<script src="2024-06-25_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2024-06-25_files/libs/quarto-html/anchor.min.js"></script>
<link href="2024-06-25_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2024-06-25_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2024-06-25_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2024-06-25_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2024-06-25_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.js"></script>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">2024-06-15</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Witek ten Hove </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="obp" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="obp">OBP:</h2>
<p>Afspraken:</p>
<ul class="task-list">
<li><p><label><input type="checkbox">We gaan verder kijken naar Simulation Optimization methodes</label></p></li>
<li><p><label><input type="checkbox">Wellicht icm Gradient Boosting, mogelijk ML-toepassingen</label></p></li>
<li><p><label><input type="checkbox">Onderzoeken wat de stand van zaken is mbt SO en Appointment Scheduling</label></p></li>
<li><p><label><input type="checkbox">Start met artikel van <span class="citation" data-cites="homem2022simulation">Homem-de-Mello, Kong, and Godoy-Barba (<a href="#ref-homem2022simulation" role="doc-biblioref">2022</a>)</span></label></p></li>
<li><p><label><input type="checkbox">Waarom zou het probleem dat besproken wordt in <span class="citation" data-cites="homem2022simulation">Homem-de-Mello, Kong, and Godoy-Barba (<a href="#ref-homem2022simulation" role="doc-biblioref">2022</a>)</span> non-convex zijn?</label></p></li>
<li><p><label><input type="checkbox" checked="">Aanmaken van Overleaf document voor samenwerking.</label></p></li>
<li><p><label><input type="checkbox">Literatuurnotities maken</label></p></li>
<li><p><label><input type="checkbox" checked="">Literatuuroverzicht maken</label></p></li>
<li><p><label><input type="checkbox">Problem description uitwerken in Overleaf.</label></p></li>
</ul>
<p>From appendix D <span class="citation" data-cites="zacharias2020multimodularity">Zacharias and Yunes (<a href="#ref-zacharias2020multimodularity" role="doc-biblioref">2020</a>)</span></p>
<div class="column-screen-inset">
<div>

<div class="container mt-4">
        <div class="table-wrapper">
            
<table class="table table-bordered" data-quarto-postprocess="true">
<thead style="position: sticky; top: 0; background-color: #fff; z-index: 1;">
<tr class="header">
<th data-quarto-table-cell-role="th">Service Time Distribution</th>
<th data-quarto-table-cell-role="th">Emergency Demand</th>
<th data-quarto-table-cell-role="th">No-Shows</th>
<th data-quarto-table-cell-role="th">Random Investigational Punctuality</th>
<th data-quarto-table-cell-role="th">Heterogeneous Patient Groups</th>
<th data-quarto-table-cell-role="th">Theoretical Optimization Properties</th>
<th data-quarto-table-cell-role="th">Exact or Heuristic Solution</th>
<th data-quarto-table-cell-role="th">Full Reference</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Lau and Lau (2000)</td>
<td>Independent, General</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Stochastic - Heuristic Quasi-Newton (beta-fitting)</td>
<td>Lau HS, Lau AHL (2000) A fast procedure for computing the total system cost of an appointment schedule for medical and kindred facilities. IIE Trans. 32(9):833–839.</td>
</tr>
<tr class="even">
<td>Kaandorp and Koole (2007)</td>
<td>I.I.D Exponential</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Local Search Multimodularity Exact (Exponential Complexity)</td>
<td>Kaandorp GC, Koole G (2007) Optimal outpatient appointment scheduling. Health Care Management Sci. 10(3):217–229.</td>
</tr>
<tr class="odd">
<td>Hassin and Mendel (2008)</td>
<td>I.I.D Exponential</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Sequential - Heuristic Quadratic Programming</td>
<td>Hassin R, Mendel S (2008) Scheduling arrivals to queues: A single-server model with no-shows. Management Sci. 54(3):565–572.</td>
</tr>
<tr class="even">
<td>Zeng et al. (2010)</td>
<td>I.I.D Exponential</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Local Search Multimodularity Exact (Exponential Complexity)</td>
<td>Zeng B, Turkcan A, Lin J, Lawley M (2010) Clinic scheduling models with overbooking for patients with heterogeneous no-show probabilities. Ann. Oper. Res. 178(1):121–144.</td>
</tr>
<tr class="odd">
<td>Begen and Queyranne (2011)</td>
<td>Independent</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Local Search General L-Convexity Exact in Polynomial Time</td>
<td>Begen MA, Queyranne M (2011) Appointment scheduling with discrete random durations. Math. Oper. Res. 36(2):240–257.</td>
</tr>
<tr class="even">
<td>Luo et al. (2012)</td>
<td>Independent Exponential</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Interior-Point Methods - Heuristic</td>
<td>Luo J, Kulkarni VG, Ziya S (2012) Appointment scheduling under patient no-shows and service interruptions. Manufacturing Service Oper. Management 14(4):670–684.</td>
</tr>
<tr class="odd">
<td>LaGanga and Lawrence (2012)</td>
<td>Deterministic</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Structural Properties &amp; Heuristic Gradient Search &amp; Pairwise Swap</td>
<td>LaGanga LR, Lawrence SR (2012) Appointment overbooking in health care clinics to improve patient service and clinic performance. Production Oper. Management 21(5):874–888.</td>
</tr>
<tr class="even">
<td>Kong et al. (2013)</td>
<td>Distributionally Robust Based on First Two Moments</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Moment Robust Optimization Exact Decomposition &amp; Convex Conic Programming</td>
<td>Kong Q, Lee CY, Teo CP, Zheng Z (2013) Scheduling arrivals to a stochastic service delivery system using copositive cones. Oper. Res. 61(3):711–726.</td>
</tr>
<tr class="odd">
<td>Chen and Robinson (2014)</td>
<td>Independent General</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Stochastic Linear Programming &amp; Stochastic Sequencing Rules - Heuristic</td>
<td>Chen RR, Robinson LW (2014) Sequencing and scheduling appointments with potential call-in patients. Production Oper. Management 23(9):1522–1538.</td>
</tr>
<tr class="even">
<td>Zacharias and Pinedo (2014)</td>
<td>Deterministic</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Structural Properties Exact Enumeration (Exponential Complexity)</td>
<td>Zacharias C, Pinedo M (2014) Appointment scheduling with no-shows and overbooking. Production Oper. Management 23(5):788–801.</td>
</tr>
<tr class="odd">
<td>Mak et al. (2014)</td>
<td>Independent General</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Structural Properties Mixed-Integer Second-Order Stochastic Conic Programming - Heuristic</td>
<td>Mak HY, Rong Y, Zhang J (2015) Appointment scheduling with limited distributional information. Management Sci. 61(2):316–334.</td>
</tr>
<tr class="even">
<td>Mak et al. (2015)</td>
<td>Distributionally Robust Based on Marginal Moments</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Sequencing Rules, Closed-Form Conic Programming &amp; Sample Average Approximation - Exact</td>
<td>Mak HY, Rong Y, Zhang J (2015) Appointment scheduling with limited distributional information. Management Sci. 61(2):316–334.</td>
</tr>
<tr class="odd">
<td>Zacharias and Pinedo (2017)</td>
<td>Deterministic</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Multimodularity &amp; Monotonicity Properties Local Search Exact (Exponential Complexity)</td>
<td>Zacharias C, Pinedo M (2017) Managing customer arrivals in service systems with multiple identical servers. Manufacturing Service Oper. Management 19(4):639–656.</td>
</tr>
<tr class="even">
<td>Qi (2017)</td>
<td>General Discrete</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>Equivalent Exact</td>
<td>Qi J (2017) Mitigating delays and unfairness in appointment systems. Management Sci. 63(2):566–583.</td>
</tr>
</tbody>
</table>

        </div>
    </div>
</div>
</div>
<hr>
<p>To solve the scheduling problem using XGBoost, we need to frame it as a machine learning problem where XGBoost can be applied effectively. This involves several steps:</p>
<ol type="1">
<li><p><strong>Define the Problem</strong>: We need to define the scheduling problem in terms of features and labels that can be used for training the XGBoost model.</p></li>
<li><p><strong>Generate Data</strong>: Since this is a scheduling problem, we need to generate or use historical scheduling data that includes features such as the number of patients, number of service intervals, service times, waiting times, no-show probabilities, etc.</p></li>
<li><p><strong>Feature Engineering</strong>: Create relevant features that will be used by the XGBoost model to make predictions.</p></li>
<li><p><strong>Define the Objective Function</strong>: As per the scheduling problem, the objective function is to minimize the expected waiting time and overtime. This objective function will be used to evaluate the performance of the model.</p></li>
<li><p><strong>Train the XGBoost Model</strong>: Train the model using the generated or historical data.</p></li>
<li><p><strong>Evaluate and Optimize</strong>: Evaluate the model’s performance and optimize the hyperparameters to improve the results.</p></li>
</ol>
<p>Here’s a detailed approach to implement XGBoost for the scheduling problem:</p>
<section id="step-1-define-the-problem" class="level3">
<h3 class="anchored" data-anchor-id="step-1-define-the-problem">Step 1: Define the Problem</h3>
<p>The goal is to minimize the expected waiting time <span class="math inline">W(x)</span> and the expected overtime <span class="math inline">L(x)</span> given a schedule <span class="math inline">x</span>. We will use XGBoost to predict the expected waiting time and overtime for given schedules.</p>
</section>
<section id="step-2-generate-data" class="level3">
<h3 class="anchored" data-anchor-id="step-2-generate-data">Step 2: Generate Data</h3>
<p>Generate synthetic data or use historical data that includes the following: - Number of patients (<span class="math inline">N</span>) - Number of service intervals (<span class="math inline">T</span>) - Duration of each interval (<span class="math inline">d</span>) - Service times (<span class="math inline">s_{n,t}</span>) - Waiting times (<span class="math inline">w_{n,t}</span>) - No-show probabilities (<span class="math inline">\rho</span>) - Idle times (<span class="math inline">i_t</span>) - Actual schedule (<span class="math inline">x</span>)</p>
</section>
<section id="step-3-feature-engineering" class="level3">
<h3 class="anchored" data-anchor-id="step-3-feature-engineering">Step 3: Feature Engineering</h3>
<p>Create features that can be used by the XGBoost model: - <span class="math inline">N</span>: Total number of patients. - <span class="math inline">T</span>: Total number of service intervals. - <span class="math inline">d</span>: Duration of each interval. - <span class="math inline">\rho</span>: No-show probability. - Aggregated statistics of service times (mean, variance, etc.). - Aggregated statistics of waiting times (mean, variance, etc.). - Features representing the schedule <span class="math inline">x</span> (e.g., number of patients in each interval).</p>
</section>
<section id="step-4-define-the-objective-function" class="level3">
<h3 class="anchored" data-anchor-id="step-4-define-the-objective-function">Step 4: Define the Objective Function</h3>
<p>The objective function to minimize is given by: <span class="math display">C(x) = \alpha_W W(x) + \alpha_L L(x)</span></p>
<p>Here, <span class="math inline">W(x)</span> and <span class="math inline">L(x)</span> are the expected waiting time and expected overtime, respectively.</p>
</section>
<section id="step-5-train-the-xgboost-model" class="level3">
<h3 class="anchored" data-anchor-id="step-5-train-the-xgboost-model">Step 5: Train the XGBoost Model</h3>
<p>Use the features and labels (expected waiting time and overtime) to train the XGBoost model.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> xgboost <span class="im">as</span> xgb</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Assume `data` is a DataFrame containing the features and labels</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> data.drop([<span class="st">'expected_waiting_time'</span>, <span class="st">'expected_overtime'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>y_waiting_time <span class="op">=</span> data[<span class="st">'expected_waiting_time'</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>y_overtime <span class="op">=</span> data[<span class="st">'expected_overtime'</span>]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Split the data into training and testing sets</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train_waiting, y_test_waiting <span class="op">=</span> train_test_split(X, y_waiting_time, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>_, _, y_train_overtime, y_test_overtime <span class="op">=</span> train_test_split(X, y_overtime, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Train XGBoost models</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>model_waiting <span class="op">=</span> xgb.XGBRegressor(objective<span class="op">=</span><span class="st">'reg:squarederror'</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>model_overtime <span class="op">=</span> xgb.XGBRegressor(objective<span class="op">=</span><span class="st">'reg:squarederror'</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>model_waiting.fit(X_train, y_train_waiting)</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>model_overtime.fit(X_train, y_train_overtime)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict and evaluate</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>pred_waiting <span class="op">=</span> model_waiting.predict(X_test)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>pred_overtime <span class="op">=</span> model_overtime.predict(X_test)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>rmse_waiting <span class="op">=</span> mean_squared_error(y_test_waiting, pred_waiting, squared<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>rmse_overtime <span class="op">=</span> mean_squared_error(y_test_overtime, pred_overtime, squared<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'RMSE for Waiting Time: </span><span class="sc">{</span>rmse_waiting<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'RMSE for Overtime: </span><span class="sc">{</span>rmse_overtime<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="step-6-evaluate-and-optimize" class="level3">
<h3 class="anchored" data-anchor-id="step-6-evaluate-and-optimize">Step 6: Evaluate and Optimize</h3>
<p>Evaluate the model’s performance using metrics such as RMSE (Root Mean Squared Error) for both waiting time and overtime. Optimize the hyperparameters of the XGBoost model using techniques such as Grid Search or Bayesian Optimization to improve the results.</p>
</section>
<section id="additional-considerations" class="level3">
<h3 class="anchored" data-anchor-id="additional-considerations">Additional Considerations</h3>
<ol type="1">
<li><strong>Hyperparameter Tuning</strong>: Use cross-validation and hyperparameter tuning to improve the model performance.</li>
<li><strong>Feature Importance</strong>: Analyze feature importance to understand which features are most influential in predicting waiting time and overtime.</li>
<li><strong>Model Interpretability</strong>: Consider using SHAP values to interpret the model predictions and understand the impact of each feature.</li>
</ol>
<p>By following these steps, you can effectively use XGBoost to address the scheduling problem, aiming to minimize the expected waiting time and overtime for the given schedules.</p>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-homem2022simulation" class="csl-entry" role="listitem">
Homem-de-Mello, Tito, Qingxia Kong, and Rodrigo Godoy-Barba. 2022. <span>“A Simulation Optimization Approach for the Appointment Scheduling Problem with Decision-Dependent Uncertainties.”</span> <em>INFORMS Journal on Computing</em> 34 (5): 2845–65.
</div>
<div id="ref-zacharias2020multimodularity" class="csl-entry" role="listitem">
Zacharias, Christos, and Tallys Yunes. 2020. <span>“Multimodularity in the Stochastic Appointment Scheduling Problem with Discrete Arrival Epochs.”</span> <em>Management Science</em> 66 (2): 744–63.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>