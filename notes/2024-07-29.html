<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Witek ten Hove">

<title>2024-07-18</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="2024-07-29_files/libs/clipboard/clipboard.min.js"></script>
<script src="2024-07-29_files/libs/quarto-html/quarto.js"></script>
<script src="2024-07-29_files/libs/quarto-html/popper.min.js"></script>
<script src="2024-07-29_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="2024-07-29_files/libs/quarto-html/anchor.min.js"></script>
<link href="2024-07-29_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="2024-07-29_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="2024-07-29_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="2024-07-29_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="2024-07-29_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="2024-07-29_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="2024-07-29_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="2024-07-29_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">2024-07-18</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Witek ten Hove </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>Besproken met Joost:</p>
<ul>
<li>Model bouwen voor pairwise ranking.</li>
<li>Performance vergelijken met cardinal ML model</li>
<li>Computation time vergelijken:
<ul>
<li>Lindley recursion &lt;&gt; cardinal ML</li>
<li>Cardinal ML model pairwise ranking vs direct pairwise ranking</li>
</ul></li>
<li>Cardinal ML model met large objective punisment in loss function ontwikkelen</li>
</ul>
<section id="setup-and-load-data" class="level2">
<h2 class="anchored" data-anchor-id="setup-and-load-data">Setup and load data</h2>
<div id="1cab2262" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> schedule_class <span class="im">import</span> NewSchedule, generate_schedules, service_time_with_no_shows</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pickle</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> xgboost <span class="im">as</span> xgb</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split, cross_val_score, StratifiedKFold, GridSearchCV</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error, make_scorer, accuracy_score</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.base <span class="im">import</span> clone</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> StratifiedKFold, train_test_split, GridSearchCV</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> chain, combinations</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="03762809" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ScheduleData:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, N: <span class="bu">int</span>, T: <span class="bu">int</span>, samples, labels):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.N <span class="op">=</span> N</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.T <span class="op">=</span> T</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.samples <span class="op">=</span> samples</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.labels <span class="op">=</span> labels</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> describe_data(<span class="va">self</span>):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f'N = </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>N<span class="sc">}</span><span class="ss">'</span>, <span class="ss">f'T = </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>T<span class="sc">}</span><span class="ss">'</span>, <span class="st">'</span><span class="ch">\n</span><span class="st">Samples'</span>,<span class="va">self</span>.samples.tail(<span class="dv">10</span>), <span class="st">'</span><span class="ch">\n</span><span class="st">Labels'</span>, <span class="va">self</span>.labels.tail(<span class="dv">10</span>), sep <span class="op">=</span> <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> create_pair_list(<span class="va">self</span>, n): <span class="co"># Create a set of randomly selected pairs of schedules</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(<span class="va">self</span>.samples)))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> random.choices(S, k<span class="op">=</span>n)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    P <span class="op">=</span> []</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> q <span class="kw">in</span> Q:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a list of possible choices excluding t</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        possible_choices <span class="op">=</span> [s <span class="cf">for</span> s <span class="kw">in</span> S <span class="cf">if</span> s <span class="op">!=</span> q]</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Choose a random element from the possible choices</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        p <span class="op">=</span> random.choice(possible_choices)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add the chosen element to the result list</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        P.append(p)</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    samples_s1 <span class="op">=</span> <span class="va">self</span>.samples.iloc[Q, :].values.tolist()</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    samples_s2 <span class="op">=</span> <span class="va">self</span>.samples.iloc[P, :].values.tolist()</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.pair_list <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(samples_s1, samples_s2))</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.lables_s1 <span class="op">=</span> <span class="va">self</span>.labels.loc[Q, <span class="st">'obj'</span>].values.tolist()</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.lables_s2 <span class="op">=</span> <span class="va">self</span>.labels.loc[P, <span class="st">'obj'</span>].values.tolist()</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.lables_rank <span class="op">=</span> [<span class="dv">1</span> <span class="op">*</span> (<span class="va">self</span>.lables_s1[i] <span class="op">&gt;</span> <span class="va">self</span>.lables_s2[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(<span class="va">self</span>.lables_s1))]</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="va">self</span>.pair_list[:<span class="dv">15</span>], <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, <span class="va">self</span>.lables_s1[:<span class="dv">15</span>], <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, <span class="va">self</span>.lables_s2[:<span class="dv">15</span>], <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, <span class="va">self</span>.lables_rank[:<span class="dv">15</span>])</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> create_neighbors_list(<span class="va">self</span>, n): <span class="co"># Create a set of pairs of schedules that are from the same neighborhood</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build a subset of random schedules with length n</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    S <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="bu">len</span>(<span class="va">self</span>.samples)))</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> random.choices(S, k<span class="op">=</span>n)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    samples_sub <span class="op">=</span> <span class="va">self</span>.samples.iloc[Q, :].values.tolist()</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    labels_sub <span class="op">=</span> <span class="va">self</span>.labels.iloc[Q, <span class="dv">7</span>]</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.neighbors_list <span class="op">=</span> []</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For each schedule in in the subset choose 2 random intervals i, j and swap 1 patient</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> samples_sub:</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>      i <span class="op">=</span> random.choice(<span class="bu">range</span>(<span class="bu">len</span>(s)))  <span class="co"># Ensure i is a valid index in s</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>      j <span class="op">=</span> [index <span class="cf">for</span> index, element <span class="kw">in</span> <span class="bu">enumerate</span>(s) <span class="cf">if</span> element <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> index <span class="op">!=</span> i]</span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="kw">not</span> j:  <span class="co"># Ensure j is not empty</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>          <span class="cf">continue</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>      j <span class="op">=</span> random.choice(j)  <span class="co"># Choose a random valid index from j</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>      s_pair <span class="op">=</span> s.copy()  <span class="co"># Create a copy of s to modify</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>      s_pair[i] <span class="op">=</span> s[i] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>      s_pair[j] <span class="op">=</span> s[j] <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.neighbors_list.append((s, s_pair))</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(samples_sub, <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, <span class="va">self</span>.neighbors_list, <span class="st">"</span><span class="ch">\n</span><span class="st">"</span>, labels_sub)</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> calculate_objective(<span class="va">self</span>, schedule, s, d, q):</span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> service_time_with_no_shows(s, q) <span class="co"># Adjust service times distribution for no-shows</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    sp <span class="op">=</span> np.array([<span class="dv">1</span>], dtype<span class="op">=</span>np.int64) <span class="co"># Set probability of first spillover time being zero to 1</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>    wt_list <span class="op">=</span> [] <span class="co"># Initialize wt_list for saving all waiting times for all patients in the schedule</span></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    ewt <span class="op">=</span> <span class="dv">0</span> <span class="co"># Initialize sum of expected waiting times</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> schedule: <span class="co"># For each interval -</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(x <span class="op">==</span> <span class="dv">0</span>): <span class="co"># In case there are no patients,</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>        wt_temp <span class="op">=</span> [np.array(sp)] <span class="co"># the spillover from the previous interval is recorded,</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>        wt_list.append([]) <span class="co"># but there are no waiting times.</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>        sp <span class="op">=</span> [] <span class="co"># Initialize the spillover time distribution </span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>        sp.append(np.<span class="bu">sum</span>(wt_temp[<span class="op">-</span><span class="dv">1</span>][:d<span class="op">+</span><span class="dv">1</span>])) <span class="co"># All the work from the previous interval's spillover that could not be processed will be added to the this interval's spillover.</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>        sp[<span class="dv">1</span>:] <span class="op">=</span> wt_temp[<span class="op">-</span><span class="dv">1</span>][d<span class="op">+</span><span class="dv">1</span>:]</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>: <span class="co"># In case there are patients scheduled,</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>        wt_temp <span class="op">=</span> [np.array(sp)] <span class="co"># Initialize wt_temp for saving all waiting times for all patients in the interval. The first patient has to wait for the spillover work from the previous period.</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>        ewt <span class="op">+=</span> np.dot(<span class="bu">range</span>(<span class="bu">len</span>(sp)), sp) <span class="co"># Add waiting time for first patient in interval</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(x<span class="op">-</span><span class="dv">1</span>): <span class="co"># For each patient</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>          wt <span class="op">=</span> np.convolve(wt_temp[i], s) <span class="co"># Calculate the waiting time distribution</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>          wt_temp.append(wt)</span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>          ewt <span class="op">+=</span> np.dot(<span class="bu">range</span>(<span class="bu">len</span>(wt)), wt)</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>        wt_list.append(wt_temp)</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>        sp <span class="op">=</span> []</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>        sp.append(np.<span class="bu">sum</span>(np.convolve(wt_temp[<span class="op">-</span><span class="dv">1</span>],s)[:d<span class="op">+</span><span class="dv">1</span>])) <span class="co"># Calculate the spillover</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>        sp[<span class="dv">1</span>:] <span class="op">=</span> np.convolve(wt_temp[<span class="op">-</span><span class="dv">1</span>],s)[d<span class="op">+</span><span class="dv">1</span>:]</span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Schedule: </span><span class="sc">{</span>schedule<span class="sc">}</span><span class="ss">, ewt = </span><span class="sc">{</span>ewt<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">'./experiments/data.pickle'</span>, <span class="st">'rb'</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>  sch_data: ScheduleData <span class="op">=</span> pickle.load(<span class="bu">file</span>)</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>sch_data.description</span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>sch_data.describe_data()</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>sch_data.create_pair_list(<span class="dv">16000</span>)</span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>sch_data.create_neighbors_list(<span class="dv">10</span>)</span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>test_sch <span class="op">=</span> sch_data.neighbors_list[<span class="dv">1</span>][<span class="dv">0</span>]</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>sch_data.calculate_objective(test_sch, [<span class="fl">0.0</span>, <span class="fl">0.27</span>, <span class="fl">0.28</span>, <span class="fl">0.2</span>, <span class="fl">0.15</span>, <span class="fl">0.1</span>], <span class="dv">3</span>, <span class="fl">0.2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>N = 10
T = 7

Samples
      x_0  x_1  x_2  x_3  x_4  x_5  x_6
7998    8    1    0    1    0    0    0
7999    8    1    1    0    0    0    0
8000    8    2    0    0    0    0    0
8001    9    0    0    0    0    0    1
8002    9    0    0    0    0    1    0
8003    9    0    0    0    1    0    0
8004    9    0    0    1    0    0    0
8005    9    0    1    0    0    0    0
8006    9    1    0    0    0    0    0
8007   10    0    0    0    0    0    0

Labels
        ew_0       ew_1       ew_2      ew_3      ew_4      ew_5    ew_6  \
7998  56.672  13.192158   0.000000  9.241482  0.000000  0.000000  0.0000   
7999  56.672  13.192158  12.217911  0.000000  0.000000  0.000000  0.0000   
8000  56.672  28.408317   0.000000  0.000000  0.000000  0.000000  0.0000   
8001  72.864   0.000000   0.000000  0.000000  0.000000  0.000000  1.9547   
8002  72.864   0.000000   0.000000  0.000000  0.000000  3.858871  0.0000   
8003  72.864   0.000000   0.000000  0.000000  6.380606  0.000000  0.0000   
8004  72.864   0.000000   0.000000  9.241482  0.000000  0.000000  0.0000   
8005  72.864   0.000000  12.217883  0.000000  0.000000  0.000000  0.0000   
8006  72.864  15.216038   0.000000  0.000000  0.000000  0.000000  0.0000   
8007  91.080   0.000000   0.000000  0.000000  0.000000  0.000000  0.0000   

            obj  obj_rank  
7998  79.105640    7964.5  
7999  82.082070    7978.0  
8000  85.080317    7987.5  
8001  74.818700    7911.0  
8002  76.722871    7945.5  
8003  79.244606    7968.0  
8004  82.105482    7982.5  
8005  85.081883    7993.0  
8006  88.080038    7998.5  
8007  91.080000    8005.0  
[([0, 1, 1, 3, 3, 0, 2], [2, 3, 0, 4, 0, 1, 0]), ([1, 3, 0, 1, 3, 2, 0], [0, 4, 3, 2, 1, 0, 0]), ([3, 0, 6, 1, 0, 0, 0], [4, 0, 0, 2, 0, 0, 4]), ([0, 1, 3, 1, 2, 0, 3], [0, 7, 2, 0, 1, 0, 0]), ([0, 0, 1, 1, 2, 0, 6], [1, 2, 3, 2, 0, 2, 0]), ([1, 1, 2, 1, 2, 3, 0], [2, 0, 6, 0, 2, 0, 0]), ([1, 2, 2, 2, 0, 1, 2], [1, 3, 0, 1, 0, 0, 5]), ([0, 1, 0, 3, 1, 2, 3], [3, 1, 3, 0, 1, 1, 1]), ([2, 1, 1, 1, 1, 0, 4], [0, 1, 2, 2, 1, 3, 1]), ([0, 4, 0, 0, 2, 4, 0], [3, 0, 0, 3, 2, 1, 1]), ([0, 1, 2, 5, 2, 0, 0], [1, 0, 3, 5, 0, 1, 0]), ([0, 2, 3, 0, 2, 1, 2], [5, 0, 2, 1, 1, 1, 0]), ([0, 1, 3, 0, 2, 1, 3], [1, 2, 4, 2, 1, 0, 0]), ([0, 0, 1, 4, 1, 2, 2], [4, 1, 3, 1, 1, 0, 0]), ([0, 0, 1, 3, 5, 0, 1], [4, 0, 0, 2, 0, 3, 1])] 
 [34.22189054428099, 27.96868620985509, 53.3082981348685, 29.369766555466406, 35.67029770240003, 23.887440159861143, 22.93950307655502, 33.723200793605855, 19.126779984248845, 36.808115960523025, 50.957329268487, 29.84213748777736, 26.3343622869004, 43.153046469728096, 52.08487469317008] 
 [37.74296530111671, 61.349811984034645, 28.445885809131536, 76.10685409489975, 34.07964836131413, 48.699926716726544, 28.53976369152002, 30.762532890673068, 29.55469960026075, 29.855052541193373, 49.69217767565351, 44.80542845094866, 45.01716228565713, 50.09276646866054, 27.597715658081768] 
 [0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1]
[[0, 1, 0, 1, 5, 1, 2], [3, 0, 1, 0, 4, 1, 1], [3, 3, 3, 0, 0, 1, 0], [1, 2, 0, 1, 1, 1, 4], [1, 1, 0, 3, 2, 2, 1], [3, 0, 1, 1, 0, 5, 0], [2, 7, 0, 0, 1, 0, 0], [2, 2, 1, 0, 1, 0, 4], [2, 3, 0, 0, 4, 1, 0], [2, 4, 0, 0, 3, 1, 0]] 
 [([0, 1, 0, 1, 5, 1, 2], [0, 1, 0, 1, 4, 1, 3]), ([3, 0, 1, 0, 4, 1, 1], [3, 0, 1, 0, 3, 2, 1]), ([3, 3, 3, 0, 0, 1, 0], [3, 2, 3, 0, 0, 1, 1]), ([1, 2, 0, 1, 1, 1, 4], [1, 1, 0, 1, 2, 1, 4]), ([1, 1, 0, 3, 2, 2, 1], [2, 1, 0, 3, 1, 2, 1]), ([3, 0, 1, 1, 0, 5, 0], [3, 0, 1, 0, 0, 6, 0]), ([2, 7, 0, 0, 1, 0, 0], [1, 7, 0, 0, 1, 0, 1]), ([2, 2, 1, 0, 1, 0, 4], [3, 2, 0, 0, 1, 0, 4]), ([2, 3, 0, 0, 4, 1, 0], [2, 4, 0, 0, 4, 0, 0]), ([2, 4, 0, 0, 3, 1, 0], [2, 4, 0, 0, 2, 1, 1])] 
 1092    44.023325
6435    29.712577
7024    50.651334
4257    18.106888
3840    31.028331
6445    29.050236
6288    61.609420
5920    23.019970
6059    33.232156
6179    36.082312
Name: obj, dtype: float64
Schedule: [3, 0, 1, 0, 4, 1, 1], ewt = 29.71257736182595</code></pre>
</div>
</div>
<section id="flow-chart-of-objective-calculation-method" class="level3">
<h3 class="anchored" data-anchor-id="flow-chart-of-objective-calculation-method">Flow chart of objective calculation method</h3>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    A[Start] --&gt; B[Adjust service times distribution for no-shows]
    B --&gt; C[Set probability of first spillover time being zero to 1]
    C --&gt; D[Initialize wt_list and ewt &lt;/br&gt; for saving waiting times distributions and &lt;/br&gt;accumulated expected waiting time]
    D --&gt; E[Loop through each interval in schedule]
    
    E --&gt; F{Is x == 0?}
    
    F --&gt;|Yes| G[Record spillover from previous interval]
    G --&gt; H[Append empty list to wt_list]
    H --&gt; I[Initialize spillover time distribution]
    I --&gt; J[Calculate spillover for next interval]
    J --&gt; K[Continue to next interval]

    F --&gt;|No| L[Initialize wt_temp for current interval]
    L --&gt; M[Add spillover from previous interval &lt;/br&gt;as waiting time for first patient in current interval]
    M --&gt; N[Loop through each patient in interval]
    
    N --&gt; O[Calculate waiting time distribution for current patient]
    O --&gt; P[Append waiting time distribution to wt_temp]
    P --&gt; Q[Add expected waiting time for current patient to ewt]
    Q --&gt; R[Append wt_temp to wt_list]
    
    R --&gt; S[Initialize spillover time distribution]
    S --&gt; T[Calculate spillover for next interval]
    T --&gt; K[Continue to next interval]
    
    K --&gt; U[Print wt_list]
    U --&gt; V[Print schedule and ewt]
    V --&gt; W[End]

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="flow-chart-data-preparation" class="level3">
<h3 class="anchored" data-anchor-id="flow-chart-data-preparation">Flow chart data preparation</h3>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    A["Create features"] --&gt;|"option 1"| B["from population"]
    A["Create features"] --&gt;|"option 2"| C["random subset"]
    B --&gt; D["Create pairs"]
    C --&gt; D["Create pairs"]
    D["Create pairs"] --&gt;|"option 1"| E["random"]
    D["Create pairs"] --&gt;|"option 2"| F["neighbors"]
    E --&gt; G["Create labels"]
    F --&gt; G["Create labels"]
    G["Create labels"] --&gt;|"option 1"| H["objective"]
    G["Create labels"] --&gt;|"option 2"| I["ranking"]
    H --&gt; J["Split dataset"]
    I --&gt; J["Split dataset"]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>